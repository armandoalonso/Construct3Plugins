@@START rot.js|.js|false|true|false|inline-script
@@TEMPLATE
this._info.AddFileDependency(
{
    filename: "c3runtime/rot.js",
    type: ""
});
@@CONTENT
/*
	This is rot.js, the ROguelike Toolkit in JavaScript.
	Version 0.7~dev, generated on Thu Sep 13 12:51:19 CEST 2018.
*/
(function(root, factory)
{
    if (typeof define === 'function' && define.amd)
    {
        // AMD. Register as an anonymous module.
        define([], factory);
    }
    else if (typeof exports === 'object')
    {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    }
    else
    {
        // Browser globals (root is window)
        root.ROT = factory();
    }
}(this, function()
{
    /**
     * @namespace Top-level ROT namespace
     */
    var ROT = {
        /**
         * @returns {bool} Is rot.js supported by this browser?
         */
        isSupported: function()
        {
            return !!(document.createElement("canvas").getContext && Function.prototype.bind);
        },

        /** Default with for display and map generators */
        DEFAULT_WIDTH: 80,
        /** Default height for display and map generators */
        DEFAULT_HEIGHT: 25,

        /** Directional constants. Ordering is important! */
        DIRS: {
            "4": [
            [0, -1],
            [1, 0],
            [0, 1],
            [-1, 0]
        ],
            "8": [
            [0, -1],
            [1, -1],
            [1, 0],
            [1, 1],
            [0, 1],
            [-1, 1],
            [-1, 0],
            [-1, -1]
        ],
            "6": [
            [-1, -1],
            [1, -1],
            [2, 0],
            [1, 1],
            [-1, 1],
            [-2, 0]
        ]
        },

        /** Cancel key. */
        VK_CANCEL: 3,
        /** Help key. */
        VK_HELP: 6,
        /** Backspace key. */
        VK_BACK_SPACE: 8,
        /** Tab key. */
        VK_TAB: 9,
        /** 5 key on Numpad when NumLock is unlocked. Or on Mac, clear key which is positioned at NumLock key. */
        VK_CLEAR: 12,
        /** Return/enter key on the main keyboard. */
        VK_RETURN: 13,
        /** Reserved, but not used. */
        VK_ENTER: 14,
        /** Shift key. */
        VK_SHIFT: 16,
        /** Control key. */
        VK_CONTROL: 17,
        /** Alt (Option on Mac) key. */
        VK_ALT: 18,
        /** Pause key. */
        VK_PAUSE: 19,
        /** Caps lock. */
        VK_CAPS_LOCK: 20,
        /** Escape key. */
        VK_ESCAPE: 27,
        /** Space bar. */
        VK_SPACE: 32,
        /** Page Up key. */
        VK_PAGE_UP: 33,
        /** Page Down key. */
        VK_PAGE_DOWN: 34,
        /** End key. */
        VK_END: 35,
        /** Home key. */
        VK_HOME: 36,
        /** Left arrow. */
        VK_LEFT: 37,
        /** Up arrow. */
        VK_UP: 38,
        /** Right arrow. */
        VK_RIGHT: 39,
        /** Down arrow. */
        VK_DOWN: 40,
        /** Print Screen key. */
        VK_PRINTSCREEN: 44,
        /** Ins(ert) key. */
        VK_INSERT: 45,
        /** Del(ete) key. */
        VK_DELETE: 46,
        /***/
        VK_0: 48,
        /***/
        VK_1: 49,
        /***/
        VK_2: 50,
        /***/
        VK_3: 51,
        /***/
        VK_4: 52,
        /***/
        VK_5: 53,
        /***/
        VK_6: 54,
        /***/
        VK_7: 55,
        /***/
        VK_8: 56,
        /***/
        VK_9: 57,
        /** Colon (:) key. Requires Gecko 15.0 */
        VK_COLON: 58,
        /** Semicolon (;) key. */
        VK_SEMICOLON: 59,
        /** Less-than (<) key. Requires Gecko 15.0 */
        VK_LESS_THAN: 60,
        /** Equals (=) key. */
        VK_EQUALS: 61,
        /** Greater-than (>) key. Requires Gecko 15.0 */
        VK_GREATER_THAN: 62,
        /** Question mark (?) key. Requires Gecko 15.0 */
        VK_QUESTION_MARK: 63,
        /** Atmark (@) key. Requires Gecko 15.0 */
        VK_AT: 64,
        /***/
        VK_A: 65,
        /***/
        VK_B: 66,
        /***/
        VK_C: 67,
        /***/
        VK_D: 68,
        /***/
        VK_E: 69,
        /***/
        VK_F: 70,
        /***/
        VK_G: 71,
        /***/
        VK_H: 72,
        /***/
        VK_I: 73,
        /***/
        VK_J: 74,
        /***/
        VK_K: 75,
        /***/
        VK_L: 76,
        /***/
        VK_M: 77,
        /***/
        VK_N: 78,
        /***/
        VK_O: 79,
        /***/
        VK_P: 80,
        /***/
        VK_Q: 81,
        /***/
        VK_R: 82,
        /***/
        VK_S: 83,
        /***/
        VK_T: 84,
        /***/
        VK_U: 85,
        /***/
        VK_V: 86,
        /***/
        VK_W: 87,
        /***/
        VK_X: 88,
        /***/
        VK_Y: 89,
        /***/
        VK_Z: 90,
        /***/
        VK_CONTEXT_MENU: 93,
        /** 0 on the numeric keypad. */
        VK_NUMPAD0: 96,
        /** 1 on the numeric keypad. */
        VK_NUMPAD1: 97,
        /** 2 on the numeric keypad. */
        VK_NUMPAD2: 98,
        /** 3 on the numeric keypad. */
        VK_NUMPAD3: 99,
        /** 4 on the numeric keypad. */
        VK_NUMPAD4: 100,
        /** 5 on the numeric keypad. */
        VK_NUMPAD5: 101,
        /** 6 on the numeric keypad. */
        VK_NUMPAD6: 102,
        /** 7 on the numeric keypad. */
        VK_NUMPAD7: 103,
        /** 8 on the numeric keypad. */
        VK_NUMPAD8: 104,
        /** 9 on the numeric keypad. */
        VK_NUMPAD9: 105,
        /** * on the numeric keypad. */
        VK_MULTIPLY: 106,
        /** + on the numeric keypad. */
        VK_ADD: 107,
        /***/
        VK_SEPARATOR: 108,
        /** - on the numeric keypad. */
        VK_SUBTRACT: 109,
        /** Decimal point on the numeric keypad. */
        VK_DECIMAL: 110,
        /** / on the numeric keypad. */
        VK_DIVIDE: 111,
        /** F1 key. */
        VK_F1: 112,
        /** F2 key. */
        VK_F2: 113,
        /** F3 key. */
        VK_F3: 114,
        /** F4 key. */
        VK_F4: 115,
        /** F5 key. */
        VK_F5: 116,
        /** F6 key. */
        VK_F6: 117,
        /** F7 key. */
        VK_F7: 118,
        /** F8 key. */
        VK_F8: 119,
        /** F9 key. */
        VK_F9: 120,
        /** F10 key. */
        VK_F10: 121,
        /** F11 key. */
        VK_F11: 122,
        /** F12 key. */
        VK_F12: 123,
        /** F13 key. */
        VK_F13: 124,
        /** F14 key. */
        VK_F14: 125,
        /** F15 key. */
        VK_F15: 126,
        /** F16 key. */
        VK_F16: 127,
        /** F17 key. */
        VK_F17: 128,
        /** F18 key. */
        VK_F18: 129,
        /** F19 key. */
        VK_F19: 130,
        /** F20 key. */
        VK_F20: 131,
        /** F21 key. */
        VK_F21: 132,
        /** F22 key. */
        VK_F22: 133,
        /** F23 key. */
        VK_F23: 134,
        /** F24 key. */
        VK_F24: 135,
        /** Num Lock key. */
        VK_NUM_LOCK: 144,
        /** Scroll Lock key. */
        VK_SCROLL_LOCK: 145,
        /** Circumflex (^) key. Requires Gecko 15.0 */
        VK_CIRCUMFLEX: 160,
        /** Exclamation (!) key. Requires Gecko 15.0 */
        VK_EXCLAMATION: 161,
        /** Double quote () key. Requires Gecko 15.0 */
        VK_DOUBLE_QUOTE: 162,
        /** Hash (#) key. Requires Gecko 15.0 */
        VK_HASH: 163,
        /** Dollar sign ($) key. Requires Gecko 15.0 */
        VK_DOLLAR: 164,
        /** Percent (%) key. Requires Gecko 15.0 */
        VK_PERCENT: 165,
        /** Ampersand (&) key. Requires Gecko 15.0 */
        VK_AMPERSAND: 166,
        /** Underscore (_) key. Requires Gecko 15.0 */
        VK_UNDERSCORE: 167,
        /** Open parenthesis (() key. Requires Gecko 15.0 */
        VK_OPEN_PAREN: 168,
        /** Close parenthesis ()) key. Requires Gecko 15.0 */
        VK_CLOSE_PAREN: 169,
        /* Asterisk (*) key. Requires Gecko 15.0 */
        VK_ASTERISK: 170,
        /** Plus (+) key. Requires Gecko 15.0 */
        VK_PLUS: 171,
        /** Pipe (|) key. Requires Gecko 15.0 */
        VK_PIPE: 172,
        /** Hyphen-US/docs/Minus (-) key. Requires Gecko 15.0 */
        VK_HYPHEN_MINUS: 173,
        /** Open curly bracket ({) key. Requires Gecko 15.0 */
        VK_OPEN_CURLY_BRACKET: 174,
        /** Close curly bracket (}) key. Requires Gecko 15.0 */
        VK_CLOSE_CURLY_BRACKET: 175,
        /** Tilde (~) key. Requires Gecko 15.0 */
        VK_TILDE: 176,
        /** Comma (,) key. */
        VK_COMMA: 188,
        /** Period (.) key. */
        VK_PERIOD: 190,
        /** Slash (/) key. */
        VK_SLASH: 191,
        /** Back tick (`) key. */
        VK_BACK_QUOTE: 192,
        /** Open square bracket ([) key. */
        VK_OPEN_BRACKET: 219,
        /** Back slash (\) key. */
        VK_BACK_SLASH: 220,
        /** Close square bracket (]) key. */
        VK_CLOSE_BRACKET: 221,
        /** Quote (''') key. */
        VK_QUOTE: 222,
        /** Meta key on Linux, Command key on Mac. */
        VK_META: 224,
        /** AltGr key on Linux. Requires Gecko 15.0 */
        VK_ALTGR: 225,
        /** Windows logo key on Windows. Or Super or Hyper key on Linux. Requires Gecko 15.0 */
        VK_WIN: 91,
        /** Linux support for this keycode was added in Gecko 4.0. */
        VK_KANA: 21,
        /** Linux support for this keycode was added in Gecko 4.0. */
        VK_HANGUL: 21,
        /** 英数 key on Japanese Mac keyboard. Requires Gecko 15.0 */
        VK_EISU: 22,
        /** Linux support for this keycode was added in Gecko 4.0. */
        VK_JUNJA: 23,
        /** Linux support for this keycode was added in Gecko 4.0. */
        VK_FINAL: 24,
        /** Linux support for this keycode was added in Gecko 4.0. */
        VK_HANJA: 25,
        /** Linux support for this keycode was added in Gecko 4.0. */
        VK_KANJI: 25,
        /** Linux support for this keycode was added in Gecko 4.0. */
        VK_CONVERT: 28,
        /** Linux support for this keycode was added in Gecko 4.0. */
        VK_NONCONVERT: 29,
        /** Linux support for this keycode was added in Gecko 4.0. */
        VK_ACCEPT: 30,
        /** Linux support for this keycode was added in Gecko 4.0. */
        VK_MODECHANGE: 31,
        /** Linux support for this keycode was added in Gecko 4.0. */
        VK_SELECT: 41,
        /** Linux support for this keycode was added in Gecko 4.0. */
        VK_PRINT: 42,
        /** Linux support for this keycode was added in Gecko 4.0. */
        VK_EXECUTE: 43,
        /** Linux support for this keycode was added in Gecko 4.0.	 */
        VK_SLEEP: 95
    };
    /**
     * @namespace
     * Contains text tokenization and breaking routines
     */
    ROT.Text = {
        RE_COLORS: /%([bc]){([^}]*)}/g,

        /* token types */
        TYPE_TEXT: 0,
        TYPE_NEWLINE: 1,
        TYPE_FG: 2,
        TYPE_BG: 3,

        /**
         * Measure size of a resulting text block
         */
        measure: function(str, maxWidth)
        {
            var result = {
                width: 0,
                height: 1
            };
            var tokens = this.tokenize(str, maxWidth);
            var lineWidth = 0;

            for (var i = 0; i < tokens.length; i++)
            {
                var token = tokens[i];
                switch (token.type)
                {
                    case this.TYPE_TEXT:
                        lineWidth += token.value.length;
                        break;

                    case this.TYPE_NEWLINE:
                        result.height++;
                        result.width = Math.max(result.width, lineWidth);
                        lineWidth = 0;
                        break;
                }
            }
            result.width = Math.max(result.width, lineWidth);

            return result;
        },

        /**
         * Convert string to a series of a formatting commands
         */
        tokenize: function(str, maxWidth)
        {
            var result = [];

            /* first tokenization pass - split texts and color formatting commands */
            var offset = 0;
            str.replace(this.RE_COLORS, function(match, type, name, index)
            {
                /* string before */
                var part = str.substring(offset, index);
                if (part.length)
                {
                    result.push(
                    {
                        type: ROT.Text.TYPE_TEXT,
                        value: part
                    });
                }

                /* color command */
                result.push(
                {
                    type: (type == "c" ? ROT.Text.TYPE_FG : ROT.Text.TYPE_BG),
                    value: name.trim()
                });

                offset = index + match.length;
                return "";
            });

            /* last remaining part */
            var part = str.substring(offset);
            if (part.length)
            {
                result.push(
                {
                    type: ROT.Text.TYPE_TEXT,
                    value: part
                });
            }

            return this._breakLines(result, maxWidth);
        },

        /* insert line breaks into first-pass tokenized data */
        _breakLines: function(tokens, maxWidth)
        {
            if (!maxWidth)
            {
                maxWidth = Infinity;
            }

            var i = 0;
            var lineLength = 0;
            var lastTokenWithSpace = -1;

            while (i < tokens.length)
            { /* take all text tokens, remove space, apply linebreaks */
                var token = tokens[i];
                if (token.type == ROT.Text.TYPE_NEWLINE)
                { /* reset */
                    lineLength = 0;
                    lastTokenWithSpace = -1;
                }
                if (token.type != ROT.Text.TYPE_TEXT)
                { /* skip non-text tokens */
                    i++;
                    continue;
                }

                /* remove spaces at the beginning of line */
                while (lineLength == 0 && token.value.charAt(0) == " ")
                {
                    token.value = token.value.substring(1);
                }

                /* forced newline? insert two new tokens after this one */
                var index = token.value.indexOf("\n");
                if (index != -1)
                {
                    token.value = this._breakInsideToken(tokens, i, index, true);

                    /* if there are spaces at the end, we must remove them (we do not want the line too long) */
                    var arr = token.value.split("");
                    while (arr.length && arr[arr.length - 1] == " ")
                    {
                        arr.pop();
                    }
                    token.value = arr.join("");
                }

                /* token degenerated? */
                if (!token.value.length)
                {
                    tokens.splice(i, 1);
                    continue;
                }

                if (lineLength + token.value.length > maxWidth)
                { /* line too long, find a suitable breaking spot */

                    /* is it possible to break within this token? */
                    var index = -1;
                    while (1)
                    {
                        var nextIndex = token.value.indexOf(" ", index + 1);
                        if (nextIndex == -1)
                        {
                            break;
                        }
                        if (lineLength + nextIndex > maxWidth)
                        {
                            break;
                        }
                        index = nextIndex;
                    }

                    if (index != -1)
                    { /* break at space within this one */
                        token.value = this._breakInsideToken(tokens, i, index, true);
                    }
                    else if (lastTokenWithSpace != -1)
                    { /* is there a previous token where a break can occur? */
                        var token = tokens[lastTokenWithSpace];
                        var breakIndex = token.value.lastIndexOf(" ");
                        token.value = this._breakInsideToken(tokens, lastTokenWithSpace, breakIndex, true);
                        i = lastTokenWithSpace;
                    }
                    else
                    { /* force break in this token */
                        token.value = this._breakInsideToken(tokens, i, maxWidth - lineLength, false);
                    }

                }
                else
                { /* line not long, continue */
                    lineLength += token.value.length;
                    if (token.value.indexOf(" ") != -1)
                    {
                        lastTokenWithSpace = i;
                    }
                }

                i++; /* advance to next token */
            }


            tokens.push(
            {
                type: ROT.Text.TYPE_NEWLINE
            }); /* insert fake newline to fix the last text line */

            /* remove trailing space from text tokens before newlines */
            var lastTextToken = null;
            for (var i = 0; i < tokens.length; i++)
            {
                var token = tokens[i];
                switch (token.type)
                {
                    case ROT.Text.TYPE_TEXT:
                        lastTextToken = token;
                        break;
                    case ROT.Text.TYPE_NEWLINE:
                        if (lastTextToken)
                        { /* remove trailing space */
                            var arr = lastTextToken.value.split("");
                            while (arr.length && arr[arr.length - 1] == " ")
                            {
                                arr.pop();
                            }
                            lastTextToken.value = arr.join("");
                        }
                        lastTextToken = null;
                        break;
                }
            }

            tokens.pop(); /* remove fake token */

            return tokens;
        },

        /**
         * Create new tokens and insert them into the stream
         * @param {object[]} tokens
         * @param {int} tokenIndex Token being processed
         * @param {int} breakIndex Index within current token's value
         * @param {bool} removeBreakChar Do we want to remove the breaking character?
         * @returns {string} remaining unbroken token value
         */
        _breakInsideToken: function(tokens, tokenIndex, breakIndex, removeBreakChar)
        {
            var newBreakToken = {
                type: ROT.Text.TYPE_NEWLINE
            };
            var newTextToken = {
                type: ROT.Text.TYPE_TEXT,
                value: tokens[tokenIndex].value.substring(breakIndex + (removeBreakChar ? 1 : 0))
            };
            tokens.splice(tokenIndex + 1, 0, newBreakToken, newTextToken);
            return tokens[tokenIndex].value.substring(0, breakIndex);
        }
    };
    /**
     * @returns {any} Randomly picked item, null when length=0
     */
    Array.prototype.random = Array.prototype.random || function()
    {
        if (!this.length)
        {
            return null;
        }
        return this[Math.floor(ROT.RNG.getUniform() * this.length)];
    };

    /**
     * @returns {array} New array with randomized items
     */
    Array.prototype.randomize = Array.prototype.randomize || function()
    {
        var result = [];
        var clone = this.slice();
        while (clone.length)
        {
            var index = clone.indexOf(clone.random());
            result.push(clone.splice(index, 1)[0]);
        }
        return result;
    };
    /**
     * Always positive modulus
     * @param {int} n Modulus
     * @returns {int} this modulo n
     */
    Number.prototype.mod = Number.prototype.mod || function(n)
    {
        return ((this % n) + n) % n;
    };
    /**
     * @returns {string} First letter capitalized
     */
    String.prototype.capitalize = String.prototype.capitalize || function()
    {
        return this.charAt(0).toUpperCase() + this.substring(1);
    };

    /** 
     * Left pad
     * @param {string} [character="0"]
     * @param {int} [count=2]
     */
    String.prototype.lpad = String.prototype.lpad || function(character, count)
    {
        var ch = character || "0";
        var cnt = count || 2;

        var s = "";
        while (s.length < (cnt - this.length))
        {
            s += ch;
        }
        s = s.substring(0, cnt - this.length);
        return s + this;
    };

    /** 
     * Right pad
     * @param {string} [character="0"]
     * @param {int} [count=2]
     */
    String.prototype.rpad = String.prototype.rpad || function(character, count)
    {
        var ch = character || "0";
        var cnt = count || 2;

        var s = "";
        while (s.length < (cnt - this.length))
        {
            s += ch;
        }
        s = s.substring(0, cnt - this.length);
        return this + s;
    };

    /**
     * Format a string in a flexible way. Scans for %s strings and replaces them with arguments. List of patterns is modifiable via String.format.map.
     * @param {string} template
     * @param {any} [argv]
     */
    String.format = String.format || function(template)
    {
        var map = String.format.map;
        var args = Array.prototype.slice.call(arguments, 1);

        var replacer = function(match, group1, group2, index)
        {
            if (template.charAt(index - 1) == "%")
            {
                return match.substring(1);
            }
            if (!args.length)
            {
                return match;
            }
            var obj = args[0];

            var group = group1 || group2;
            var parts = group.split(",");
            var name = parts.shift();
            var method = map[name.toLowerCase()];
            if (!method)
            {
                return match;
            }

            var obj = args.shift();
            var replaced = obj[method].apply(obj, parts);

            var first = name.charAt(0);
            if (first != first.toLowerCase())
            {
                replaced = replaced.capitalize();
            }

            return replaced;
        };
        return template.replace(/%(?:([a-z]+)|(?:{([^}]+)}))/gi, replacer);
    };

    String.format.map = String.format.map || {
        "s": "toString"
    };

    /**
     * Convenience shortcut to String.format(this)
     */
    String.prototype.format = String.prototype.format || function()
    {
        var args = Array.prototype.slice.call(arguments);
        args.unshift(this);
        return String.format.apply(String, args);
    };

    if (!Object.create)
    {
        /**
         * ES5 Object.create
         */
        Object.create = function(o)
        {
            var tmp = function()
            {};
            tmp.prototype = o;
            return new tmp();
        };
    }
    /**
     * Sets prototype of this function to an instance of parent function
     * @param {function} parent
     */
    Function.prototype.extend = Function.prototype.extend || function(parent)
    {
        this.prototype = Object.create(parent.prototype);
        this.prototype.constructor = this;
        return this;
    };
    if (typeof window != "undefined")
    {
        window.requestAnimationFrame =
            window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(cb)
        {
            return setTimeout(function()
            {
                cb(Date.now());
            }, 1000 / 60);
        };

        window.cancelAnimationFrame =
            window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function(id)
        {
            return clearTimeout(id);
        };
    }
    /**
     * @class Visual map display
     * @param {object} [options]
     * @param {int} [options.width=ROT.DEFAULT_WIDTH]
     * @param {int} [options.height=ROT.DEFAULT_HEIGHT]
     * @param {int} [options.fontSize=15]
     * @param {string} [options.fontFamily="monospace"]
     * @param {string} [options.fontStyle=""] bold/italic/none/both
     * @param {string} [options.fg="#ccc"]
     * @param {string} [options.bg="#000"]
     * @param {float} [options.spacing=1]
     * @param {float} [options.border=0]
     * @param {string} [options.layout="rect"]
     * @param {bool} [options.forceSquareRatio=false]
     * @param {int} [options.tileWidth=32]
     * @param {int} [options.tileHeight=32]
     * @param {object} [options.tileMap={}]
     * @param {image} [options.tileSet=null]
     * @param {image} [options.tileColorize=false]
     */
    ROT.Display = function(options)
    {
        var canvas = document.createElement("canvas");
        this._context = canvas.getContext("2d");
        this._data = {};
        this._dirty = false; /* false = nothing, true = all, object = dirty cells */
        this._options = {};
        this._backend = null;

        var defaultOptions = {
            width: ROT.DEFAULT_WIDTH,
            height: ROT.DEFAULT_HEIGHT,
            transpose: false,
            layout: "rect",
            fontSize: 15,
            spacing: 1,
            border: 0,
            forceSquareRatio: false,
            fontFamily: "monospace",
            fontStyle: "",
            fg: "#ccc",
            bg: "#000",
            tileWidth: 32,
            tileHeight: 32,
            tileMap: {},
            tileSet: null,
            tileColorize: false,
            termColor: "xterm"
        };
        for (var p in options)
        {
            defaultOptions[p] = options[p];
        }
        this.setOptions(defaultOptions);
        this.DEBUG = this.DEBUG.bind(this);

        this._tick = this._tick.bind(this);
        requestAnimationFrame(this._tick);
    };

    /**
     * Debug helper, ideal as a map generator callback. Always bound to this.
     * @param {int} x
     * @param {int} y
     * @param {int} what
     */
    ROT.Display.prototype.DEBUG = function(x, y, what)
    {
        var colors = [this._options.bg, this._options.fg];
        this.draw(x, y, null, null, colors[what % colors.length]);
    };

    /**
     * Clear the whole display (cover it with background color)
     */
    ROT.Display.prototype.clear = function()
    {
        this._data = {};
        this._dirty = true;
    };

    /**
     * @see ROT.Display
     */
    ROT.Display.prototype.setOptions = function(options)
    {
        for (var p in options)
        {
            this._options[p] = options[p];
        }
        if (options.width || options.height || options.fontSize || options.fontFamily || options.spacing || options.layout)
        {
            if (options.layout)
            {
                this._backend = new ROT.Display[options.layout.capitalize()](this._context);
            }

            var font = (this._options.fontStyle ? this._options.fontStyle + " " : "") + this._options.fontSize + "px " + this._options.fontFamily;
            this._context.font = font;
            this._backend.compute(this._options);
            this._context.font = font;
            this._context.textAlign = "center";
            this._context.textBaseline = "middle";
            this._dirty = true;
        }
        return this;
    };

    /**
     * Returns currently set options
     * @returns {object} Current options object
     */
    ROT.Display.prototype.getOptions = function()
    {
        return this._options;
    };

    /**
     * Returns the DOM node of this display
     * @returns {node} DOM node
     */
    ROT.Display.prototype.getContainer = function()
    {
        return this._context.canvas;
    };

    /**
     * Compute the maximum width/height to fit into a set of given constraints
     * @param {int} availWidth Maximum allowed pixel width
     * @param {int} availHeight Maximum allowed pixel height
     * @returns {int[2]} cellWidth,cellHeight
     */
    ROT.Display.prototype.computeSize = function(availWidth, availHeight)
    {
        return this._backend.computeSize(availWidth, availHeight, this._options);
    };

    /**
     * Compute the maximum font size to fit into a set of given constraints
     * @param {int} availWidth Maximum allowed pixel width
     * @param {int} availHeight Maximum allowed pixel height
     * @returns {int} fontSize
     */
    ROT.Display.prototype.computeFontSize = function(availWidth, availHeight)
    {
        return this._backend.computeFontSize(availWidth, availHeight, this._options);
    };

    /**
     * Convert a DOM event (mouse or touch) to map coordinates. Uses first touch for multi-touch.
     * @param {Event} e event
     * @returns {int[2]} -1 for values outside of the canvas
     */
    ROT.Display.prototype.eventToPosition = function(e)
    {
        if (e.touches)
        {
            var x = e.touches[0].clientX;
            var y = e.touches[0].clientY;
        }
        else
        {
            var x = e.clientX;
            var y = e.clientY;
        }

        var rect = this._context.canvas.getBoundingClientRect();
        x -= rect.left;
        y -= rect.top;

        x *= this._context.canvas.width / rect.width;
        y *= this._context.canvas.height / rect.height;

        if (x < 0 || y < 0 || x >= this._context.canvas.width || y >= this._context.canvas.height)
        {
            return [-1, -1];
        }

        return this._backend.eventToPosition(x, y);
    };

    /**
     * @param {int} x
     * @param {int} y
     * @param {string || string[]} ch One or more chars (will be overlapping themselves)
     * @param {string} [fg] foreground color
     * @param {string} [bg] background color
     */
    ROT.Display.prototype.draw = function(x, y, ch, fg, bg)
    {
        if (!fg)
        {
            fg = this._options.fg;
        }
        if (!bg)
        {
            bg = this._options.bg;
        }
        this._data[x + "," + y] = [x, y, ch, fg, bg];

        if (this._dirty === true)
        {
            return;
        } /* will already redraw everything */
        if (!this._dirty)
        {
            this._dirty = {};
        } /* first! */
        this._dirty[x + "," + y] = true;
    };

    /**
     * Draws a text at given position. Optionally wraps at a maximum length. Currently does not work with hex layout.
     * @param {int} x
     * @param {int} y
     * @param {string} text May contain color/background format specifiers, %c{name}/%b{name}, both optional. %c{}/%b{} resets to default.
     * @param {int} [maxWidth] wrap at what width?
     * @returns {int} lines drawn
     */
    ROT.Display.prototype.drawText = function(x, y, text, maxWidth)
    {
        var fg = null;
        var bg = null;
        var cx = x;
        var cy = y;
        var lines = 1;
        if (!maxWidth)
        {
            maxWidth = this._options.width - x;
        }

        var tokens = ROT.Text.tokenize(text, maxWidth);

        while (tokens.length)
        { /* interpret tokenized opcode stream */
            var token = tokens.shift();
            switch (token.type)
            {
                case ROT.Text.TYPE_TEXT:
                    var isSpace = false,
                        isPrevSpace = false,
                        isFullWidth = false,
                        isPrevFullWidth = false;
                    for (var i = 0; i < token.value.length; i++)
                    {
                        var cc = token.value.charCodeAt(i);
                        var c = token.value.charAt(i);
                        // Assign to `true` when the current char is full-width.
                        isFullWidth = (cc > 0xff00 && cc < 0xff61) || (cc > 0xffdc && cc < 0xffe8) || cc > 0xffee;
                        // Current char is space, whatever full-width or half-width both are OK.
                        isSpace = (c.charCodeAt(0) == 0x20 || c.charCodeAt(0) == 0x3000);
                        // The previous char is full-width and
                        // current char is nether half-width nor a space.
                        if (isPrevFullWidth && !isFullWidth && !isSpace)
                        {
                            cx++;
                        } // add an extra position
                        // The current char is full-width and
                        // the previous char is not a space.
                        if (isFullWidth && !isPrevSpace)
                        {
                            cx++;
                        } // add an extra position
                        this.draw(cx++, cy, c, fg, bg);
                        isPrevSpace = isSpace;
                        isPrevFullWidth = isFullWidth;
                    }
                    break;

                case ROT.Text.TYPE_FG:
                    fg = token.value || null;
                    break;

                case ROT.Text.TYPE_BG:
                    bg = token.value || null;
                    break;

                case ROT.Text.TYPE_NEWLINE:
                    cx = x;
                    cy++;
                    lines++;
                    break;
            }
        }

        return lines;
    };

    /**
     * Timer tick: update dirty parts
     */
    ROT.Display.prototype._tick = function()
    {
        requestAnimationFrame(this._tick);

        if (!this._dirty)
        {
            return;
        }

        if (this._dirty === true)
        { /* draw all */
            this._context.fillStyle = this._options.bg;
            this._context.fillRect(0, 0, this._context.canvas.width, this._context.canvas.height);

            for (var id in this._data)
            { /* redraw cached data */
                this._draw(id, false);
            }

        }
        else
        { /* draw only dirty */
            for (var key in this._dirty)
            {
                this._draw(key, true);
            }
        }

        this._dirty = false;
    };

    /**
     * @param {string} key What to draw
     * @param {bool} clearBefore Is it necessary to clean before?
     */
    ROT.Display.prototype._draw = function(key, clearBefore)
    {
        var data = this._data[key];
        if (data[4] != this._options.bg)
        {
            clearBefore = true;
        }

        this._backend.draw(data, clearBefore);
    };
    /**
     * @class Abstract display backend module
     * @private
     */
    ROT.Display.Backend = function(context)
    {
        this._context = context;
    };

    ROT.Display.Backend.prototype.compute = function(options)
    {};

    ROT.Display.Backend.prototype.draw = function(data, clearBefore)
    {};

    ROT.Display.Backend.prototype.computeSize = function(availWidth, availHeight)
    {};

    ROT.Display.Backend.prototype.computeFontSize = function(availWidth, availHeight)
    {};

    ROT.Display.Backend.prototype.eventToPosition = function(x, y)
    {};
    /**
     * @class Rectangular backend
     * @private
     */
    ROT.Display.Rect = function(context)
    {
        ROT.Display.Backend.call(this, context);

        this._spacingX = 0;
        this._spacingY = 0;
        this._canvasCache = {};
        this._options = {};
    };
    ROT.Display.Rect.extend(ROT.Display.Backend);

    ROT.Display.Rect.cache = false;

    ROT.Display.Rect.prototype.compute = function(options)
    {
        this._canvasCache = {};
        this._options = options;

        var charWidth = Math.ceil(this._context.measureText("W").width);
        this._spacingX = Math.ceil(options.spacing * charWidth);
        this._spacingY = Math.ceil(options.spacing * options.fontSize);

        if (this._options.forceSquareRatio)
        {
            this._spacingX = this._spacingY = Math.max(this._spacingX, this._spacingY);
        }

        this._context.canvas.width = options.width * this._spacingX;
        this._context.canvas.height = options.height * this._spacingY;
    };

    ROT.Display.Rect.prototype.draw = function(data, clearBefore)
    {
        if (this.constructor.cache)
        {
            this._drawWithCache(data, clearBefore);
        }
        else
        {
            this._drawNoCache(data, clearBefore);
        }
    };

    ROT.Display.Rect.prototype._drawWithCache = function(data, clearBefore)
    {
        var x = data[0];
        var y = data[1];
        var ch = data[2];
        var fg = data[3];
        var bg = data[4];

        var hash = "" + ch + fg + bg;
        if (hash in this._canvasCache)
        {
            var canvas = this._canvasCache[hash];
        }
        else
        {
            var b = this._options.border;
            var canvas = document.createElement("canvas");
            var ctx = canvas.getContext("2d");
            canvas.width = this._spacingX;
            canvas.height = this._spacingY;
            ctx.fillStyle = bg;
            ctx.fillRect(b, b, canvas.width - b, canvas.height - b);

            if (ch)
            {
                ctx.fillStyle = fg;
                ctx.font = this._context.font;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";

                var chars = [].concat(ch);
                for (var i = 0; i < chars.length; i++)
                {
                    ctx.fillText(chars[i], this._spacingX / 2, Math.ceil(this._spacingY / 2));
                }
            }
            this._canvasCache[hash] = canvas;
        }

        this._context.drawImage(canvas, x * this._spacingX, y * this._spacingY);
    };

    ROT.Display.Rect.prototype._drawNoCache = function(data, clearBefore)
    {
        var x = data[0];
        var y = data[1];
        var ch = data[2];
        var fg = data[3];
        var bg = data[4];

        if (clearBefore)
        {
            var b = this._options.border;
            this._context.fillStyle = bg;
            this._context.fillRect(x * this._spacingX + b, y * this._spacingY + b, this._spacingX - b, this._spacingY - b);
        }

        if (!ch)
        {
            return;
        }

        this._context.fillStyle = fg;

        var chars = [].concat(ch);
        for (var i = 0; i < chars.length; i++)
        {
            this._context.fillText(chars[i], (x + 0.5) * this._spacingX, Math.ceil((y + 0.5) * this._spacingY));
        }
    };

    ROT.Display.Rect.prototype.computeSize = function(availWidth, availHeight)
    {
        var width = Math.floor(availWidth / this._spacingX);
        var height = Math.floor(availHeight / this._spacingY);
        return [width, height];
    };

    ROT.Display.Rect.prototype.computeFontSize = function(availWidth, availHeight)
    {
        var boxWidth = Math.floor(availWidth / this._options.width);
        var boxHeight = Math.floor(availHeight / this._options.height);

        /* compute char ratio */
        var oldFont = this._context.font;
        this._context.font = "100px " + this._options.fontFamily;
        var width = Math.ceil(this._context.measureText("W").width);
        this._context.font = oldFont;
        var ratio = width / 100;

        var widthFraction = ratio * boxHeight / boxWidth;
        if (widthFraction > 1)
        { /* too wide with current aspect ratio */
            boxHeight = Math.floor(boxHeight / widthFraction);
        }
        return Math.floor(boxHeight / this._options.spacing);
    };

    ROT.Display.Rect.prototype.eventToPosition = function(x, y)
    {
        return [Math.floor(x / this._spacingX), Math.floor(y / this._spacingY)];
    };
    /**
     * @class Hexagonal backend
     * @private
     */
    ROT.Display.Hex = function(context)
    {
        ROT.Display.Backend.call(this, context);

        this._spacingX = 0;
        this._spacingY = 0;
        this._hexSize = 0;
        this._options = {};
    };
    ROT.Display.Hex.extend(ROT.Display.Backend);

    ROT.Display.Hex.prototype.compute = function(options)
    {
        this._options = options;

        /* FIXME char size computation does not respect transposed hexes */
        var charWidth = Math.ceil(this._context.measureText("W").width);
        this._hexSize = Math.floor(options.spacing * (options.fontSize + charWidth / Math.sqrt(3)) / 2);
        this._spacingX = this._hexSize * Math.sqrt(3) / 2;
        this._spacingY = this._hexSize * 1.5;

        if (options.transpose)
        {
            var xprop = "height";
            var yprop = "width";
        }
        else
        {
            var xprop = "width";
            var yprop = "height";
        }
        this._context.canvas[xprop] = Math.ceil((options.width + 1) * this._spacingX);
        this._context.canvas[yprop] = Math.ceil((options.height - 1) * this._spacingY + 2 * this._hexSize);
    };

    ROT.Display.Hex.prototype.draw = function(data, clearBefore)
    {
        var x = data[0];
        var y = data[1];
        var ch = data[2];
        var fg = data[3];
        var bg = data[4];

        var px = [
        (x + 1) * this._spacingX,
        y * this._spacingY + this._hexSize
    ];
        if (this._options.transpose)
        {
            px.reverse();
        }

        if (clearBefore)
        {
            this._context.fillStyle = bg;
            this._fill(px[0], px[1]);
        }

        if (!ch)
        {
            return;
        }

        this._context.fillStyle = fg;

        var chars = [].concat(ch);
        for (var i = 0; i < chars.length; i++)
        {
            this._context.fillText(chars[i], px[0], Math.ceil(px[1]));
        }
    };

    ROT.Display.Hex.prototype.computeSize = function(availWidth, availHeight)
    {
        if (this._options.transpose)
        {
            availWidth += availHeight;
            availHeight = availWidth - availHeight;
            availWidth -= availHeight;
        }

        var width = Math.floor(availWidth / this._spacingX) - 1;
        var height = Math.floor((availHeight - 2 * this._hexSize) / this._spacingY + 1);
        return [width, height];
    };

    ROT.Display.Hex.prototype.computeFontSize = function(availWidth, availHeight)
    {
        if (this._options.transpose)
        {
            availWidth += availHeight;
            availHeight = availWidth - availHeight;
            availWidth -= availHeight;
        }

        var hexSizeWidth = 2 * availWidth / ((this._options.width + 1) * Math.sqrt(3)) - 1;
        var hexSizeHeight = availHeight / (2 + 1.5 * (this._options.height - 1));
        var hexSize = Math.min(hexSizeWidth, hexSizeHeight);

        /* compute char ratio */
        var oldFont = this._context.font;
        this._context.font = "100px " + this._options.fontFamily;
        var width = Math.ceil(this._context.measureText("W").width);
        this._context.font = oldFont;
        var ratio = width / 100;

        hexSize = Math.floor(hexSize) + 1; /* closest larger hexSize */

        /* FIXME char size computation does not respect transposed hexes */
        var fontSize = 2 * hexSize / (this._options.spacing * (1 + ratio / Math.sqrt(3)));

        /* closest smaller fontSize */
        return Math.ceil(fontSize) - 1;
    };

    ROT.Display.Hex.prototype.eventToPosition = function(x, y)
    {
        if (this._options.transpose)
        {
            x += y;
            y = x - y;
            x -= y;
            var nodeSize = this._context.canvas.width;
        }
        else
        {
            var nodeSize = this._context.canvas.height;
        }
        var size = nodeSize / this._options.height;
        y = Math.floor(y / size);

        if (y.mod(2))
        { /* odd row */
            x -= this._spacingX;
            x = 1 + 2 * Math.floor(x / (2 * this._spacingX));
        }
        else
        {
            x = 2 * Math.floor(x / (2 * this._spacingX));
        }

        return [x, y];
    };

    /**
     * Arguments are pixel values. If "transposed" mode is enabled, then these two are already swapped.
     */
    ROT.Display.Hex.prototype._fill = function(cx, cy)
    {
        var a = this._hexSize;
        var b = this._options.border;

        this._context.beginPath();

        if (this._options.transpose)
        {
            this._context.moveTo(cx - a + b, cy);
            this._context.lineTo(cx - a / 2 + b, cy + this._spacingX - b);
            this._context.lineTo(cx + a / 2 - b, cy + this._spacingX - b);
            this._context.lineTo(cx + a - b, cy);
            this._context.lineTo(cx + a / 2 - b, cy - this._spacingX + b);
            this._context.lineTo(cx - a / 2 + b, cy - this._spacingX + b);
            this._context.lineTo(cx - a + b, cy);
        }
        else
        {
            this._context.moveTo(cx, cy - a + b);
            this._context.lineTo(cx + this._spacingX - b, cy - a / 2 + b);
            this._context.lineTo(cx + this._spacingX - b, cy + a / 2 - b);
            this._context.lineTo(cx, cy + a - b);
            this._context.lineTo(cx - this._spacingX + b, cy + a / 2 - b);
            this._context.lineTo(cx - this._spacingX + b, cy - a / 2 + b);
            this._context.lineTo(cx, cy - a + b);
        }
        this._context.fill();
    };
    /**
     * @class Tile backend
     * @private
     */
    ROT.Display.Tile = function(context)
    {
        ROT.Display.Rect.call(this, context);

        this._options = {};
        this._colorCanvas = document.createElement("canvas");
    };
    ROT.Display.Tile.extend(ROT.Display.Rect);

    ROT.Display.Tile.prototype.compute = function(options)
    {
        this._options = options;
        this._context.canvas.width = options.width * options.tileWidth;
        this._context.canvas.height = options.height * options.tileHeight;
        this._colorCanvas.width = options.tileWidth;
        this._colorCanvas.height = options.tileHeight;
    };

    ROT.Display.Tile.prototype.draw = function(data, clearBefore)
    {
        var x = data[0];
        var y = data[1];
        var ch = data[2];
        var fg = data[3];
        var bg = data[4];

        var tileWidth = this._options.tileWidth;
        var tileHeight = this._options.tileHeight;

        if (clearBefore)
        {
            if (this._options.tileColorize)
            {
                this._context.clearRect(x * tileWidth, y * tileHeight, tileWidth, tileHeight);
            }
            else
            {
                this._context.fillStyle = bg;
                this._context.fillRect(x * tileWidth, y * tileHeight, tileWidth, tileHeight);
            }
        }

        if (!ch)
        {
            return;
        }

        var chars = [].concat(ch);
        var fgs = [].concat(fg);
        var bgs = [].concat(bg);

        for (var i = 0; i < chars.length; i++)
        {
            var tile = this._options.tileMap[chars[i]];
            if (!tile)
            {
                throw new Error("Char '" + chars[i] + "' not found in tileMap");
            }

            if (this._options.tileColorize)
            { /* apply colorization */
                var canvas = this._colorCanvas;
                var context = canvas.getContext("2d");
                context.globalCompositeOperation = "source-over";
                context.clearRect(0, 0, tileWidth, tileHeight);

                var fg = fgs[i];
                var bg = bgs[i];

                context.drawImage(
                this._options.tileSet,
                tile[0], tile[1], tileWidth, tileHeight,
                0, 0, tileWidth, tileHeight);

                if (fg != "transparent")
                {
                    context.fillStyle = fg;
                    context.globalCompositeOperation = "source-atop";
                    context.fillRect(0, 0, tileWidth, tileHeight);
                }

                if (bg != "transparent")
                {
                    context.fillStyle = bg;
                    context.globalCompositeOperation = "destination-over";
                    context.fillRect(0, 0, tileWidth, tileHeight);
                }

                this._context.drawImage(canvas, x * tileWidth, y * tileHeight, tileWidth, tileHeight);
            }
            else
            { /* no colorizing, easy */
                this._context.drawImage(
                this._options.tileSet,
                tile[0], tile[1], tileWidth, tileHeight,
                x * tileWidth, y * tileHeight, tileWidth, tileHeight);
            }
        }
    };

    ROT.Display.Tile.prototype.computeSize = function(availWidth, availHeight)
    {
        var width = Math.floor(availWidth / this._options.tileWidth);
        var height = Math.floor(availHeight / this._options.tileHeight);
        return [width, height];
    };

    ROT.Display.Tile.prototype.computeFontSize = function(availWidth, availHeight)
    {
        var width = Math.floor(availWidth / this._options.width);
        var height = Math.floor(availHeight / this._options.height);
        return [width, height];
    };

    ROT.Display.Tile.prototype.eventToPosition = function(x, y)
    {
        return [Math.floor(x / this._options.tileWidth), Math.floor(y / this._options.tileHeight)];
    };
    /**
     * @namespace
     * This code is an implementation of Alea algorithm; (C) 2010 Johannes Baagøe.
     * Alea is licensed according to the http://en.wikipedia.org/wiki/MIT_License.
     */
    ROT.RNG = {
        /**
         * @returns {number}
         */
        getSeed: function()
        {
            return this._seed;
        },

        /**
         * @param {number} seed Seed the number generator
         */
        setSeed: function(seed)
        {
            seed = (seed < 1 ? 1 / seed : seed);

            this._seed = seed;
            this._s0 = (seed >>> 0) * this._frac;

            seed = (seed * 69069 + 1) >>> 0;
            this._s1 = seed * this._frac;

            seed = (seed * 69069 + 1) >>> 0;
            this._s2 = seed * this._frac;

            this._c = 1;
            return this;
        },

        /**
         * @returns {float} Pseudorandom value [0,1), uniformly distributed
         */
        getUniform: function()
        {
            var t = 2091639 * this._s0 + this._c * this._frac;
            this._s0 = this._s1;
            this._s1 = this._s2;
            this._c = t | 0;
            this._s2 = t - this._c;
            return this._s2;
        },

        /**
         * @param {int} lowerBound The lower end of the range to return a value from, inclusive
         * @param {int} upperBound The upper end of the range to return a value from, inclusive
         * @returns {int} Pseudorandom value [lowerBound, upperBound], using ROT.RNG.getUniform() to distribute the value
         */
        getUniformInt: function(lowerBound, upperBound)
        {
            var max = Math.max(lowerBound, upperBound);
            var min = Math.min(lowerBound, upperBound);
            return Math.floor(this.getUniform() * (max - min + 1)) + min;
        },

        /**
         * @param {float} [mean=0] Mean value
         * @param {float} [stddev=1] Standard deviation. ~95% of the absolute values will be lower than 2*stddev.
         * @returns {float} A normally distributed pseudorandom value
         */
        getNormal: function(mean, stddev)
        {
            do {
                var u = 2 * this.getUniform() - 1;
                var v = 2 * this.getUniform() - 1;
                var r = u * u + v * v;
            } while (r > 1 || r == 0);

            var gauss = u * Math.sqrt(-2 * Math.log(r) / r);
            return (mean || 0) + gauss * (stddev || 1);
        },

        /**
         * @returns {int} Pseudorandom value [1,100] inclusive, uniformly distributed
         */
        getPercentage: function()
        {
            return 1 + Math.floor(this.getUniform() * 100);
        },

        /**
         * @param {object} data key=whatever, value=weight (relative probability)
         * @returns {string} whatever
         */
        getWeightedValue: function(data)
        {
            var total = 0;

            for (var id in data)
            {
                total += data[id];
            }
            var random = this.getUniform() * total;

            var part = 0;
            for (var id in data)
            {
                part += data[id];
                if (random < part)
                {
                    return id;
                }
            }

            // If by some floating-point annoyance we have
            // random >= total, just return the last id.
            return id;
        },

        /**
         * Get RNG state. Useful for storing the state and re-setting it via setState.
         * @returns {?} Internal state
         */
        getState: function()
        {
            return [this._s0, this._s1, this._s2, this._c];
        },

        /**
         * Set a previously retrieved state.
         * @param {?} state
         */
        setState: function(state)
        {
            this._s0 = state[0];
            this._s1 = state[1];
            this._s2 = state[2];
            this._c = state[3];
            return this;
        },

        /**
         * Returns a cloned RNG
         */
        clone: function()
        {
            var clone = Object.create(this);
            clone.setState(this.getState());
            return clone;
        },

        _s0: 0,
        _s1: 0,
        _s2: 0,
        _c: 0,
        _frac: 2.3283064365386963e-10 /* 2^-32 */
    };

    ROT.RNG.setSeed(Date.now());
    /**
     * @class (Markov process)-based string generator.
     * Copied from a <a href="http://www.roguebasin.roguelikedevelopment.org/index.php?title=Names_from_a_high_order_Markov_Process_and_a_simplified_Katz_back-off_scheme">RogueBasin article</a>.
     * Offers configurable order and prior.
     * @param {object} [options]
     * @param {bool} [options.words=false] Use word mode?
     * @param {int} [options.order=3]
     * @param {float} [options.prior=0.001]
     */
    ROT.StringGenerator = function(options)
    {
        this._options = {
            words: false,
            order: 3,
            prior: 0.001
        };
        for (var p in options)
        {
            this._options[p] = options[p];
        }

        this._boundary = String.fromCharCode(0);
        this._suffix = this._boundary;
        this._prefix = [];
        for (var i = 0; i < this._options.order; i++)
        {
            this._prefix.push(this._boundary);
        }

        this._priorValues = {};
        this._priorValues[this._boundary] = this._options.prior;

        this._data = {};
    };

    /**
     * Remove all learning data
     */
    ROT.StringGenerator.prototype.clear = function()
    {
        this._data = {};
        this._priorValues = {};
    };

    /**
     * @returns {string} Generated string
     */
    ROT.StringGenerator.prototype.generate = function()
    {
        var result = [this._sample(this._prefix)];
        while (result[result.length - 1] != this._boundary)
        {
            result.push(this._sample(result));
        }
        return this._join(result.slice(0, -1));
    };

    /**
     * Observe (learn) a string from a training set
     */
    ROT.StringGenerator.prototype.observe = function(string)
    {
        var tokens = this._split(string);

        for (var i = 0; i < tokens.length; i++)
        {
            this._priorValues[tokens[i]] = this._options.prior;
        }

        tokens = this._prefix.concat(tokens).concat(this._suffix); /* add boundary symbols */

        for (var i = this._options.order; i < tokens.length; i++)
        {
            var context = tokens.slice(i - this._options.order, i);
            var event = tokens[i];
            for (var j = 0; j < context.length; j++)
            {
                var subcontext = context.slice(j);
                this._observeEvent(subcontext, event);
            }
        }
    };

    ROT.StringGenerator.prototype.getStats = function()
    {
        var parts = [];

        var priorCount = 0;
        for (var p in this._priorValues)
        {
            priorCount++;
        }
        priorCount--; /* boundary */
        parts.push("distinct samples: " + priorCount);

        var dataCount = 0;
        var eventCount = 0;
        for (var p in this._data)
        {
            dataCount++;
            for (var key in this._data[p])
            {
                eventCount++;
            }
        }
        parts.push("dictionary size (contexts): " + dataCount);
        parts.push("dictionary size (events): " + eventCount);

        return parts.join(", ");
    };

    /**
     * @param {string}
     * @returns {string[]}
     */
    ROT.StringGenerator.prototype._split = function(str)
    {
        return str.split(this._options.words ? /\s+/ : "");
    };

    /**
     * @param {string[]}
     * @returns {string}
     */
    ROT.StringGenerator.prototype._join = function(arr)
    {
        return arr.join(this._options.words ? " " : "");
    };

    /**
     * @param {string[]} context
     * @param {string} event
     */
    ROT.StringGenerator.prototype._observeEvent = function(context, event)
    {
        var key = this._join(context);
        if (!(key in this._data))
        {
            this._data[key] = {};
        }
        var data = this._data[key];

        if (!(event in data))
        {
            data[event] = 0;
        }
        data[event]++;
    };

    /**
     * @param {string[]}
     * @returns {string}
     */
    ROT.StringGenerator.prototype._sample = function(context)
    {
        context = this._backoff(context);
        var key = this._join(context);
        var data = this._data[key];

        var available = {};

        if (this._options.prior)
        {
            for (var event in this._priorValues)
            {
                available[event] = this._priorValues[event];
            }
            for (var event in data)
            {
                available[event] += data[event];
            }
        }
        else
        {
            available = data;
        }

        return ROT.RNG.getWeightedValue(available);
    };

    /**
     * @param {string[]}
     * @returns {string[]}
     */
    ROT.StringGenerator.prototype._backoff = function(context)
    {
        if (context.length > this._options.order)
        {
            context = context.slice(-this._options.order);
        }
        else if (context.length < this._options.order)
        {
            context = this._prefix.slice(0, this._options.order - context.length).concat(context);
        }

        while (!(this._join(context) in this._data) && context.length > 0)
        {
            context = context.slice(1);
        }

        return context;
    };
    /**
     * @class Generic event queue: stores events and retrieves them based on their time
     */
    ROT.EventQueue = function()
    {
        this._time = 0;
        this._events = [];
        this._eventTimes = [];
    };

    /**
     * @returns {number} Elapsed time
     */
    ROT.EventQueue.prototype.getTime = function()
    {
        return this._time;
    };

    /**
     * Clear all scheduled events
     */
    ROT.EventQueue.prototype.clear = function()
    {
        this._events = [];
        this._eventTimes = [];
        return this;
    };

    /**
     * @param {?} event
     * @param {number} time
     */
    ROT.EventQueue.prototype.add = function(event, time)
    {
        var index = this._events.length;
        for (var i = 0; i < this._eventTimes.length; i++)
        {
            if (this._eventTimes[i] > time)
            {
                index = i;
                break;
            }
        }

        this._events.splice(index, 0, event);
        this._eventTimes.splice(index, 0, time);
    };

    /**
     * Locates the nearest event, advances time if necessary. Returns that event and removes it from the queue.
     * @returns {? || null} The event previously added by addEvent, null if no event available
     */
    ROT.EventQueue.prototype.get = function()
    {
        if (!this._events.length)
        {
            return null;
        }

        var time = this._eventTimes.splice(0, 1)[0];
        if (time > 0)
        { /* advance */
            this._time += time;
            for (var i = 0; i < this._eventTimes.length; i++)
            {
                this._eventTimes[i] -= time;
            }
        }

        return this._events.splice(0, 1)[0];
    };

    /**
     * Get the time associated with the given event
     * @param {?} event
     * @returns {number} time
     */
    ROT.EventQueue.prototype.getEventTime = function(event)
    {
        var index = this._events.indexOf(event);
        if (index == -1)
        {
            return undefined
        }
        return this._eventTimes[index];
    };

    /**
     * Remove an event from the queue
     * @param {?} event
     * @returns {bool} success?
     */
    ROT.EventQueue.prototype.remove = function(event)
    {
        var index = this._events.indexOf(event);
        if (index == -1)
        {
            return false
        }
        this._remove(index);
        return true;
    };

    /**
     * Remove an event from the queue
     * @param {int} index
     */
    ROT.EventQueue.prototype._remove = function(index)
    {
        this._events.splice(index, 1);
        this._eventTimes.splice(index, 1);
    };
    /**
     * @class Abstract scheduler
     */
    ROT.Scheduler = function()
    {
        this._queue = new ROT.EventQueue();
        this._repeat = [];
        this._current = null;
    };

    /**
     * @see ROT.EventQueue#getTime
     */
    ROT.Scheduler.prototype.getTime = function()
    {
        return this._queue.getTime();
    };

    /**
     * @param {?} item
     * @param {bool} repeat
     */
    ROT.Scheduler.prototype.add = function(item, repeat)
    {
        if (repeat)
        {
            this._repeat.push(item);
        }
        return this;
    };

    /**
     * Get the time the given item is scheduled for
     * @param {?} item
     * @returns {number} time
     */
    ROT.Scheduler.prototype.getTimeOf = function(item)
    {
        return this._queue.getEventTime(item);
    };

    /**
     * Clear all items
     */
    ROT.Scheduler.prototype.clear = function()
    {
        this._queue.clear();
        this._repeat = [];
        this._current = null;
        return this;
    };

    /**
     * Remove a previously added item
     * @param {?} item
     * @returns {bool} successful?
     */
    ROT.Scheduler.prototype.remove = function(item)
    {
        var result = this._queue.remove(item);

        var index = this._repeat.indexOf(item);
        if (index != -1)
        {
            this._repeat.splice(index, 1);
        }

        if (this._current == item)
        {
            this._current = null;
        }

        return result;
    };

    /**
     * Schedule next item
     * @returns {?}
     */
    ROT.Scheduler.prototype.next = function()
    {
        this._current = this._queue.get();
        return this._current;
    };
    /**
     * @class Simple fair scheduler (round-robin style)
     * @augments ROT.Scheduler
     */
    ROT.Scheduler.Simple = function()
    {
        ROT.Scheduler.call(this);
    };
    ROT.Scheduler.Simple.extend(ROT.Scheduler);

    /**
     * @see ROT.Scheduler#add
     */
    ROT.Scheduler.Simple.prototype.add = function(item, repeat)
    {
        this._queue.add(item, 0);
        return ROT.Scheduler.prototype.add.call(this, item, repeat);
    };

    /**
     * @see ROT.Scheduler#next
     */
    ROT.Scheduler.Simple.prototype.next = function()
    {
        if (this._current && this._repeat.indexOf(this._current) != -1)
        {
            this._queue.add(this._current, 0);
        }
        return ROT.Scheduler.prototype.next.call(this);
    };
    /**
     * @class Speed-based scheduler
     * @augments ROT.Scheduler
     */
    ROT.Scheduler.Speed = function()
    {
        ROT.Scheduler.call(this);
    };
    ROT.Scheduler.Speed.extend(ROT.Scheduler);

    /**
     * @param {object} item anything with "getSpeed" method
     * @param {bool} repeat
     * @param {number} [time=1/item.getSpeed()]
     * @see ROT.Scheduler#add
     */
    ROT.Scheduler.Speed.prototype.add = function(item, repeat, time)
    {
        this._queue.add(item, time !== undefined ? time : 1 / item.getSpeed());
        return ROT.Scheduler.prototype.add.call(this, item, repeat);
    };

    /**
     * @see ROT.Scheduler#next
     */
    ROT.Scheduler.Speed.prototype.next = function()
    {
        if (this._current && this._repeat.indexOf(this._current) != -1)
        {
            this._queue.add(this._current, 1 / this._current.getSpeed());
        }
        return ROT.Scheduler.prototype.next.call(this);
    };
    /**
     * @class Action-based scheduler
     * @augments ROT.Scheduler
     */
    ROT.Scheduler.Action = function()
    {
        ROT.Scheduler.call(this);
        this._defaultDuration = 1; /* for newly added */
        this._duration = this._defaultDuration; /* for this._current */
    };
    ROT.Scheduler.Action.extend(ROT.Scheduler);

    /**
     * @param {object} item
     * @param {bool} repeat
     * @param {number} [time=1]
     * @see ROT.Scheduler#add
     */
    ROT.Scheduler.Action.prototype.add = function(item, repeat, time)
    {
        this._queue.add(item, time || this._defaultDuration);
        return ROT.Scheduler.prototype.add.call(this, item, repeat);
    };

    ROT.Scheduler.Action.prototype.clear = function()
    {
        this._duration = this._defaultDuration;
        return ROT.Scheduler.prototype.clear.call(this);
    };

    ROT.Scheduler.Action.prototype.remove = function(item)
    {
        if (item == this._current)
        {
            this._duration = this._defaultDuration;
        }
        return ROT.Scheduler.prototype.remove.call(this, item);
    };

    /**
     * @see ROT.Scheduler#next
     */
    ROT.Scheduler.Action.prototype.next = function()
    {
        if (this._current && this._repeat.indexOf(this._current) != -1)
        {
            this._queue.add(this._current, this._duration || this._defaultDuration);
            this._duration = this._defaultDuration;
        }
        return ROT.Scheduler.prototype.next.call(this);
    };

    /**
     * Set duration for the active item
     */
    ROT.Scheduler.Action.prototype.setDuration = function(time)
    {
        if (this._current)
        {
            this._duration = time;
        }
        return this;
    };
    /**
     * @class Asynchronous main loop
     * @param {ROT.Scheduler} scheduler
     */
    ROT.Engine = function(scheduler)
    {
        this._scheduler = scheduler;
        this._lock = 1;
    };

    /**
     * Start the main loop. When this call returns, the loop is locked.
     */
    ROT.Engine.prototype.start = function()
    {
        return this.unlock();
    };

    /**
     * Interrupt the engine by an asynchronous action
     */
    ROT.Engine.prototype.lock = function()
    {
        this._lock++;
        return this;
    };

    /**
     * Resume execution (paused by a previous lock)
     */
    ROT.Engine.prototype.unlock = function()
    {
        if (!this._lock)
        {
            throw new Error("Cannot unlock unlocked engine");
        }
        this._lock--;

        while (!this._lock)
        {
            var actor = this._scheduler.next();
            if (!actor)
            {
                return this.lock();
            } /* no actors */
            var result = actor.act();
            if (result && result.then)
            { /* actor returned a "thenable", looks like a Promise */
                this.lock();
                result.then(this.unlock.bind(this));
            }
        }

        return this;
    };
    /**
     * @class Base map generator
     * @param {int} [width=ROT.DEFAULT_WIDTH]
     * @param {int} [height=ROT.DEFAULT_HEIGHT]
     */
    ROT.Map = function(width, height)
    {
        this._width = width || ROT.DEFAULT_WIDTH;
        this._height = height || ROT.DEFAULT_HEIGHT;
    };

    ROT.Map.prototype.create = function(callback)
    {};

    ROT.Map.prototype._fillMap = function(value)
    {
        var map = [];
        for (var i = 0; i < this._width; i++)
        {
            map.push([]);
            for (var j = 0; j < this._height; j++)
            {
                map[i].push(value);
            }
        }
        return map;
    };
    /**
     * @class Simple empty rectangular room
     * @augments ROT.Map
     */
    ROT.Map.Arena = function(width, height)
    {
        ROT.Map.call(this, width, height);
    };
    ROT.Map.Arena.extend(ROT.Map);

    ROT.Map.Arena.prototype.create = function(callback)
    {
        var w = this._width - 1;
        var h = this._height - 1;
        for (var i = 0; i <= w; i++)
        {
            for (var j = 0; j <= h; j++)
            {
                var empty = (i && j && i < w && j < h);
                callback(i, j, empty ? 0 : 1);
            }
        }
        return this;
    };
    /**
     * @class Recursively divided maze, http://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_division_method
     * @augments ROT.Map
     */
    ROT.Map.DividedMaze = function(width, height)
    {
        ROT.Map.call(this, width, height);
        this._stack = [];
    };
    ROT.Map.DividedMaze.extend(ROT.Map);

    ROT.Map.DividedMaze.prototype.create = function(callback)
    {
        var w = this._width;
        var h = this._height;

        this._map = [];

        for (var i = 0; i < w; i++)
        {
            this._map.push([]);
            for (var j = 0; j < h; j++)
            {
                var border = (i == 0 || j == 0 || i + 1 == w || j + 1 == h);
                this._map[i].push(border ? 1 : 0);
            }
        }

        this._stack = [
        [1, 1, w - 2, h - 2]
    ];
        this._process();

        for (var i = 0; i < w; i++)
        {
            for (var j = 0; j < h; j++)
            {
                callback(i, j, this._map[i][j]);
            }
        }
        this._map = null;
        return this;
    };

    ROT.Map.DividedMaze.prototype._process = function()
    {
        while (this._stack.length)
        {
            var room = this._stack.shift(); /* [left, top, right, bottom] */
            this._partitionRoom(room);
        }
    };

    ROT.Map.DividedMaze.prototype._partitionRoom = function(room)
    {
        var availX = [];
        var availY = [];

        for (var i = room[0] + 1; i < room[2]; i++)
        {
            var top = this._map[i][room[1] - 1];
            var bottom = this._map[i][room[3] + 1];
            if (top && bottom && !(i % 2))
            {
                availX.push(i);
            }
        }

        for (var j = room[1] + 1; j < room[3]; j++)
        {
            var left = this._map[room[0] - 1][j];
            var right = this._map[room[2] + 1][j];
            if (left && right && !(j % 2))
            {
                availY.push(j);
            }
        }

        if (!availX.length || !availY.length)
        {
            return;
        }

        var x = availX.random();
        var y = availY.random();

        this._map[x][y] = 1;

        var walls = [];

        var w = [];
        walls.push(w); /* left part */
        for (var i = room[0]; i < x; i++)
        {
            this._map[i][y] = 1;
            w.push([i, y]);
        }

        var w = [];
        walls.push(w); /* right part */
        for (var i = x + 1; i <= room[2]; i++)
        {
            this._map[i][y] = 1;
            w.push([i, y]);
        }

        var w = [];
        walls.push(w); /* top part */
        for (var j = room[1]; j < y; j++)
        {
            this._map[x][j] = 1;
            w.push([x, j]);
        }

        var w = [];
        walls.push(w); /* bottom part */
        for (var j = y + 1; j <= room[3]; j++)
        {
            this._map[x][j] = 1;
            w.push([x, j]);
        }

        var solid = walls.random();
        for (var i = 0; i < walls.length; i++)
        {
            var w = walls[i];
            if (w == solid)
            {
                continue;
            }

            var hole = w.random();
            this._map[hole[0]][hole[1]] = 0;
        }

        this._stack.push([room[0], room[1], x - 1, y - 1]); /* left top */
        this._stack.push([x + 1, room[1], room[2], y - 1]); /* right top */
        this._stack.push([room[0], y + 1, x - 1, room[3]]); /* left bottom */
        this._stack.push([x + 1, y + 1, room[2], room[3]]); /* right bottom */
    };
    /**
     * @class Icey's Maze generator
     * See http://www.roguebasin.roguelikedevelopment.org/index.php?title=Simple_maze for explanation
     * @augments ROT.Map
     */
    ROT.Map.IceyMaze = function(width, height, regularity)
    {
        ROT.Map.call(this, width, height);
        this._regularity = regularity || 0;
    };
    ROT.Map.IceyMaze.extend(ROT.Map);

    ROT.Map.IceyMaze.prototype.create = function(callback)
    {
        var width = this._width;
        var height = this._height;

        var map = this._fillMap(1);

        width -= (width % 2 ? 1 : 2);
        height -= (height % 2 ? 1 : 2);

        var cx = 0;
        var cy = 0;
        var nx = 0;
        var ny = 0;

        var done = 0;
        var blocked = false;
        var dirs = [
        [0, 0],
        [0, 0],
        [0, 0],
        [0, 0]
    ];
        do {
            cx = 1 + 2 * Math.floor(ROT.RNG.getUniform() * (width - 1) / 2);
            cy = 1 + 2 * Math.floor(ROT.RNG.getUniform() * (height - 1) / 2);

            if (!done)
            {
                map[cx][cy] = 0;
            }

            if (!map[cx][cy])
            {
                this._randomize(dirs);
                do {
                    if (Math.floor(ROT.RNG.getUniform() * (this._regularity + 1)) == 0)
                    {
                        this._randomize(dirs);
                    }
                    blocked = true;
                    for (var i = 0; i < 4; i++)
                    {
                        nx = cx + dirs[i][0] * 2;
                        ny = cy + dirs[i][1] * 2;
                        if (this._isFree(map, nx, ny, width, height))
                        {
                            map[nx][ny] = 0;
                            map[cx + dirs[i][0]][cy + dirs[i][1]] = 0;

                            cx = nx;
                            cy = ny;
                            blocked = false;
                            done++;
                            break;
                        }
                    }
                } while (!blocked);
            }
        } while (done + 1 < width * height / 4);

        for (var i = 0; i < this._width; i++)
        {
            for (var j = 0; j < this._height; j++)
            {
                callback(i, j, map[i][j]);
            }
        }
        this._map = null;
        return this;
    };

    ROT.Map.IceyMaze.prototype._randomize = function(dirs)
    {
        for (var i = 0; i < 4; i++)
        {
            dirs[i][0] = 0;
            dirs[i][1] = 0;
        }

        switch (Math.floor(ROT.RNG.getUniform() * 4))
        {
            case 0:
                dirs[0][0] = -1;
                dirs[1][0] = 1;
                dirs[2][1] = -1;
                dirs[3][1] = 1;
                break;
            case 1:
                dirs[3][0] = -1;
                dirs[2][0] = 1;
                dirs[1][1] = -1;
                dirs[0][1] = 1;
                break;
            case 2:
                dirs[2][0] = -1;
                dirs[3][0] = 1;
                dirs[0][1] = -1;
                dirs[1][1] = 1;
                break;
            case 3:
                dirs[1][0] = -1;
                dirs[0][0] = 1;
                dirs[3][1] = -1;
                dirs[2][1] = 1;
                break;
        }
    };

    ROT.Map.IceyMaze.prototype._isFree = function(map, x, y, width, height)
    {
        if (x < 1 || y < 1 || x >= width || y >= height)
        {
            return false;
        }
        return map[x][y];
    };
    /**
     * @class Maze generator - Eller's algorithm
     * See http://homepages.cwi.nl/~tromp/maze.html for explanation
     * @augments ROT.Map
     */
    ROT.Map.EllerMaze = function(width, height)
    {
        ROT.Map.call(this, width, height);
    };
    ROT.Map.EllerMaze.extend(ROT.Map);

    ROT.Map.EllerMaze.prototype.create = function(callback)
    {
        var map = this._fillMap(1);
        var w = Math.ceil((this._width - 2) / 2);

        var rand = 9 / 24;

        var L = [];
        var R = [];

        for (var i = 0; i < w; i++)
        {
            L.push(i);
            R.push(i);
        }
        L.push(w - 1); /* fake stop-block at the right side */

        for (var j = 1; j + 3 < this._height; j += 2)
        {
            /* one row */
            for (var i = 0; i < w; i++)
            {
                /* cell coords (will be always empty) */
                var x = 2 * i + 1;
                var y = j;
                map[x][y] = 0;

                /* right connection */
                if (i != L[i + 1] && ROT.RNG.getUniform() > rand)
                {
                    this._addToList(i, L, R);
                    map[x + 1][y] = 0;
                }

                /* bottom connection */
                if (i != L[i] && ROT.RNG.getUniform() > rand)
                {
                    /* remove connection */
                    this._removeFromList(i, L, R);
                }
                else
                {
                    /* create connection */
                    map[x][y + 1] = 0;
                }
            }
        }

        /* last row */
        for (var i = 0; i < w; i++)
        {
            /* cell coords (will be always empty) */
            var x = 2 * i + 1;
            var y = j;
            map[x][y] = 0;

            /* right connection */
            if (i != L[i + 1] && (i == L[i] || ROT.RNG.getUniform() > rand))
            {
                /* dig right also if the cell is separated, so it gets connected to the rest of maze */
                this._addToList(i, L, R);
                map[x + 1][y] = 0;
            }

            this._removeFromList(i, L, R);
        }

        for (var i = 0; i < this._width; i++)
        {
            for (var j = 0; j < this._height; j++)
            {
                callback(i, j, map[i][j]);
            }
        }

        return this;
    };

    /**
     * Remove "i" from its list
     */
    ROT.Map.EllerMaze.prototype._removeFromList = function(i, L, R)
    {
        R[L[i]] = R[i];
        L[R[i]] = L[i];
        R[i] = i;
        L[i] = i;
    };

    /**
     * Join lists with "i" and "i+1"
     */
    ROT.Map.EllerMaze.prototype._addToList = function(i, L, R)
    {
        R[L[i + 1]] = R[i];
        L[R[i]] = L[i + 1];
        R[i] = i + 1;
        L[i + 1] = i;
    };
    /**
     * @class Cellular automaton map generator
     * @augments ROT.Map
     * @param {int} [width=ROT.DEFAULT_WIDTH]
     * @param {int} [height=ROT.DEFAULT_HEIGHT]
     * @param {object} [options] Options
     * @param {int[]} [options.born] List of neighbor counts for a new cell to be born in empty space
     * @param {int[]} [options.survive] List of neighbor counts for an existing  cell to survive
     * @param {int} [options.topology] Topology 4 or 6 or 8
     */
    ROT.Map.Cellular = function(width, height, options)
    {
        ROT.Map.call(this, width, height);
        this._options = {
            born: [5, 6, 7, 8],
            survive: [4, 5, 6, 7, 8],
            topology: 8
        };
        this.setOptions(options);

        this._dirs = ROT.DIRS[this._options.topology];
        this._map = this._fillMap(0);
    };
    ROT.Map.Cellular.extend(ROT.Map);

    /**
     * Fill the map with random values
     * @param {float} probability Probability for a cell to become alive; 0 = all empty, 1 = all full
     */
    ROT.Map.Cellular.prototype.randomize = function(probability)
    {
        for (var i = 0; i < this._width; i++)
        {
            for (var j = 0; j < this._height; j++)
            {
                this._map[i][j] = (ROT.RNG.getUniform() < probability ? 1 : 0);
            }
        }
        return this;
    };

    /**
     * Change options.
     * @see ROT.Map.Cellular
     */
    ROT.Map.Cellular.prototype.setOptions = function(options)
    {
        for (var p in options)
        {
            this._options[p] = options[p];
        }
    };

    ROT.Map.Cellular.prototype.set = function(x, y, value)
    {
        this._map[x][y] = value;
    };

    ROT.Map.Cellular.prototype.create = function(callback)
    {
        var newMap = this._fillMap(0);
        var born = this._options.born;
        var survive = this._options.survive;


        for (var j = 0; j < this._height; j++)
        {
            var widthStep = 1;
            var widthStart = 0;
            if (this._options.topology == 6)
            {
                widthStep = 2;
                widthStart = j % 2;
            }

            for (var i = widthStart; i < this._width; i += widthStep)
            {
                var cur = this._map[i][j];
                var ncount = this._getNeighbors(i, j);

                if (cur && survive.indexOf(ncount) != -1)
                { /* survive */
                    newMap[i][j] = 1;
                }
                else if (!cur && born.indexOf(ncount) != -1)
                { /* born */
                    newMap[i][j] = 1;
                }
            }
        }

        this._map = newMap;
        callback && this._serviceCallback(callback);
    };

    ROT.Map.Cellular.prototype._serviceCallback = function(callback)
    {
        for (var j = 0; j < this._height; j++)
        {
            var widthStep = 1;
            var widthStart = 0;
            if (this._options.topology == 6)
            {
                widthStep = 2;
                widthStart = j % 2;
            }
            for (var i = widthStart; i < this._width; i += widthStep)
            {
                callback(i, j, this._map[i][j]);
            }
        }
    };

    /**
     * Get neighbor count at [i,j] in this._map
     */
    ROT.Map.Cellular.prototype._getNeighbors = function(cx, cy)
    {
        var result = 0;
        for (var i = 0; i < this._dirs.length; i++)
        {
            var dir = this._dirs[i];
            var x = cx + dir[0];
            var y = cy + dir[1];

            if (x < 0 || x >= this._width || y < 0 || y >= this._height)
            {
                continue;
            }
            result += (this._map[x][y] == 1 ? 1 : 0);
        }

        return result;
    };

    /**
     * Make sure every non-wall space is accessible.
     * @param {function} callback to call to display map when do
     * @param {int} value to consider empty space - defaults to 0
     * @param {function} callback to call when a new connection is made
     */
    ROT.Map.Cellular.prototype.connect = function(callback, value, connectionCallback)
    {
        if (!value) value = 0;

        var allFreeSpace = [];
        var notConnected = {};

        // find all free space
        var widthStep = 1;
        var widthStarts = [0, 0];
        if (this._options.topology == 6)
        {
            widthStep = 2;
            widthStarts = [0, 1];
        }
        for (var y = 0; y < this._height; y++)
        {
            for (var x = widthStarts[y % 2]; x < this._width; x += widthStep)
            {
                if (this._freeSpace(x, y, value))
                {
                    var p = [x, y];
                    notConnected[this._pointKey(p)] = p;
                    allFreeSpace.push([x, y]);
                }
            }
        }
        var start = allFreeSpace[ROT.RNG.getUniformInt(0, allFreeSpace.length - 1)];

        var key = this._pointKey(start);
        var connected = {};
        connected[key] = start;
        delete notConnected[key];

        // find what's connected to the starting point
        this._findConnected(connected, notConnected, [start], false, value);

        while (Object.keys(notConnected).length > 0)
        {
            // find two points from notConnected to connected
            var p = this._getFromTo(connected, notConnected);
            var from = p[0]; // notConnected
            var to = p[1]; // connected

            // find everything connected to the starting point
            var local = {};
            local[this._pointKey(from)] = from;
            this._findConnected(local, notConnected, [from], true, value);

            // connect to a connected cell
            var tunnelFn = (this._options.topology == 6 ? this._tunnelToConnected6 : this._tunnelToConnected);
            tunnelFn.call(this, to, from, connected, notConnected, value, connectionCallback);

            // now all of local is connected
            for (var k in local)
            {
                var pp = local[k];
                this._map[pp[0]][pp[1]] = value;
                connected[k] = pp;
                delete notConnected[k];
            }
        }

        callback && this._serviceCallback(callback);
    };

    /**
     * Find random points to connect. Search for the closest point in the larger space.
     * This is to minimize the length of the passage while maintaining good performance.
     */
    ROT.Map.Cellular.prototype._getFromTo = function(connected, notConnected)
    {
        var from, to, d;
        var connectedKeys = Object.keys(connected);
        var notConnectedKeys = Object.keys(notConnected);
        for (var i = 0; i < 5; i++)
        {
            if (connectedKeys.length < notConnectedKeys.length)
            {
                var keys = connectedKeys;
                to = connected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]];
                from = this._getClosest(to, notConnected);
            }
            else
            {
                var keys = notConnectedKeys;
                from = notConnected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]];
                to = this._getClosest(from, connected);
            }
            d = (from[0] - to[0]) * (from[0] - to[0]) + (from[1] - to[1]) * (from[1] - to[1]);
            if (d < 64)
            {
                break;
            }
        }
        // console.log(">>> connected=" + to + " notConnected=" + from + " dist=" + d);
        return [from, to];
    };

    ROT.Map.Cellular.prototype._getClosest = function(point, space)
    {
        var minPoint = null;
        var minDist = null;
        for (k in space)
        {
            var p = space[k];
            var d = (p[0] - point[0]) * (p[0] - point[0]) + (p[1] - point[1]) * (p[1] - point[1]);
            if (minDist == null || d < minDist)
            {
                minDist = d;
                minPoint = p;
            }
        }
        return minPoint;
    };

    ROT.Map.Cellular.prototype._findConnected = function(connected, notConnected, stack, keepNotConnected, value)
    {
        while (stack.length > 0)
        {
            var p = stack.splice(0, 1)[0];
            var tests;

            if (this._options.topology == 6)
            {
                tests = [
                [p[0] + 2, p[1]],
                [p[0] + 1, p[1] - 1],
                [p[0] - 1, p[1] - 1],
                [p[0] - 2, p[1]],
                [p[0] - 1, p[1] + 1],
                [p[0] + 1, p[1] + 1],
            ];
            }
            else
            {
                tests = [
                [p[0] + 1, p[1]],
                [p[0] - 1, p[1]],
                [p[0], p[1] + 1],
                [p[0], p[1] - 1]
            ];
            }

            for (var i = 0; i < tests.length; i++)
            {
                var key = this._pointKey(tests[i]);
                if (connected[key] == null && this._freeSpace(tests[i][0], tests[i][1], value))
                {
                    connected[key] = tests[i];
                    if (!keepNotConnected)
                    {
                        delete notConnected[key];
                    }
                    stack.push(tests[i]);
                }
            }
        }
    };

    ROT.Map.Cellular.prototype._tunnelToConnected = function(to, from, connected, notConnected, value, connectionCallback)
    {
        var key = this._pointKey(from);
        var a, b;
        if (from[0] < to[0])
        {
            a = from;
            b = to;
        }
        else
        {
            a = to;
            b = from;
        }
        for (var xx = a[0]; xx <= b[0]; xx++)
        {
            this._map[xx][a[1]] = value;
            var p = [xx, a[1]];
            var pkey = this._pointKey(p);
            connected[pkey] = p;
            delete notConnected[pkey];
        }
        if (connectionCallback && a[0] < b[0])
        {
            connectionCallback(a, [b[0], a[1]]);
        }

        // x is now fixed
        var x = b[0];

        if (from[1] < to[1])
        {
            a = from;
            b = to;
        }
        else
        {
            a = to;
            b = from;
        }
        for (var yy = a[1]; yy < b[1]; yy++)
        {
            this._map[x][yy] = value;
            var p = [x, yy];
            var pkey = this._pointKey(p);
            connected[pkey] = p;
            delete notConnected[pkey];
        }
        if (connectionCallback && a[1] < b[1])
        {
            connectionCallback([b[0], a[1]], [b[0], b[1]]);
        }
    }

    ROT.Map.Cellular.prototype._tunnelToConnected6 = function(to, from, connected, notConnected, value, connectionCallback)
    {
        var a, b;
        if (from[0] < to[0])
        {
            a = from;
            b = to;
        }
        else
        {
            a = to;
            b = from;
        }

        // tunnel diagonally until horizontally level
        var xx = a[0];
        var yy = a[1];
        while (!(xx == b[0] && yy == b[1]))
        {
            var stepWidth = 2;
            if (yy < b[1])
            {
                yy++;
                stepWidth = 1;
            }
            else if (yy > b[1])
            {
                yy--;
                stepWidth = 1;
            }
            if (xx < b[0])
            {
                xx += stepWidth
            }
            else if (xx > b[0])
            {
                xx -= stepWidth
            }
            else if (b[1] % 2)
            {
                // Won't step outside map if destination on is map's right edge
                xx -= stepWidth;
            }
            else
            {
                // ditto for left edge
                xx += stepWidth;
            }
            this._map[xx][yy] = value;
            var p = [xx, yy]
            var pkey = this._pointKey(p);
            connected[pkey] = p;
            delete notConnected[pkey];
        }

        if (connectionCallback)
        {
            connectionCallback(from, to);
        }
    }

    ROT.Map.Cellular.prototype._freeSpace = function(x, y, value)
    {
        return x >= 0 && x < this._width && y >= 0 && y < this._height && this._map[x][y] == value;
    }

    ROT.Map.Cellular.prototype._pointKey = function(p)
    {
        return p[0] + "." + p[1];
    }
    /**
     * @class Dungeon map: has rooms and corridors
     * @augments ROT.Map
     */
    ROT.Map.Dungeon = function(width, height)
    {
        ROT.Map.call(this, width, height);
        this._rooms = []; /* list of all rooms */
        this._corridors = [];
    };
    ROT.Map.Dungeon.extend(ROT.Map);

    /**
     * Get all generated rooms
     * @returns {ROT.Map.Feature.Room[]}
     */
    ROT.Map.Dungeon.prototype.getRooms = function()
    {
        return this._rooms;
    };

    /**
     * Get all generated corridors
     * @returns {ROT.Map.Feature.Corridor[]}
     */
    ROT.Map.Dungeon.prototype.getCorridors = function()
    {
        return this._corridors;
    };
    /**
     * @class Random dungeon generator using human-like digging patterns.
     * Heavily based on Mike Anderson's ideas from the "Tyrant" algo, mentioned at
     * http://www.roguebasin.roguelikedevelopment.org/index.php?title=Dungeon-Building_Algorithm.
     * @augments ROT.Map.Dungeon
     */
    ROT.Map.Digger = function(width, height, options)
    {
        ROT.Map.Dungeon.call(this, width, height);

        this._options = {
            roomWidth: [3, 9],
            /* room minimum and maximum width */
            roomHeight: [3, 5],
            /* room minimum and maximum height */
            corridorLength: [3, 10],
            /* corridor minimum and maximum length */
            dugPercentage: 0.2,
            /* we stop after this percentage of level area has been dug out */
            timeLimit: 1000 /* we stop after this much time has passed (msec) */
        };
        for (var p in options)
        {
            this._options[p] = options[p];
        }

        this._features = {
            "Room": 4,
            "Corridor": 4
        };
        this._featureAttempts = 20; /* how many times do we try to create a feature on a suitable wall */
        this._walls = {}; /* these are available for digging */

        this._digCallback = this._digCallback.bind(this);
        this._canBeDugCallback = this._canBeDugCallback.bind(this);
        this._isWallCallback = this._isWallCallback.bind(this);
        this._priorityWallCallback = this._priorityWallCallback.bind(this);
    };
    ROT.Map.Digger.extend(ROT.Map.Dungeon);

    /**
     * Create a map
     * @see ROT.Map#create
     */
    ROT.Map.Digger.prototype.create = function(callback)
    {
        this._rooms = [];
        this._corridors = [];
        this._map = this._fillMap(1);
        this._walls = {};
        this._dug = 0;
        var area = (this._width - 2) * (this._height - 2);

        this._firstRoom();

        var t1 = Date.now();

        do {
            var t2 = Date.now();
            if (t2 - t1 > this._options.timeLimit)
            {
                break;
            }

            /* find a good wall */
            var wall = this._findWall();
            if (!wall)
            {
                break;
            } /* no more walls */

            var parts = wall.split(",");
            var x = parseInt(parts[0]);
            var y = parseInt(parts[1]);
            var dir = this._getDiggingDirection(x, y);
            if (!dir)
            {
                continue;
            } /* this wall is not suitable */

            //		console.log("wall", x, y);

            /* try adding a feature */
            var featureAttempts = 0;
            do {
                featureAttempts++;
                if (this._tryFeature(x, y, dir[0], dir[1]))
                { /* feature added */
                    //if (this._rooms.length + this._corridors.length == 2) { this._rooms[0].addDoor(x, y); } /* first room oficially has doors */
                    this._removeSurroundingWalls(x, y);
                    this._removeSurroundingWalls(x - dir[0], y - dir[1]);
                    break;
                }
            } while (featureAttempts < this._featureAttempts);

            var priorityWalls = 0;
            for (var id in this._walls)
            {
                if (this._walls[id] > 1)
                {
                    priorityWalls++;
                }
            }

        } while (this._dug / area < this._options.dugPercentage || priorityWalls); /* fixme number of priority walls */

        this._addDoors();

        if (callback)
        {
            for (var i = 0; i < this._width; i++)
            {
                for (var j = 0; j < this._height; j++)
                {
                    callback(i, j, this._map[i][j]);
                }
            }
        }

        this._walls = {};
        this._map = null;

        return this;
    };

    ROT.Map.Digger.prototype._digCallback = function(x, y, value)
    {
        if (value == 0 || value == 2)
        { /* empty */
            this._map[x][y] = 0;
            this._dug++;
        }
        else
        { /* wall */
            this._walls[x + "," + y] = 1;
        }
    };

    ROT.Map.Digger.prototype._isWallCallback = function(x, y)
    {
        if (x < 0 || y < 0 || x >= this._width || y >= this._height)
        {
            return false;
        }
        return (this._map[x][y] == 1);
    };

    ROT.Map.Digger.prototype._canBeDugCallback = function(x, y)
    {
        if (x < 1 || y < 1 || x + 1 >= this._width || y + 1 >= this._height)
        {
            return false;
        }
        return (this._map[x][y] == 1);
    };

    ROT.Map.Digger.prototype._priorityWallCallback = function(x, y)
    {
        this._walls[x + "," + y] = 2;
    };

    ROT.Map.Digger.prototype._firstRoom = function()
    {
        var cx = Math.floor(this._width / 2);
        var cy = Math.floor(this._height / 2);
        var room = ROT.Map.Feature.Room.createRandomCenter(cx, cy, this._options);
        this._rooms.push(room);
        room.create(this._digCallback);
    };

    /**
     * Get a suitable wall
     */
    ROT.Map.Digger.prototype._findWall = function()
    {
        var prio1 = [];
        var prio2 = [];
        for (var id in this._walls)
        {
            var prio = this._walls[id];
            if (prio == 2)
            {
                prio2.push(id);
            }
            else
            {
                prio1.push(id);
            }
        }

        var arr = (prio2.length ? prio2 : prio1);
        if (!arr.length)
        {
            return null;
        } /* no walls :/ */

        var id = arr.sort().random(); // sort to make the order deterministic
        delete this._walls[id];

        return id;
    };

    /**
     * Tries adding a feature
     * @returns {bool} was this a successful try?
     */
    ROT.Map.Digger.prototype._tryFeature = function(x, y, dx, dy)
    {
        var feature = ROT.RNG.getWeightedValue(this._features);
        feature = ROT.Map.Feature[feature].createRandomAt(x, y, dx, dy, this._options);

        if (!feature.isValid(this._isWallCallback, this._canBeDugCallback))
        {
            //		console.log("not valid");
            //		feature.debug();
            return false;
        }

        feature.create(this._digCallback);
        //	feature.debug();

        if (feature instanceof ROT.Map.Feature.Room)
        {
            this._rooms.push(feature);
        }
        if (feature instanceof ROT.Map.Feature.Corridor)
        {
            feature.createPriorityWalls(this._priorityWallCallback);
            this._corridors.push(feature);
        }

        return true;
    };

    ROT.Map.Digger.prototype._removeSurroundingWalls = function(cx, cy)
    {
        var deltas = ROT.DIRS[4];

        for (var i = 0; i < deltas.length; i++)
        {
            var delta = deltas[i];
            var x = cx + delta[0];
            var y = cy + delta[1];
            delete this._walls[x + "," + y];
            var x = cx + 2 * delta[0];
            var y = cy + 2 * delta[1];
            delete this._walls[x + "," + y];
        }
    };

    /**
     * Returns vector in "digging" direction, or false, if this does not exist (or is not unique)
     */
    ROT.Map.Digger.prototype._getDiggingDirection = function(cx, cy)
    {
        if (cx <= 0 || cy <= 0 || cx >= this._width - 1 || cy >= this._height - 1)
        {
            return null;
        }

        var result = null;
        var deltas = ROT.DIRS[4];

        for (var i = 0; i < deltas.length; i++)
        {
            var delta = deltas[i];
            var x = cx + delta[0];
            var y = cy + delta[1];

            if (!this._map[x][y])
            { /* there already is another empty neighbor! */
                if (result)
                {
                    return null;
                }
                result = delta;
            }
        }

        /* no empty neighbor */
        if (!result)
        {
            return null;
        }

        return [-result[0], -result[1]];
    };

    /**
     * Find empty spaces surrounding rooms, and apply doors.
     */
    ROT.Map.Digger.prototype._addDoors = function()
    {
        var data = this._map;
        var isWallCallback = function(x, y)
        {
            return (data[x][y] == 1);
        };
        for (var i = 0; i < this._rooms.length; i++)
        {
            var room = this._rooms[i];
            room.clearDoors();
            room.addDoors(isWallCallback);
        }
    };
    /**
     * @class Dungeon generator which tries to fill the space evenly. Generates independent rooms and tries to connect them.
     * @augments ROT.Map.Dungeon
     */
    ROT.Map.Uniform = function(width, height, options)
    {
        ROT.Map.Dungeon.call(this, width, height);

        this._options = {
            roomWidth: [3, 9],
            /* room minimum and maximum width */
            roomHeight: [3, 5],
            /* room minimum and maximum height */
            roomDugPercentage: 0.1,
            /* we stop after this percentage of level area has been dug out by rooms */
            timeLimit: 1000 /* we stop after this much time has passed (msec) */
        };
        for (var p in options)
        {
            this._options[p] = options[p];
        }

        this._roomAttempts = 20; /* new room is created N-times until is considered as impossible to generate */
        this._corridorAttempts = 20; /* corridors are tried N-times until the level is considered as impossible to connect */

        this._connected = []; /* list of already connected rooms */
        this._unconnected = []; /* list of remaining unconnected rooms */

        this._digCallback = this._digCallback.bind(this);
        this._canBeDugCallback = this._canBeDugCallback.bind(this);
        this._isWallCallback = this._isWallCallback.bind(this);
    };
    ROT.Map.Uniform.extend(ROT.Map.Dungeon);

    /**
     * Create a map. If the time limit has been hit, returns null.
     * @see ROT.Map#create
     */
    ROT.Map.Uniform.prototype.create = function(callback)
    {
        var t1 = Date.now();
        while (1)
        {
            var t2 = Date.now();
            if (t2 - t1 > this._options.timeLimit)
            {
                return null;
            } /* time limit! */

            this._map = this._fillMap(1);
            this._dug = 0;
            this._rooms = [];
            this._unconnected = [];
            this._generateRooms();
            if (this._rooms.length < 2)
            {
                continue;
            }
            if (this._generateCorridors())
            {
                break;
            }
        }

        if (callback)
        {
            for (var i = 0; i < this._width; i++)
            {
                for (var j = 0; j < this._height; j++)
                {
                    callback(i, j, this._map[i][j]);
                }
            }
        }

        return this;
    };

    /**
     * Generates a suitable amount of rooms
     */
    ROT.Map.Uniform.prototype._generateRooms = function()
    {
        var w = this._width - 2;
        var h = this._height - 2;

        do {
            var room = this._generateRoom();
            if (this._dug / (w * h) > this._options.roomDugPercentage)
            {
                break;
            } /* achieved requested amount of free space */
        } while (room);

        /* either enough rooms, or not able to generate more of them :) */
    };

    /**
     * Try to generate one room
     */
    ROT.Map.Uniform.prototype._generateRoom = function()
    {
        var count = 0;
        while (count < this._roomAttempts)
        {
            count++;

            var room = ROT.Map.Feature.Room.createRandom(this._width, this._height, this._options);
            if (!room.isValid(this._isWallCallback, this._canBeDugCallback))
            {
                continue;
            }

            room.create(this._digCallback);
            this._rooms.push(room);
            return room;
        }

        /* no room was generated in a given number of attempts */
        return null;
    };

    /**
     * Generates connectors beween rooms
     * @returns {bool} success Was this attempt successfull?
     */
    ROT.Map.Uniform.prototype._generateCorridors = function()
    {
        var cnt = 0;
        while (cnt < this._corridorAttempts)
        {
            cnt++;
            this._corridors = [];

            /* dig rooms into a clear map */
            this._map = this._fillMap(1);
            for (var i = 0; i < this._rooms.length; i++)
            {
                var room = this._rooms[i];
                room.clearDoors();
                room.create(this._digCallback);
            }

            this._unconnected = this._rooms.slice().randomize();
            this._connected = [];
            if (this._unconnected.length)
            {
                this._connected.push(this._unconnected.pop());
            } /* first one is always connected */

            while (1)
            {
                /* 1. pick random connected room */
                var connected = this._connected.random();

                /* 2. find closest unconnected */
                var room1 = this._closestRoom(this._unconnected, connected);

                /* 3. connect it to closest connected */
                var room2 = this._closestRoom(this._connected, room1);

                var ok = this._connectRooms(room1, room2);
                if (!ok)
                {
                    break;
                } /* stop connecting, re-shuffle */

                if (!this._unconnected.length)
                {
                    return true;
                } /* done; no rooms remain */
            }
        }
        return false;
    };

    /**
     * For a given room, find the closest one from the list
     */
    ROT.Map.Uniform.prototype._closestRoom = function(rooms, room)
    {
        var dist = Infinity;
        var center = room.getCenter();
        var result = null;

        for (var i = 0; i < rooms.length; i++)
        {
            var r = rooms[i];
            var c = r.getCenter();
            var dx = c[0] - center[0];
            var dy = c[1] - center[1];
            var d = dx * dx + dy * dy;

            if (d < dist)
            {
                dist = d;
                result = r;
            }
        }

        return result;
    };

    ROT.Map.Uniform.prototype._connectRooms = function(room1, room2)
    {
        /*
		room1.debug();
		room2.debug();
	*/

        var center1 = room1.getCenter();
        var center2 = room2.getCenter();

        var diffX = center2[0] - center1[0];
        var diffY = center2[1] - center1[1];

        if (Math.abs(diffX) < Math.abs(diffY))
        { /* first try connecting north-south walls */
            var dirIndex1 = (diffY > 0 ? 2 : 0);
            var dirIndex2 = (dirIndex1 + 2) % 4;
            var min = room2.getLeft();
            var max = room2.getRight();
            var index = 0;
        }
        else
        { /* first try connecting east-west walls */
            var dirIndex1 = (diffX > 0 ? 1 : 3);
            var dirIndex2 = (dirIndex1 + 2) % 4;
            var min = room2.getTop();
            var max = room2.getBottom();
            var index = 1;
        }

        var start = this._placeInWall(room1, dirIndex1); /* corridor will start here */
        if (!start)
        {
            return false;
        }

        if (start[index] >= min && start[index] <= max)
        { /* possible to connect with straight line (I-like) */
            var end = start.slice();
            var value = null;
            switch (dirIndex2)
            {
                case 0:
                    value = room2.getTop() - 1;
                    break;
                case 1:
                    value = room2.getRight() + 1;
                    break;
                case 2:
                    value = room2.getBottom() + 1;
                    break;
                case 3:
                    value = room2.getLeft() - 1;
                    break;
            }
            end[(index + 1) % 2] = value;
            this._digLine([start, end]);

        }
        else if (start[index] < min - 1 || start[index] > max + 1)
        { /* need to switch target wall (L-like) */

            var diff = start[index] - center2[index];
            switch (dirIndex2)
            {
                case 0:
                case 1:
                    var rotation = (diff < 0 ? 3 : 1);
                    break;
                case 2:
                case 3:
                    var rotation = (diff < 0 ? 1 : 3);
                    break;
            }
            dirIndex2 = (dirIndex2 + rotation) % 4;

            var end = this._placeInWall(room2, dirIndex2);
            if (!end)
            {
                return false;
            }

            var mid = [0, 0];
            mid[index] = start[index];
            var index2 = (index + 1) % 2;
            mid[index2] = end[index2];
            this._digLine([start, mid, end]);

        }
        else
        { /* use current wall pair, but adjust the line in the middle (S-like) */

            var index2 = (index + 1) % 2;
            var end = this._placeInWall(room2, dirIndex2);
            if (!end)
            {
                return false;
            }
            var mid = Math.round((end[index2] + start[index2]) / 2);

            var mid1 = [0, 0];
            var mid2 = [0, 0];
            mid1[index] = start[index];
            mid1[index2] = mid;
            mid2[index] = end[index];
            mid2[index2] = mid;
            this._digLine([start, mid1, mid2, end]);
        }

        room1.addDoor(start[0], start[1]);
        room2.addDoor(end[0], end[1]);

        var index = this._unconnected.indexOf(room1);
        if (index != -1)
        {
            this._unconnected.splice(index, 1);
            this._connected.push(room1);
        }

        var index = this._unconnected.indexOf(room2);
        if (index != -1)
        {
            this._unconnected.splice(index, 1);
            this._connected.push(room2);
        }

        return true;
    };

    ROT.Map.Uniform.prototype._placeInWall = function(room, dirIndex)
    {
        var start = [0, 0];
        var dir = [0, 0];
        var length = 0;

        switch (dirIndex)
        {
            case 0:
                dir = [1, 0];
                start = [room.getLeft(), room.getTop() - 1];
                length = room.getRight() - room.getLeft() + 1;
                break;
            case 1:
                dir = [0, 1];
                start = [room.getRight() + 1, room.getTop()];
                length = room.getBottom() - room.getTop() + 1;
                break;
            case 2:
                dir = [1, 0];
                start = [room.getLeft(), room.getBottom() + 1];
                length = room.getRight() - room.getLeft() + 1;
                break;
            case 3:
                dir = [0, 1];
                start = [room.getLeft() - 1, room.getTop()];
                length = room.getBottom() - room.getTop() + 1;
                break;
        }

        var avail = [];
        var lastBadIndex = -2;

        for (var i = 0; i < length; i++)
        {
            var x = start[0] + i * dir[0];
            var y = start[1] + i * dir[1];
            avail.push(null);

            var isWall = (this._map[x][y] == 1);
            if (isWall)
            {
                if (lastBadIndex != i - 1)
                {
                    avail[i] = [x, y];
                }
            }
            else
            {
                lastBadIndex = i;
                if (i)
                {
                    avail[i - 1] = null;
                }
            }
        }

        for (var i = avail.length - 1; i >= 0; i--)
        {
            if (!avail[i])
            {
                avail.splice(i, 1);
            }
        }
        return (avail.length ? avail.random() : null);
    };

    /**
     * Dig a polyline.
     */
    ROT.Map.Uniform.prototype._digLine = function(points)
    {
        for (var i = 1; i < points.length; i++)
        {
            var start = points[i - 1];
            var end = points[i];
            var corridor = new ROT.Map.Feature.Corridor(start[0], start[1], end[0], end[1]);
            corridor.create(this._digCallback);
            this._corridors.push(corridor);
        }
    };

    ROT.Map.Uniform.prototype._digCallback = function(x, y, value)
    {
        this._map[x][y] = value;
        if (value == 0)
        {
            this._dug++;
        }
    };

    ROT.Map.Uniform.prototype._isWallCallback = function(x, y)
    {
        if (x < 0 || y < 0 || x >= this._width || y >= this._height)
        {
            return false;
        }
        return (this._map[x][y] == 1);
    };

    ROT.Map.Uniform.prototype._canBeDugCallback = function(x, y)
    {
        if (x < 1 || y < 1 || x + 1 >= this._width || y + 1 >= this._height)
        {
            return false;
        }
        return (this._map[x][y] == 1);
    };

    /**
     * @author hyakugei
     * @class Dungeon generator which uses the "orginal" Rogue dungeon generation algorithm. See http://kuoi.com/~kamikaze/GameDesign/art07_rogue_dungeon.php
     * @augments ROT.Map
     * @param {int} [width=ROT.DEFAULT_WIDTH]
     * @param {int} [height=ROT.DEFAULT_HEIGHT]
     * @param {object} [options] Options
     * @param {int[]} [options.cellWidth=3] Number of cells to create on the horizontal (number of rooms horizontally)
     * @param {int[]} [options.cellHeight=3] Number of cells to create on the vertical (number of rooms vertically)
     * @param {int} [options.roomWidth] Room min and max width - normally set auto-magically via the constructor.
     * @param {int} [options.roomHeight] Room min and max height - normally set auto-magically via the constructor.
     */
    ROT.Map.Rogue = function(width, height, options)
    {
        ROT.Map.call(this, width, height);

        this._options = {
            cellWidth: 3, // NOTE to self, these could probably work the same as the roomWidth/room Height values
            cellHeight: 3 //     ie. as an array with min-max values for each direction....
        };

        for (var p in options)
        {
            this._options[p] = options[p];
        }

        /*
	Set the room sizes according to the over-all width of the map,
	and the cell sizes.
	*/
        if (!this._options.hasOwnProperty("roomWidth"))
        {
            this._options["roomWidth"] = this._calculateRoomSize(this._width, this._options["cellWidth"]);
        }
        if (!this._options.hasOwnProperty("roomHeight"))
        {
            this._options["roomHeight"] = this._calculateRoomSize(this._height, this._options["cellHeight"]);
        }

    };

    ROT.Map.Rogue.extend(ROT.Map);

    /**
     * @see ROT.Map#create
     */
    ROT.Map.Rogue.prototype.create = function(callback)
    {
        this.map = this._fillMap(1);
        this.rooms = [];
        this.connectedCells = [];

        this._initRooms();
        this._connectRooms();
        this._connectUnconnectedRooms();
        this._createRandomRoomConnections();
        this._createRooms();
        this._createCorridors();

        if (callback)
        {
            for (var i = 0; i < this._width; i++)
            {
                for (var j = 0; j < this._height; j++)
                {
                    callback(i, j, this.map[i][j]);
                }
            }
        }

        return this;
    };

    ROT.Map.Rogue.prototype._calculateRoomSize = function(size, cell)
    {
        var max = Math.floor((size / cell) * 0.8);
        var min = Math.floor((size / cell) * 0.25);
        if (min < 2)
        {
            min = 2;
        }
        if (max < 2)
        {
            max = 2;
        }
        return [min, max];
    };

    ROT.Map.Rogue.prototype._initRooms = function()
    {
        // create rooms array. This is the "grid" list from the algo.
        for (var i = 0; i < this._options.cellWidth; i++)
        {
            this.rooms.push([]);
            for (var j = 0; j < this._options.cellHeight; j++)
            {
                this.rooms[i].push(
                {
                    "x": 0,
                    "y": 0,
                    "width": 0,
                    "height": 0,
                    "connections": [],
                    "cellx": i,
                    "celly": j
                });
            }
        }
    };

    ROT.Map.Rogue.prototype._connectRooms = function()
    {
        //pick random starting grid
        var cgx = ROT.RNG.getUniformInt(0, this._options.cellWidth - 1);
        var cgy = ROT.RNG.getUniformInt(0, this._options.cellHeight - 1);

        var idx;
        var ncgx;
        var ncgy;

        var found = false;
        var room;
        var otherRoom;

        // find  unconnected neighbour cells
        do {

            //var dirToCheck = [0, 1, 2, 3, 4, 5, 6, 7];
            var dirToCheck = [0, 2, 4, 6];
            dirToCheck = dirToCheck.randomize();

            do {
                found = false;
                idx = dirToCheck.pop();

                ncgx = cgx + ROT.DIRS[8][idx][0];
                ncgy = cgy + ROT.DIRS[8][idx][1];

                if (ncgx < 0 || ncgx >= this._options.cellWidth)
                {
                    continue;
                }
                if (ncgy < 0 || ncgy >= this._options.cellHeight)
                {
                    continue;
                }

                room = this.rooms[cgx][cgy];

                if (room["connections"].length > 0)
                {
                    // as long as this room doesn't already coonect to me, we are ok with it.
                    if (room["connections"][0][0] == ncgx && room["connections"][0][1] == ncgy)
                    {
                        break;
                    }
                }

                otherRoom = this.rooms[ncgx][ncgy];

                if (otherRoom["connections"].length == 0)
                {
                    otherRoom["connections"].push([cgx, cgy]);

                    this.connectedCells.push([ncgx, ncgy]);
                    cgx = ncgx;
                    cgy = ncgy;
                    found = true;
                }

            } while (dirToCheck.length > 0 && found == false);

        } while (dirToCheck.length > 0);

    };

    ROT.Map.Rogue.prototype._connectUnconnectedRooms = function()
    {
        //While there are unconnected rooms, try to connect them to a random connected neighbor
        //(if a room has no connected neighbors yet, just keep cycling, you'll fill out to it eventually).
        var cw = this._options.cellWidth;
        var ch = this._options.cellHeight;

        this.connectedCells = this.connectedCells.randomize();
        var room;
        var otherRoom;
        var validRoom;

        for (var i = 0; i < this._options.cellWidth; i++)
        {
            for (var j = 0; j < this._options.cellHeight; j++)
            {

                room = this.rooms[i][j];

                if (room["connections"].length == 0)
                {
                    var directions = [0, 2, 4, 6];
                    directions = directions.randomize();

                    validRoom = false;

                    do {

                        var dirIdx = directions.pop();
                        var newI = i + ROT.DIRS[8][dirIdx][0];
                        var newJ = j + ROT.DIRS[8][dirIdx][1];

                        if (newI < 0 || newI >= cw || newJ < 0 || newJ >= ch)
                        {
                            continue;
                        }

                        otherRoom = this.rooms[newI][newJ];

                        validRoom = true;

                        if (otherRoom["connections"].length == 0)
                        {
                            break;
                        }

                        for (var k = 0; k < otherRoom["connections"].length; k++)
                        {
                            if (otherRoom["connections"][k][0] == i && otherRoom["connections"][k][1] == j)
                            {
                                validRoom = false;
                                break;
                            }
                        }

                        if (validRoom)
                        {
                            break;
                        }

                    } while (directions.length);

                    if (validRoom)
                    {
                        room["connections"].push([otherRoom["cellx"], otherRoom["celly"]]);
                    }
                    else
                    {
                        console.log("-- Unable to connect room.");
                    }
                }
            }
        }
    };

    ROT.Map.Rogue.prototype._createRandomRoomConnections = function(connections)
    {
        // Empty for now.
    };


    ROT.Map.Rogue.prototype._createRooms = function()
    {
        // Create Rooms

        var w = this._width;
        var h = this._height;

        var cw = this._options.cellWidth;
        var ch = this._options.cellHeight;

        var cwp = Math.floor(this._width / cw);
        var chp = Math.floor(this._height / ch);

        var roomw;
        var roomh;
        var roomWidth = this._options["roomWidth"];
        var roomHeight = this._options["roomHeight"];
        var sx;
        var sy;
        var otherRoom;

        for (var i = 0; i < cw; i++)
        {
            for (var j = 0; j < ch; j++)
            {
                sx = cwp * i;
                sy = chp * j;

                if (sx == 0)
                {
                    sx = 1;
                }
                if (sy == 0)
                {
                    sy = 1;
                }

                roomw = ROT.RNG.getUniformInt(roomWidth[0], roomWidth[1]);
                roomh = ROT.RNG.getUniformInt(roomHeight[0], roomHeight[1]);

                if (j > 0)
                {
                    otherRoom = this.rooms[i][j - 1];
                    while (sy - (otherRoom["y"] + otherRoom["height"]) < 3)
                    {
                        sy++;
                    }
                }

                if (i > 0)
                {
                    otherRoom = this.rooms[i - 1][j];
                    while (sx - (otherRoom["x"] + otherRoom["width"]) < 3)
                    {
                        sx++;
                    }
                }

                var sxOffset = Math.round(ROT.RNG.getUniformInt(0, cwp - roomw) / 2);
                var syOffset = Math.round(ROT.RNG.getUniformInt(0, chp - roomh) / 2);

                while (sx + sxOffset + roomw >= w)
                {
                    if (sxOffset)
                    {
                        sxOffset--;
                    }
                    else
                    {
                        roomw--;
                    }
                }

                while (sy + syOffset + roomh >= h)
                {
                    if (syOffset)
                    {
                        syOffset--;
                    }
                    else
                    {
                        roomh--;
                    }
                }

                sx = sx + sxOffset;
                sy = sy + syOffset;

                this.rooms[i][j]["x"] = sx;
                this.rooms[i][j]["y"] = sy;
                this.rooms[i][j]["width"] = roomw;
                this.rooms[i][j]["height"] = roomh;

                for (var ii = sx; ii < sx + roomw; ii++)
                {
                    for (var jj = sy; jj < sy + roomh; jj++)
                    {
                        this.map[ii][jj] = 0;
                    }
                }
            }
        }
    };

    ROT.Map.Rogue.prototype._getWallPosition = function(aRoom, aDirection)
    {
        var rx;
        var ry;
        var door;

        if (aDirection == 1 || aDirection == 3)
        {
            rx = ROT.RNG.getUniformInt(aRoom["x"] + 1, aRoom["x"] + aRoom["width"] - 2);
            if (aDirection == 1)
            {
                ry = aRoom["y"] - 2;
                door = ry + 1;
            }
            else
            {
                ry = aRoom["y"] + aRoom["height"] + 1;
                door = ry - 1;
            }

            this.map[rx][door] = 0; // i'm not setting a specific 'door' tile value right now, just empty space.

        }
        else if (aDirection == 2 || aDirection == 4)
        {
            ry = ROT.RNG.getUniformInt(aRoom["y"] + 1, aRoom["y"] + aRoom["height"] - 2);
            if (aDirection == 2)
            {
                rx = aRoom["x"] + aRoom["width"] + 1;
                door = rx - 1;
            }
            else
            {
                rx = aRoom["x"] - 2;
                door = rx + 1;
            }

            this.map[door][ry] = 0; // i'm not setting a specific 'door' tile value right now, just empty space.

        }
        return [rx, ry];
    };

    /***
     * @param startPosition a 2 element array
     * @param endPosition a 2 element array
     */
    ROT.Map.Rogue.prototype._drawCorridor = function(startPosition, endPosition)
    {
        var xOffset = endPosition[0] - startPosition[0];
        var yOffset = endPosition[1] - startPosition[1];

        var xpos = startPosition[0];
        var ypos = startPosition[1];

        var tempDist;
        var xDir;
        var yDir;

        var move; // 2 element array, element 0 is the direction, element 1 is the total value to move.
        var moves = []; // a list of 2 element arrays

        var xAbs = Math.abs(xOffset);
        var yAbs = Math.abs(yOffset);

        var percent = ROT.RNG.getUniform(); // used to split the move at different places along the long axis
        var firstHalf = percent;
        var secondHalf = 1 - percent;

        xDir = xOffset > 0 ? 2 : 6;
        yDir = yOffset > 0 ? 4 : 0;

        if (xAbs < yAbs)
        {
            // move firstHalf of the y offset
            tempDist = Math.ceil(yAbs * firstHalf);
            moves.push([yDir, tempDist]);
            // move all the x offset
            moves.push([xDir, xAbs]);
            // move sendHalf of the  y offset
            tempDist = Math.floor(yAbs * secondHalf);
            moves.push([yDir, tempDist]);
        }
        else
        {
            //  move firstHalf of the x offset
            tempDist = Math.ceil(xAbs * firstHalf);
            moves.push([xDir, tempDist]);
            // move all the y offset
            moves.push([yDir, yAbs]);
            // move secondHalf of the x offset.
            tempDist = Math.floor(xAbs * secondHalf);
            moves.push([xDir, tempDist]);
        }

        this.map[xpos][ypos] = 0;

        while (moves.length > 0)
        {
            move = moves.pop();
            while (move[1] > 0)
            {
                xpos += ROT.DIRS[8][move[0]][0];
                ypos += ROT.DIRS[8][move[0]][1];
                this.map[xpos][ypos] = 0;
                move[1] = move[1] - 1;
            }
        }
    };

    ROT.Map.Rogue.prototype._createCorridors = function()
    {
        // Draw Corridors between connected rooms

        var cw = this._options.cellWidth;
        var ch = this._options.cellHeight;
        var room;
        var connection;
        var otherRoom;
        var wall;
        var otherWall;

        for (var i = 0; i < cw; i++)
        {
            for (var j = 0; j < ch; j++)
            {
                room = this.rooms[i][j];

                for (var k = 0; k < room["connections"].length; k++)
                {

                    connection = room["connections"][k];

                    otherRoom = this.rooms[connection[0]][connection[1]];

                    // figure out what wall our corridor will start one.
                    // figure out what wall our corridor will end on.
                    if (otherRoom["cellx"] > room["cellx"])
                    {
                        wall = 2;
                        otherWall = 4;
                    }
                    else if (otherRoom["cellx"] < room["cellx"])
                    {
                        wall = 4;
                        otherWall = 2;
                    }
                    else if (otherRoom["celly"] > room["celly"])
                    {
                        wall = 3;
                        otherWall = 1;
                    }
                    else if (otherRoom["celly"] < room["celly"])
                    {
                        wall = 1;
                        otherWall = 3;
                    }

                    this._drawCorridor(this._getWallPosition(room, wall), this._getWallPosition(otherRoom, otherWall));
                }
            }
        }
    };
    /**
     * @class Dungeon feature; has own .create() method
     */
    ROT.Map.Feature = function()
    {};
    ROT.Map.Feature.prototype.isValid = function(canBeDugCallback)
    {};
    ROT.Map.Feature.prototype.create = function(digCallback)
    {};
    ROT.Map.Feature.prototype.debug = function()
    {};
    ROT.Map.Feature.createRandomAt = function(x, y, dx, dy, options)
    {};

    /**
     * @class Room
     * @augments ROT.Map.Feature
     * @param {int} x1
     * @param {int} y1
     * @param {int} x2
     * @param {int} y2
     * @param {int} [doorX]
     * @param {int} [doorY]
     */
    ROT.Map.Feature.Room = function(x1, y1, x2, y2, doorX, doorY)
    {
        this._x1 = x1;
        this._y1 = y1;
        this._x2 = x2;
        this._y2 = y2;
        this._doors = {};
        if (arguments.length > 4)
        {
            this.addDoor(doorX, doorY);
        }
    };
    ROT.Map.Feature.Room.extend(ROT.Map.Feature);

    /**
     * Room of random size, with a given doors and direction
     */
    ROT.Map.Feature.Room.createRandomAt = function(x, y, dx, dy, options)
    {
        var min = options.roomWidth[0];
        var max = options.roomWidth[1];
        var width = ROT.RNG.getUniformInt(min, max);

        var min = options.roomHeight[0];
        var max = options.roomHeight[1];
        var height = ROT.RNG.getUniformInt(min, max);

        if (dx == 1)
        { /* to the right */
            var y2 = y - Math.floor(ROT.RNG.getUniform() * height);
            return new this(x + 1, y2, x + width, y2 + height - 1, x, y);
        }

        if (dx == -1)
        { /* to the left */
            var y2 = y - Math.floor(ROT.RNG.getUniform() * height);
            return new this(x - width, y2, x - 1, y2 + height - 1, x, y);
        }

        if (dy == 1)
        { /* to the bottom */
            var x2 = x - Math.floor(ROT.RNG.getUniform() * width);
            return new this(x2, y + 1, x2 + width - 1, y + height, x, y);
        }

        if (dy == -1)
        { /* to the top */
            var x2 = x - Math.floor(ROT.RNG.getUniform() * width);
            return new this(x2, y - height, x2 + width - 1, y - 1, x, y);
        }

        throw new Error("dx or dy must be 1 or -1");
    };

    /**
     * Room of random size, positioned around center coords
     */
    ROT.Map.Feature.Room.createRandomCenter = function(cx, cy, options)
    {
        var min = options.roomWidth[0];
        var max = options.roomWidth[1];
        var width = ROT.RNG.getUniformInt(min, max);

        var min = options.roomHeight[0];
        var max = options.roomHeight[1];
        var height = ROT.RNG.getUniformInt(min, max);

        var x1 = cx - Math.floor(ROT.RNG.getUniform() * width);
        var y1 = cy - Math.floor(ROT.RNG.getUniform() * height);
        var x2 = x1 + width - 1;
        var y2 = y1 + height - 1;

        return new this(x1, y1, x2, y2);
    };

    /**
     * Room of random size within a given dimensions
     */
    ROT.Map.Feature.Room.createRandom = function(availWidth, availHeight, options)
    {
        var min = options.roomWidth[0];
        var max = options.roomWidth[1];
        var width = ROT.RNG.getUniformInt(min, max);

        var min = options.roomHeight[0];
        var max = options.roomHeight[1];
        var height = ROT.RNG.getUniformInt(min, max);

        var left = availWidth - width - 1;
        var top = availHeight - height - 1;

        var x1 = 1 + Math.floor(ROT.RNG.getUniform() * left);
        var y1 = 1 + Math.floor(ROT.RNG.getUniform() * top);
        var x2 = x1 + width - 1;
        var y2 = y1 + height - 1;

        return new this(x1, y1, x2, y2);
    };

    ROT.Map.Feature.Room.prototype.addDoor = function(x, y)
    {
        this._doors[x + "," + y] = 1;
        return this;
    };

    /**
     * @param {function}
     */
    ROT.Map.Feature.Room.prototype.getDoors = function(callback)
    {
        for (var key in this._doors)
        {
            var parts = key.split(",");
            callback(parseInt(parts[0]), parseInt(parts[1]));
        }
        return this;
    };

    ROT.Map.Feature.Room.prototype.clearDoors = function()
    {
        this._doors = {};
        return this;
    };

    ROT.Map.Feature.Room.prototype.addDoors = function(isWallCallback)
    {
        var left = this._x1 - 1;
        var right = this._x2 + 1;
        var top = this._y1 - 1;
        var bottom = this._y2 + 1;

        for (var x = left; x <= right; x++)
        {
            for (var y = top; y <= bottom; y++)
            {
                if (x != left && x != right && y != top && y != bottom)
                {
                    continue;
                }
                if (isWallCallback(x, y))
                {
                    continue;
                }

                this.addDoor(x, y);
            }
        }

        return this;
    };

    ROT.Map.Feature.Room.prototype.debug = function()
    {
        console.log("room", this._x1, this._y1, this._x2, this._y2);
    };

    ROT.Map.Feature.Room.prototype.isValid = function(isWallCallback, canBeDugCallback)
    {
        var left = this._x1 - 1;
        var right = this._x2 + 1;
        var top = this._y1 - 1;
        var bottom = this._y2 + 1;

        for (var x = left; x <= right; x++)
        {
            for (var y = top; y <= bottom; y++)
            {
                if (x == left || x == right || y == top || y == bottom)
                {
                    if (!isWallCallback(x, y))
                    {
                        return false;
                    }
                }
                else
                {
                    if (!canBeDugCallback(x, y))
                    {
                        return false;
                    }
                }
            }
        }

        return true;
    };

    /**
     * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty, 1 = wall, 2 = door. Multiple doors are allowed.
     */
    ROT.Map.Feature.Room.prototype.create = function(digCallback)
    {
        var left = this._x1 - 1;
        var right = this._x2 + 1;
        var top = this._y1 - 1;
        var bottom = this._y2 + 1;

        var value = 0;
        for (var x = left; x <= right; x++)
        {
            for (var y = top; y <= bottom; y++)
            {
                if (x + "," + y in this._doors)
                {
                    value = 2;
                }
                else if (x == left || x == right || y == top || y == bottom)
                {
                    value = 1;
                }
                else
                {
                    value = 0;
                }
                digCallback(x, y, value);
            }
        }
    };

    ROT.Map.Feature.Room.prototype.getCenter = function()
    {
        return [Math.round((this._x1 + this._x2) / 2), Math.round((this._y1 + this._y2) / 2)];
    };

    ROT.Map.Feature.Room.prototype.getLeft = function()
    {
        return this._x1;
    };

    ROT.Map.Feature.Room.prototype.getRight = function()
    {
        return this._x2;
    };

    ROT.Map.Feature.Room.prototype.getTop = function()
    {
        return this._y1;
    };

    ROT.Map.Feature.Room.prototype.getBottom = function()
    {
        return this._y2;
    };

    /**
     * @class Corridor
     * @augments ROT.Map.Feature
     * @param {int} startX
     * @param {int} startY
     * @param {int} endX
     * @param {int} endY
     */
    ROT.Map.Feature.Corridor = function(startX, startY, endX, endY)
    {
        this._startX = startX;
        this._startY = startY;
        this._endX = endX;
        this._endY = endY;
        this._endsWithAWall = true;
    };
    ROT.Map.Feature.Corridor.extend(ROT.Map.Feature);

    ROT.Map.Feature.Corridor.createRandomAt = function(x, y, dx, dy, options)
    {
        var min = options.corridorLength[0];
        var max = options.corridorLength[1];
        var length = ROT.RNG.getUniformInt(min, max);

        return new this(x, y, x + dx * length, y + dy * length);
    };

    ROT.Map.Feature.Corridor.prototype.debug = function()
    {
        console.log("corridor", this._startX, this._startY, this._endX, this._endY);
    };

    ROT.Map.Feature.Corridor.prototype.isValid = function(isWallCallback, canBeDugCallback)
    {
        var sx = this._startX;
        var sy = this._startY;
        var dx = this._endX - sx;
        var dy = this._endY - sy;
        var length = 1 + Math.max(Math.abs(dx), Math.abs(dy));

        if (dx)
        {
            dx = dx / Math.abs(dx);
        }
        if (dy)
        {
            dy = dy / Math.abs(dy);
        }
        var nx = dy;
        var ny = -dx;

        var ok = true;
        for (var i = 0; i < length; i++)
        {
            var x = sx + i * dx;
            var y = sy + i * dy;

            if (!canBeDugCallback(x, y))
            {
                ok = false;
            }
            if (!isWallCallback(x + nx, y + ny))
            {
                ok = false;
            }
            if (!isWallCallback(x - nx, y - ny))
            {
                ok = false;
            }

            if (!ok)
            {
                length = i;
                this._endX = x - dx;
                this._endY = y - dy;
                break;
            }
        }

        /**
         * If the length degenerated, this corridor might be invalid
         */

        /* not supported */
        if (length == 0)
        {
            return false;
        }

        /* length 1 allowed only if the next space is empty */
        if (length == 1 && isWallCallback(this._endX + dx, this._endY + dy))
        {
            return false;
        }

        /**
         * We do not want the corridor to crash into a corner of a room;
         * if any of the ending corners is empty, the N+1th cell of this corridor must be empty too.
         *
         * Situation:
         * #######1
         * .......?
         * #######2
         *
         * The corridor was dug from left to right.
         * 1, 2 - problematic corners, ? = N+1th cell (not dug)
         */
        var firstCornerBad = !isWallCallback(this._endX + dx + nx, this._endY + dy + ny);
        var secondCornerBad = !isWallCallback(this._endX + dx - nx, this._endY + dy - ny);
        this._endsWithAWall = isWallCallback(this._endX + dx, this._endY + dy);
        if ((firstCornerBad || secondCornerBad) && this._endsWithAWall)
        {
            return false;
        }

        return true;
    };

    /**
     * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty.
     */
    ROT.Map.Feature.Corridor.prototype.create = function(digCallback)
    {
        var sx = this._startX;
        var sy = this._startY;
        var dx = this._endX - sx;
        var dy = this._endY - sy;
        var length = 1 + Math.max(Math.abs(dx), Math.abs(dy));

        if (dx)
        {
            dx = dx / Math.abs(dx);
        }
        if (dy)
        {
            dy = dy / Math.abs(dy);
        }
        var nx = dy;
        var ny = -dx;

        for (var i = 0; i < length; i++)
        {
            var x = sx + i * dx;
            var y = sy + i * dy;
            digCallback(x, y, 0);
        }

        return true;
    };

    ROT.Map.Feature.Corridor.prototype.createPriorityWalls = function(priorityWallCallback)
    {
        if (!this._endsWithAWall)
        {
            return;
        }

        var sx = this._startX;
        var sy = this._startY;

        var dx = this._endX - sx;
        var dy = this._endY - sy;
        if (dx)
        {
            dx = dx / Math.abs(dx);
        }
        if (dy)
        {
            dy = dy / Math.abs(dy);
        }
        var nx = dy;
        var ny = -dx;

        priorityWallCallback(this._endX + dx, this._endY + dy);
        priorityWallCallback(this._endX + nx, this._endY + ny);
        priorityWallCallback(this._endX - nx, this._endY - ny);
    };
    /**
     * @class Base noise generator
     */
    ROT.Noise = function()
    {};

    ROT.Noise.prototype.get = function(x, y)
    {};
    /**
     * A simple 2d implementation of simplex noise by Ondrej Zara
     *
     * Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.
     * Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).
     * With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
     * Better rank ordering method by Stefan Gustavson in 2012.
     */

    /**
     * @class 2D simplex noise generator
     * @param {int} [gradients=256] Random gradients
     */
    ROT.Noise.Simplex = function(gradients)
    {
        ROT.Noise.call(this);

        this._F2 = 0.5 * (Math.sqrt(3) - 1);
        this._G2 = (3 - Math.sqrt(3)) / 6;

        this._gradients = [
        [0, -1],
        [1, -1],
        [1, 0],
        [1, 1],
        [0, 1],
        [-1, 1],
        [-1, 0],
        [-1, -1]
    ];

        var permutations = [];
        var count = gradients || 256;
        for (var i = 0; i < count; i++)
        {
            permutations.push(i);
        }
        permutations = permutations.randomize();

        this._perms = [];
        this._indexes = [];

        for (var i = 0; i < 2 * count; i++)
        {
            this._perms.push(permutations[i % count]);
            this._indexes.push(this._perms[i] % this._gradients.length);
        }

    };
    ROT.Noise.Simplex.extend(ROT.Noise);

    ROT.Noise.Simplex.prototype.get = function(xin, yin)
    {
        var perms = this._perms;
        var indexes = this._indexes;
        var count = perms.length / 2;
        var G2 = this._G2;

        var n0 = 0,
            n1 = 0,
            n2 = 0,
            gi; // Noise contributions from the three corners

        // Skew the input space to determine which simplex cell we're in
        var s = (xin + yin) * this._F2; // Hairy factor for 2D
        var i = Math.floor(xin + s);
        var j = Math.floor(yin + s);
        var t = (i + j) * G2;
        var X0 = i - t; // Unskew the cell origin back to (x,y) space
        var Y0 = j - t;
        var x0 = xin - X0; // The x,y distances from the cell origin
        var y0 = yin - Y0;

        // For the 2D case, the simplex shape is an equilateral triangle.
        // Determine which simplex we are in.
        var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
        if (x0 > y0)
        {
            i1 = 1;
            j1 = 0;
        }
        else
        { // lower triangle, XY order: (0,0)->(1,0)->(1,1)
            i1 = 0;
            j1 = 1;
        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)

        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
        // c = (3-sqrt(3))/6
        var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
        var y1 = y0 - j1 + G2;
        var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords
        var y2 = y0 - 1 + 2 * G2;

        // Work out the hashed gradient indices of the three simplex corners
        var ii = i.mod(count);
        var jj = j.mod(count);

        // Calculate the contribution from the three corners
        var t0 = 0.5 - x0 * x0 - y0 * y0;
        if (t0 >= 0)
        {
            t0 *= t0;
            gi = indexes[ii + perms[jj]];
            var grad = this._gradients[gi];
            n0 = t0 * t0 * (grad[0] * x0 + grad[1] * y0);
        }

        var t1 = 0.5 - x1 * x1 - y1 * y1;
        if (t1 >= 0)
        {
            t1 *= t1;
            gi = indexes[ii + i1 + perms[jj + j1]];
            var grad = this._gradients[gi];
            n1 = t1 * t1 * (grad[0] * x1 + grad[1] * y1);
        }

        var t2 = 0.5 - x2 * x2 - y2 * y2;
        if (t2 >= 0)
        {
            t2 *= t2;
            gi = indexes[ii + 1 + perms[jj + 1]];
            var grad = this._gradients[gi];
            n2 = t2 * t2 * (grad[0] * x2 + grad[1] * y2);
        }

        // Add contributions from each corner to get the final noise value.
        // The result is scaled to return values in the interval [-1,1].
        return 70 * (n0 + n1 + n2);
    }
    /**
     * @class Abstract FOV algorithm
     * @param {function} lightPassesCallback Does the light pass through x,y?
     * @param {object} [options]
     * @param {int} [options.topology=8] 4/6/8
     */
    ROT.FOV = function(lightPassesCallback, options)
    {
        this._lightPasses = lightPassesCallback;
        this._options = {
            topology: 8
        };
        for (var p in options)
        {
            this._options[p] = options[p];
        }
    };

    /**
     * Compute visibility for a 360-degree circle
     * @param {int} x
     * @param {int} y
     * @param {int} R Maximum visibility radius
     * @param {function} callback
     */
    ROT.FOV.prototype.compute = function(x, y, R, callback)
    {};

    /**
     * Return all neighbors in a concentric ring
     * @param {int} cx center-x
     * @param {int} cy center-y
     * @param {int} r range
     */
    ROT.FOV.prototype._getCircle = function(cx, cy, r)
    {
        var result = [];
        var dirs, countFactor, startOffset;

        switch (this._options.topology)
        {
            case 4:
                countFactor = 1;
                startOffset = [0, 1];
                dirs = [
                ROT.DIRS[8][7],
                ROT.DIRS[8][1],
                ROT.DIRS[8][3],
                ROT.DIRS[8][5]
            ];
                break;

            case 6:
                dirs = ROT.DIRS[6];
                countFactor = 1;
                startOffset = [-1, 1];
                break;

            case 8:
                dirs = ROT.DIRS[4];
                countFactor = 2;
                startOffset = [-1, 1];
                break;
        }

        /* starting neighbor */
        var x = cx + startOffset[0] * r;
        var y = cy + startOffset[1] * r;

        /* circle */
        for (var i = 0; i < dirs.length; i++)
        {
            for (var j = 0; j < r * countFactor; j++)
            {
                result.push([x, y]);
                x += dirs[i][0];
                y += dirs[i][1];

            }
        }

        return result;
    };
    /**
     * @class Discrete shadowcasting algorithm. Obsoleted by Precise shadowcasting.
     * @augments ROT.FOV
     */
    ROT.FOV.DiscreteShadowcasting = function(lightPassesCallback, options)
    {
        ROT.FOV.call(this, lightPassesCallback, options);
    };
    ROT.FOV.DiscreteShadowcasting.extend(ROT.FOV);

    /**
     * @see ROT.FOV#compute
     */
    ROT.FOV.DiscreteShadowcasting.prototype.compute = function(x, y, R, callback)
    {
        var center = this._coords;
        var map = this._map;

        /* this place is always visible */
        callback(x, y, 0, 1);

        /* standing in a dark place. FIXME is this a good idea?  */
        if (!this._lightPasses(x, y))
        {
            return;
        }

        /* start and end angles */
        var DATA = [];

        var A, B, cx, cy, blocks;

        /* analyze surrounding cells in concentric rings, starting from the center */
        for (var r = 1; r <= R; r++)
        {
            var neighbors = this._getCircle(x, y, r);
            var angle = 360 / neighbors.length;

            for (var i = 0; i < neighbors.length; i++)
            {
                cx = neighbors[i][0];
                cy = neighbors[i][1];
                A = angle * (i - 0.5);
                B = A + angle;

                blocks = !this._lightPasses(cx, cy);
                if (this._visibleCoords(Math.floor(A), Math.ceil(B), blocks, DATA))
                {
                    callback(cx, cy, r, 1);
                }

                if (DATA.length == 2 && DATA[0] == 0 && DATA[1] == 360)
                {
                    return;
                } /* cutoff? */

            } /* for all cells in this ring */
        } /* for all rings */
    };

    /**
     * @param {int} A start angle
     * @param {int} B end angle
     * @param {bool} blocks Does current cell block visibility?
     * @param {int[][]} DATA shadowed angle pairs
     */
    ROT.FOV.DiscreteShadowcasting.prototype._visibleCoords = function(A, B, blocks, DATA)
    {
        if (A < 0)
        {
            var v1 = this._visibleCoords(0, B, blocks, DATA);
            var v2 = this._visibleCoords(360 + A, 360, blocks, DATA);
            return v1 || v2;
        }

        var index = 0;
        while (index < DATA.length && DATA[index] < A)
        {
            index++;
        }

        if (index == DATA.length)
        { /* completely new shadow */
            if (blocks)
            {
                DATA.push(A, B);
            }
            return true;
        }

        var count = 0;

        if (index % 2)
        { /* this shadow starts in an existing shadow, or within its ending boundary */
            while (index < DATA.length && DATA[index] < B)
            {
                index++;
                count++;
            }

            if (count == 0)
            {
                return false;
            }

            if (blocks)
            {
                if (count % 2)
                {
                    DATA.splice(index - count, count, B);
                }
                else
                {
                    DATA.splice(index - count, count);
                }
            }

            return true;

        }
        else
        { /* this shadow starts outside an existing shadow, or within a starting boundary */
            while (index < DATA.length && DATA[index] < B)
            {
                index++;
                count++;
            }

            /* visible when outside an existing shadow, or when overlapping */
            if (A == DATA[index - count] && count == 1)
            {
                return false;
            }

            if (blocks)
            {
                if (count % 2)
                {
                    DATA.splice(index - count, count, A);
                }
                else
                {
                    DATA.splice(index - count, count, A, B);
                }
            }

            return true;
        }
    };
    /**
     * @class Precise shadowcasting algorithm
     * @augments ROT.FOV
     */
    ROT.FOV.PreciseShadowcasting = function(lightPassesCallback, options)
    {
        ROT.FOV.call(this, lightPassesCallback, options);
    };
    ROT.FOV.PreciseShadowcasting.extend(ROT.FOV);

    /**
     * @see ROT.FOV#compute
     */
    ROT.FOV.PreciseShadowcasting.prototype.compute = function(x, y, R, callback)
    {
        /* this place is always visible */
        callback(x, y, 0, 1);

        /* standing in a dark place. FIXME is this a good idea?  */
        if (!this._lightPasses(x, y))
        {
            return;
        }

        /* list of all shadows */
        var SHADOWS = [];

        var cx, cy, blocks, A1, A2, visibility;

        /* analyze surrounding cells in concentric rings, starting from the center */
        for (var r = 1; r <= R; r++)
        {
            var neighbors = this._getCircle(x, y, r);
            var neighborCount = neighbors.length;

            for (var i = 0; i < neighborCount; i++)
            {
                cx = neighbors[i][0];
                cy = neighbors[i][1];
                /* shift half-an-angle backwards to maintain consistency of 0-th cells */
                A1 = [i ? 2 * i - 1 : 2 * neighborCount - 1, 2 * neighborCount];
                A2 = [2 * i + 1, 2 * neighborCount];

                blocks = !this._lightPasses(cx, cy);
                visibility = this._checkVisibility(A1, A2, blocks, SHADOWS);
                if (visibility)
                {
                    callback(cx, cy, r, visibility);
                }

                if (SHADOWS.length == 2 && SHADOWS[0][0] == 0 && SHADOWS[1][0] == SHADOWS[1][1])
                {
                    return;
                } /* cutoff? */

            } /* for all cells in this ring */
        } /* for all rings */
    };

    /**
     * @param {int[2]} A1 arc start
     * @param {int[2]} A2 arc end
     * @param {bool} blocks Does current arc block visibility?
     * @param {int[][]} SHADOWS list of active shadows
     */
    ROT.FOV.PreciseShadowcasting.prototype._checkVisibility = function(A1, A2, blocks, SHADOWS)
    {
        if (A1[0] > A2[0])
        { /* split into two sub-arcs */
            var v1 = this._checkVisibility(A1, [A1[1], A1[1]], blocks, SHADOWS);
            var v2 = this._checkVisibility([0, 1], A2, blocks, SHADOWS);
            return (v1 + v2) / 2;
        }

        /* index1: first shadow >= A1 */
        var index1 = 0,
            edge1 = false;
        while (index1 < SHADOWS.length)
        {
            var old = SHADOWS[index1];
            var diff = old[0] * A1[1] - A1[0] * old[1];
            if (diff >= 0)
            { /* old >= A1 */
                if (diff == 0 && !(index1 % 2))
                {
                    edge1 = true;
                }
                break;
            }
            index1++;
        }

        /* index2: last shadow <= A2 */
        var index2 = SHADOWS.length,
            edge2 = false;
        while (index2--)
        {
            var old = SHADOWS[index2];
            var diff = A2[0] * old[1] - old[0] * A2[1];
            if (diff >= 0)
            { /* old <= A2 */
                if (diff == 0 && (index2 % 2))
                {
                    edge2 = true;
                }
                break;
            }
        }

        var visible = true;
        if (index1 == index2 && (edge1 || edge2))
        { /* subset of existing shadow, one of the edges match */
            visible = false;
        }
        else if (edge1 && edge2 && index1 + 1 == index2 && (index2 % 2))
        { /* completely equivalent with existing shadow */
            visible = false;
        }
        else if (index1 > index2 && (index1 % 2))
        { /* subset of existing shadow, not touching */
            visible = false;
        }

        if (!visible)
        {
            return 0;
        } /* fast case: not visible */

        var visibleLength, P;

        /* compute the length of visible arc, adjust list of shadows (if blocking) */
        var remove = index2 - index1 + 1;
        if (remove % 2)
        {
            if (index1 % 2)
            { /* first edge within existing shadow, second outside */
                var P = SHADOWS[index1];
                visibleLength = (A2[0] * P[1] - P[0] * A2[1]) / (P[1] * A2[1]);
                if (blocks)
                {
                    SHADOWS.splice(index1, remove, A2);
                }
            }
            else
            { /* second edge within existing shadow, first outside */
                var P = SHADOWS[index2];
                visibleLength = (P[0] * A1[1] - A1[0] * P[1]) / (A1[1] * P[1]);
                if (blocks)
                {
                    SHADOWS.splice(index1, remove, A1);
                }
            }
        }
        else
        {
            if (index1 % 2)
            { /* both edges within existing shadows */
                var P1 = SHADOWS[index1];
                var P2 = SHADOWS[index2];
                visibleLength = (P2[0] * P1[1] - P1[0] * P2[1]) / (P1[1] * P2[1]);
                if (blocks)
                {
                    SHADOWS.splice(index1, remove);
                }
            }
            else
            { /* both edges outside existing shadows */
                if (blocks)
                {
                    SHADOWS.splice(index1, remove, A1, A2);
                }
                return 1; /* whole arc visible! */
            }
        }

        var arcLength = (A2[0] * A1[1] - A1[0] * A2[1]) / (A1[1] * A2[1]);

        return visibleLength / arcLength;
    };
    /**
     * @class Recursive shadowcasting algorithm
     * Currently only supports 4/8 topologies, not hexagonal.
     * Based on Peter Harkins' implementation of Björn Bergström's algorithm described here: http://www.roguebasin.com/index.php?title=FOV_using_recursive_shadowcasting
     * @augments ROT.FOV
     */
    ROT.FOV.RecursiveShadowcasting = function(lightPassesCallback, options)
    {
        ROT.FOV.call(this, lightPassesCallback, options);
    };
    ROT.FOV.RecursiveShadowcasting.extend(ROT.FOV);

    /** Octants used for translating recursive shadowcasting offsets */
    ROT.FOV.RecursiveShadowcasting.OCTANTS = [
    [-1, 0, 0, 1],
    [0, -1, 1, 0],
    [0, -1, -1, 0],
    [-1, 0, 0, -1],
    [1, 0, 0, -1],
    [0, 1, -1, 0],
    [0, 1, 1, 0],
    [1, 0, 0, 1]
];

    /**
     * Compute visibility for a 360-degree circle
     * @param {int} x
     * @param {int} y
     * @param {int} R Maximum visibility radius
     * @param {function} callback
     */
    ROT.FOV.RecursiveShadowcasting.prototype.compute = function(x, y, R, callback)
    {
        //You can always see your own tile
        callback(x, y, 0, 1);
        for (var i = 0; i < ROT.FOV.RecursiveShadowcasting.OCTANTS.length; i++)
        {
            this._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[i], R, callback);
        }
    };

    /**
     * Compute visibility for a 180-degree arc
     * @param {int} x
     * @param {int} y
     * @param {int} R Maximum visibility radius
     * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);
     * @param {function} callback
     */
    ROT.FOV.RecursiveShadowcasting.prototype.compute180 = function(x, y, R, dir, callback)
    {
        //You can always see your own tile
        callback(x, y, 0, 1);
        var previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 180 degrees
        var nextPreviousOctant = (dir - 2 + 8) % 8; //Need to retrieve the previous two octants to render a full 180 degrees
        var nextOctant = (dir + 1 + 8) % 8; //Need to grab to next octant to render a full 180 degrees
        this._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextPreviousOctant], R, callback);
        this._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);
        this._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);
        this._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextOctant], R, callback);
    };

    /**
     * Compute visibility for a 90-degree arc
     * @param {int} x
     * @param {int} y
     * @param {int} R Maximum visibility radius
     * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);
     * @param {function} callback
     */
    ROT.FOV.RecursiveShadowcasting.prototype.compute90 = function(x, y, R, dir, callback)
    {
        //You can always see your own tile
        callback(x, y, 0, 1);
        var previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 90 degrees
        this._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);
        this._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);
    };

    /**
     * Render one octant (45-degree arc) of the viewshed
     * @param {int} x
     * @param {int} y
     * @param {int} octant Octant to be rendered
     * @param {int} R Maximum visibility radius
     * @param {function} callback
     */
    ROT.FOV.RecursiveShadowcasting.prototype._renderOctant = function(x, y, octant, R, callback)
    {
        //Radius incremented by 1 to provide same coverage area as other shadowcasting radiuses
        this._castVisibility(x, y, 1, 1.0, 0.0, R + 1, octant[0], octant[1], octant[2], octant[3], callback);
    };

    /**
     * Actually calculates the visibility
     * @param {int} startX The starting X coordinate
     * @param {int} startY The starting Y coordinate
     * @param {int} row The row to render
     * @param {float} visSlopeStart The slope to start at
     * @param {float} visSlopeEnd The slope to end at
     * @param {int} radius The radius to reach out to
     * @param {int} xx
     * @param {int} xy
     * @param {int} yx
     * @param {int} yy
     * @param {function} callback The callback to use when we hit a block that is visible
     */
    ROT.FOV.RecursiveShadowcasting.prototype._castVisibility = function(startX, startY, row, visSlopeStart, visSlopeEnd, radius, xx, xy, yx, yy, callback)
    {
        if (visSlopeStart < visSlopeEnd)
        {
            return;
        }
        for (var i = row; i <= radius; i++)
        {
            var dx = -i - 1;
            var dy = -i;
            var blocked = false;
            var newStart = 0;

            //'Row' could be column, names here assume octant 0 and would be flipped for half the octants
            while (dx <= 0)
            {
                dx += 1;

                //Translate from relative coordinates to map coordinates
                var mapX = startX + dx * xx + dy * xy;
                var mapY = startY + dx * yx + dy * yy;

                //Range of the row
                var slopeStart = (dx - 0.5) / (dy + 0.5);
                var slopeEnd = (dx + 0.5) / (dy - 0.5);

                //Ignore if not yet at left edge of Octant
                if (slopeEnd > visSlopeStart)
                {
                    continue;
                }

                //Done if past right edge
                if (slopeStart < visSlopeEnd)
                {
                    break;
                }

                //If it's in range, it's visible
                if ((dx * dx + dy * dy) < (radius * radius))
                {
                    callback(mapX, mapY, i, 1);
                }

                if (!blocked)
                {
                    //If tile is a blocking tile, cast around it
                    if (!this._lightPasses(mapX, mapY) && i < radius)
                    {
                        blocked = true;
                        this._castVisibility(startX, startY, i + 1, visSlopeStart, slopeStart, radius, xx, xy, yx, yy, callback);
                        newStart = slopeEnd;
                    }
                }
                else
                {
                    //Keep narrowing if scanning across a block
                    if (!this._lightPasses(mapX, mapY))
                    {
                        newStart = slopeEnd;
                        continue;
                    }

                    //Block has ended
                    blocked = false;
                    visSlopeStart = newStart;
                }
            }
            if (blocked)
            {
                break;
            }
        }
    };
    /**
     * @namespace Color operations
     */
    ROT.Color = {
        fromString: function(str)
        {
            var cached, r;
            if (str in this._cache)
            {
                cached = this._cache[str];
            }
            else
            {
                if (str.charAt(0) == "#")
                { /* hex rgb */

                    var values = str.match(/[0-9a-f]/gi).map(function(x)
                    {
                        return parseInt(x, 16);
                    });
                    if (values.length == 3)
                    {
                        cached = values.map(function(x)
                        {
                            return x * 17;
                        });
                    }
                    else
                    {
                        for (var i = 0; i < 3; i++)
                        {
                            values[i + 1] += 16 * values[i];
                            values.splice(i, 1);
                        }
                        cached = values;
                    }

                }
                else if ((r = str.match(/rgb\(([0-9, ]+)\)/i)))
                { /* decimal rgb */
                    cached = r[1].split(/\s*,\s*/).map(function(x)
                    {
                        return parseInt(x);
                    });
                }
                else
                { /* html name */
                    cached = [0, 0, 0];
                }

                this._cache[str] = cached;
            }

            return cached.slice();
        },

        /**
         * Add two or more colors
         * @param {number[]} color1
         * @param {number[]} color2
         * @returns {number[]}
         */
        add: function(color1, color2)
        {
            var result = color1.slice();
            for (var i = 0; i < 3; i++)
            {
                for (var j = 1; j < arguments.length; j++)
                {
                    result[i] += arguments[j][i];
                }
            }
            return result;
        },

        /**
         * Add two or more colors, MODIFIES FIRST ARGUMENT
         * @param {number[]} color1
         * @param {number[]} color2
         * @returns {number[]}
         */
        add_: function(color1, color2)
        {
            for (var i = 0; i < 3; i++)
            {
                for (var j = 1; j < arguments.length; j++)
                {
                    color1[i] += arguments[j][i];
                }
            }
            return color1;
        },

        /**
         * Multiply (mix) two or more colors
         * @param {number[]} color1
         * @param {number[]} color2
         * @returns {number[]}
         */
        multiply: function(color1, color2)
        {
            var result = color1.slice();
            for (var i = 0; i < 3; i++)
            {
                for (var j = 1; j < arguments.length; j++)
                {
                    result[i] *= arguments[j][i] / 255;
                }
                result[i] = Math.round(result[i]);
            }
            return result;
        },

        /**
         * Multiply (mix) two or more colors, MODIFIES FIRST ARGUMENT
         * @param {number[]} color1
         * @param {number[]} color2
         * @returns {number[]}
         */
        multiply_: function(color1, color2)
        {
            for (var i = 0; i < 3; i++)
            {
                for (var j = 1; j < arguments.length; j++)
                {
                    color1[i] *= arguments[j][i] / 255;
                }
                color1[i] = Math.round(color1[i]);
            }
            return color1;
        },

        /**
         * Interpolate (blend) two colors with a given factor
         * @param {number[]} color1
         * @param {number[]} color2
         * @param {float} [factor=0.5] 0..1
         * @returns {number[]}
         */
        interpolate: function(color1, color2, factor)
        {
            if (arguments.length < 3)
            {
                factor = 0.5;
            }
            var result = color1.slice();
            for (var i = 0; i < 3; i++)
            {
                result[i] = Math.round(result[i] + factor * (color2[i] - color1[i]));
            }
            return result;
        },

        /**
         * Interpolate (blend) two colors with a given factor in HSL mode
         * @param {number[]} color1
         * @param {number[]} color2
         * @param {float} [factor=0.5] 0..1
         * @returns {number[]}
         */
        interpolateHSL: function(color1, color2, factor)
        {
            if (arguments.length < 3)
            {
                factor = 0.5;
            }
            var hsl1 = this.rgb2hsl(color1);
            var hsl2 = this.rgb2hsl(color2);
            for (var i = 0; i < 3; i++)
            {
                hsl1[i] += factor * (hsl2[i] - hsl1[i]);
            }
            return this.hsl2rgb(hsl1);
        },

        /**
         * Create a new random color based on this one
         * @param {number[]} color
         * @param {number[]} diff Set of standard deviations
         * @returns {number[]}
         */
        randomize: function(color, diff)
        {
            if (!(diff instanceof Array))
            {
                diff = Math.round(ROT.RNG.getNormal(0, diff));
            }
            var result = color.slice();
            for (var i = 0; i < 3; i++)
            {
                result[i] += (diff instanceof Array ? Math.round(ROT.RNG.getNormal(0, diff[i])) : diff);
            }
            return result;
        },

        /**
         * Converts an RGB color value to HSL. Expects 0..255 inputs, produces 0..1 outputs.
         * @param {number[]} color
         * @returns {number[]}
         */
        rgb2hsl: function(color)
        {
            var r = color[0] / 255;
            var g = color[1] / 255;
            var b = color[2] / 255;

            var max = Math.max(r, g, b),
                min = Math.min(r, g, b);
            var h, s, l = (max + min) / 2;

            if (max == min)
            {
                h = s = 0; // achromatic
            }
            else
            {
                var d = max - min;
                s = (l > 0.5 ? d / (2 - max - min) : d / (max + min));
                switch (max)
                {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                }
                h /= 6;
            }

            return [h, s, l];
        },

        /**
         * Converts an HSL color value to RGB. Expects 0..1 inputs, produces 0..255 outputs.
         * @param {number[]} color
         * @returns {number[]}
         */
        hsl2rgb: function(color)
        {
            var l = color[2];

            if (color[1] == 0)
            {
                l = Math.round(l * 255);
                return [l, l, l];
            }
            else
            {
                var hue2rgb = function(p, q, t)
                {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                }

                var s = color[1];
                var q = (l < 0.5 ? l * (1 + s) : l + s - l * s);
                var p = 2 * l - q;
                var r = hue2rgb(p, q, color[0] + 1 / 3);
                var g = hue2rgb(p, q, color[0]);
                var b = hue2rgb(p, q, color[0] - 1 / 3);
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }
        },

        toRGB: function(color)
        {
            return "rgb(" + this._clamp(color[0]) + "," + this._clamp(color[1]) + "," + this._clamp(color[2]) + ")";
        },

        toHex: function(color)
        {
            var parts = [];
            for (var i = 0; i < 3; i++)
            {
                parts.push(this._clamp(color[i]).toString(16).lpad("0", 2));
            }
            return "#" + parts.join("");
        },

        _clamp: function(num)
        {
            if (num < 0)
            {
                return 0;
            }
            else if (num > 255)
            {
                return 255;
            }
            else
            {
                return num;
            }
        },

        _cache: {
            "black": [0, 0, 0],
            "navy": [0, 0, 128],
            "darkblue": [0, 0, 139],
            "mediumblue": [0, 0, 205],
            "blue": [0, 0, 255],
            "darkgreen": [0, 100, 0],
            "green": [0, 128, 0],
            "teal": [0, 128, 128],
            "darkcyan": [0, 139, 139],
            "deepskyblue": [0, 191, 255],
            "darkturquoise": [0, 206, 209],
            "mediumspringgreen": [0, 250, 154],
            "lime": [0, 255, 0],
            "springgreen": [0, 255, 127],
            "aqua": [0, 255, 255],
            "cyan": [0, 255, 255],
            "midnightblue": [25, 25, 112],
            "dodgerblue": [30, 144, 255],
            "forestgreen": [34, 139, 34],
            "seagreen": [46, 139, 87],
            "darkslategray": [47, 79, 79],
            "darkslategrey": [47, 79, 79],
            "limegreen": [50, 205, 50],
            "mediumseagreen": [60, 179, 113],
            "turquoise": [64, 224, 208],
            "royalblue": [65, 105, 225],
            "steelblue": [70, 130, 180],
            "darkslateblue": [72, 61, 139],
            "mediumturquoise": [72, 209, 204],
            "indigo": [75, 0, 130],
            "darkolivegreen": [85, 107, 47],
            "cadetblue": [95, 158, 160],
            "cornflowerblue": [100, 149, 237],
            "mediumaquamarine": [102, 205, 170],
            "dimgray": [105, 105, 105],
            "dimgrey": [105, 105, 105],
            "slateblue": [106, 90, 205],
            "olivedrab": [107, 142, 35],
            "slategray": [112, 128, 144],
            "slategrey": [112, 128, 144],
            "lightslategray": [119, 136, 153],
            "lightslategrey": [119, 136, 153],
            "mediumslateblue": [123, 104, 238],
            "lawngreen": [124, 252, 0],
            "chartreuse": [127, 255, 0],
            "aquamarine": [127, 255, 212],
            "maroon": [128, 0, 0],
            "purple": [128, 0, 128],
            "olive": [128, 128, 0],
            "gray": [128, 128, 128],
            "grey": [128, 128, 128],
            "skyblue": [135, 206, 235],
            "lightskyblue": [135, 206, 250],
            "blueviolet": [138, 43, 226],
            "darkred": [139, 0, 0],
            "darkmagenta": [139, 0, 139],
            "saddlebrown": [139, 69, 19],
            "darkseagreen": [143, 188, 143],
            "lightgreen": [144, 238, 144],
            "mediumpurple": [147, 112, 216],
            "darkviolet": [148, 0, 211],
            "palegreen": [152, 251, 152],
            "darkorchid": [153, 50, 204],
            "yellowgreen": [154, 205, 50],
            "sienna": [160, 82, 45],
            "brown": [165, 42, 42],
            "darkgray": [169, 169, 169],
            "darkgrey": [169, 169, 169],
            "lightblue": [173, 216, 230],
            "greenyellow": [173, 255, 47],
            "paleturquoise": [175, 238, 238],
            "lightsteelblue": [176, 196, 222],
            "powderblue": [176, 224, 230],
            "firebrick": [178, 34, 34],
            "darkgoldenrod": [184, 134, 11],
            "mediumorchid": [186, 85, 211],
            "rosybrown": [188, 143, 143],
            "darkkhaki": [189, 183, 107],
            "silver": [192, 192, 192],
            "mediumvioletred": [199, 21, 133],
            "indianred": [205, 92, 92],
            "peru": [205, 133, 63],
            "chocolate": [210, 105, 30],
            "tan": [210, 180, 140],
            "lightgray": [211, 211, 211],
            "lightgrey": [211, 211, 211],
            "palevioletred": [216, 112, 147],
            "thistle": [216, 191, 216],
            "orchid": [218, 112, 214],
            "goldenrod": [218, 165, 32],
            "crimson": [220, 20, 60],
            "gainsboro": [220, 220, 220],
            "plum": [221, 160, 221],
            "burlywood": [222, 184, 135],
            "lightcyan": [224, 255, 255],
            "lavender": [230, 230, 250],
            "darksalmon": [233, 150, 122],
            "violet": [238, 130, 238],
            "palegoldenrod": [238, 232, 170],
            "lightcoral": [240, 128, 128],
            "khaki": [240, 230, 140],
            "aliceblue": [240, 248, 255],
            "honeydew": [240, 255, 240],
            "azure": [240, 255, 255],
            "sandybrown": [244, 164, 96],
            "wheat": [245, 222, 179],
            "beige": [245, 245, 220],
            "whitesmoke": [245, 245, 245],
            "mintcream": [245, 255, 250],
            "ghostwhite": [248, 248, 255],
            "salmon": [250, 128, 114],
            "antiquewhite": [250, 235, 215],
            "linen": [250, 240, 230],
            "lightgoldenrodyellow": [250, 250, 210],
            "oldlace": [253, 245, 230],
            "red": [255, 0, 0],
            "fuchsia": [255, 0, 255],
            "magenta": [255, 0, 255],
            "deeppink": [255, 20, 147],
            "orangered": [255, 69, 0],
            "tomato": [255, 99, 71],
            "hotpink": [255, 105, 180],
            "coral": [255, 127, 80],
            "darkorange": [255, 140, 0],
            "lightsalmon": [255, 160, 122],
            "orange": [255, 165, 0],
            "lightpink": [255, 182, 193],
            "pink": [255, 192, 203],
            "gold": [255, 215, 0],
            "peachpuff": [255, 218, 185],
            "navajowhite": [255, 222, 173],
            "moccasin": [255, 228, 181],
            "bisque": [255, 228, 196],
            "mistyrose": [255, 228, 225],
            "blanchedalmond": [255, 235, 205],
            "papayawhip": [255, 239, 213],
            "lavenderblush": [255, 240, 245],
            "seashell": [255, 245, 238],
            "cornsilk": [255, 248, 220],
            "lemonchiffon": [255, 250, 205],
            "floralwhite": [255, 250, 240],
            "snow": [255, 250, 250],
            "yellow": [255, 255, 0],
            "lightyellow": [255, 255, 224],
            "ivory": [255, 255, 240],
            "white": [255, 255, 255]
        }
    };
    /**
     * @class Lighting computation, based on a traditional FOV for multiple light sources and multiple passes.
     * @param {function} reflectivityCallback Callback to retrieve cell reflectivity (0..1)
     * @param {object} [options]
     * @param {int} [options.passes=1] Number of passes. 1 equals to simple FOV of all light sources, >1 means a *highly simplified* radiosity-like algorithm.
     * @param {int} [options.emissionThreshold=100] Cells with emissivity > threshold will be treated as light source in the next pass.
     * @param {int} [options.range=10] Max light range
     */
    ROT.Lighting = function(reflectivityCallback, options)
    {
        this._reflectivityCallback = reflectivityCallback;
        this._options = {
            passes: 1,
            emissionThreshold: 100,
            range: 10
        };
        this._fov = null;

        this._lights = {};
        this._reflectivityCache = {};
        this._fovCache = {};

        this.setOptions(options);
    };

    /**
     * Adjust options at runtime
     * @see ROT.Lighting
     * @param {object} [options]
     */
    ROT.Lighting.prototype.setOptions = function(options)
    {
        for (var p in options)
        {
            this._options[p] = options[p];
        }
        if (options && options.range)
        {
            this.reset();
        }
        return this;
    };

    /**
     * Set the used Field-Of-View algo
     * @param {ROT.FOV} fov
     */
    ROT.Lighting.prototype.setFOV = function(fov)
    {
        this._fov = fov;
        this._fovCache = {};
        return this;
    };

    /**
     * Set (or remove) a light source
     * @param {int} x
     * @param {int} y
     * @param {null || string || number[3]} color
     */
    ROT.Lighting.prototype.setLight = function(x, y, color)
    {
        var key = x + "," + y;

        if (color)
        {
            this._lights[key] = (typeof(color) == "string" ? ROT.Color.fromString(color) : color);
        }
        else
        {
            delete this._lights[key];
        }
        return this;
    };

    /**
     * Remove all light sources
     */
    ROT.Lighting.prototype.clearLights = function()
    {
        this._lights = {};
    };

    /**
     * Reset the pre-computed topology values. Call whenever the underlying map changes its light-passability.
     */
    ROT.Lighting.prototype.reset = function()
    {
        this._reflectivityCache = {};
        this._fovCache = {};

        return this;
    };

    /**
     * Compute the lighting
     * @param {function} lightingCallback Will be called with (x, y, color) for every lit cell
     */
    ROT.Lighting.prototype.compute = function(lightingCallback)
    {
        var doneCells = {};
        var emittingCells = {};
        var litCells = {};

        for (var key in this._lights)
        { /* prepare emitters for first pass */
            var light = this._lights[key];
            emittingCells[key] = [0, 0, 0];
            ROT.Color.add_(emittingCells[key], light);
        }

        for (var i = 0; i < this._options.passes; i++)
        { /* main loop */
            this._emitLight(emittingCells, litCells, doneCells);
            if (i + 1 == this._options.passes)
            {
                continue;
            } /* not for the last pass */
            emittingCells = this._computeEmitters(litCells, doneCells);
        }

        for (var litKey in litCells)
        { /* let the user know what and how is lit */
            var parts = litKey.split(",");
            var x = parseInt(parts[0]);
            var y = parseInt(parts[1]);
            lightingCallback(x, y, litCells[litKey]);
        }

        return this;
    };

    /**
     * Compute one iteration from all emitting cells
     * @param {object} emittingCells These emit light
     * @param {object} litCells Add projected light to these
     * @param {object} doneCells These already emitted, forbid them from further calculations
     */
    ROT.Lighting.prototype._emitLight = function(emittingCells, litCells, doneCells)
    {
        for (var key in emittingCells)
        {
            var parts = key.split(",");
            var x = parseInt(parts[0]);
            var y = parseInt(parts[1]);
            this._emitLightFromCell(x, y, emittingCells[key], litCells);
            doneCells[key] = 1;
        }
        return this;
    };

    /**
     * Prepare a list of emitters for next pass
     * @param {object} litCells
     * @param {object} doneCells
     * @returns {object}
     */
    ROT.Lighting.prototype._computeEmitters = function(litCells, doneCells)
    {
        var result = {};

        for (var key in litCells)
        {
            if (key in doneCells)
            {
                continue;
            } /* already emitted */

            var color = litCells[key];

            if (key in this._reflectivityCache)
            {
                var reflectivity = this._reflectivityCache[key];
            }
            else
            {
                var parts = key.split(",");
                var x = parseInt(parts[0]);
                var y = parseInt(parts[1]);
                var reflectivity = this._reflectivityCallback(x, y);
                this._reflectivityCache[key] = reflectivity;
            }

            if (reflectivity == 0)
            {
                continue;
            } /* will not reflect at all */

            /* compute emission color */
            var emission = [];
            var intensity = 0;
            for (var i = 0; i < 3; i++)
            {
                var part = Math.round(color[i] * reflectivity);
                emission[i] = part;
                intensity += part;
            }
            if (intensity > this._options.emissionThreshold)
            {
                result[key] = emission;
            }
        }

        return result;
    };

    /**
     * Compute one iteration from one cell
     * @param {int} x
     * @param {int} y
     * @param {number[]} color
     * @param {object} litCells Cell data to by updated
     */
    ROT.Lighting.prototype._emitLightFromCell = function(x, y, color, litCells)
    {
        var key = x + "," + y;
        if (key in this._fovCache)
        {
            var fov = this._fovCache[key];
        }
        else
        {
            var fov = this._updateFOV(x, y);
        }

        for (var fovKey in fov)
        {
            var formFactor = fov[fovKey];

            if (fovKey in litCells)
            { /* already lit */
                var result = litCells[fovKey];
            }
            else
            { /* newly lit */
                var result = [0, 0, 0];
                litCells[fovKey] = result;
            }

            for (var i = 0; i < 3; i++)
            {
                result[i] += Math.round(color[i] * formFactor);
            } /* add light color */
        }

        return this;
    };

    /**
     * Compute FOV ("form factor") for a potential light source at [x,y]
     * @param {int} x
     * @param {int} y
     * @returns {object}
     */
    ROT.Lighting.prototype._updateFOV = function(x, y)
    {
        var key1 = x + "," + y;
        var cache = {};
        this._fovCache[key1] = cache;
        var range = this._options.range;
        var cb = function(x, y, r, vis)
        {
            var key2 = x + "," + y;
            var formFactor = vis * (1 - r / range);
            if (formFactor == 0)
            {
                return;
            }
            cache[key2] = formFactor;
        };
        this._fov.compute(x, y, range, cb.bind(this));

        return cache;
    };
    /**
     * @class Abstract pathfinder
     * @param {int} toX Target X coord
     * @param {int} toY Target Y coord
     * @param {function} passableCallback Callback to determine map passability
     * @param {object} [options]
     * @param {int} [options.topology=8]
     */
    ROT.Path = function(toX, toY, passableCallback, options)
    {
        this._toX = toX;
        this._toY = toY;
        this._fromX = null;
        this._fromY = null;
        this._passableCallback = passableCallback;
        this._options = {
            topology: 8
        };
        for (var p in options)
        {
            this._options[p] = options[p];
        }

        this._dirs = ROT.DIRS[this._options.topology];
        if (this._options.topology == 8)
        { /* reorder dirs for more aesthetic result (vertical/horizontal first) */
            this._dirs = [
            this._dirs[0],
            this._dirs[2],
            this._dirs[4],
            this._dirs[6],
            this._dirs[1],
            this._dirs[3],
            this._dirs[5],
            this._dirs[7]
        ]
        }
    };

    /**
     * Compute a path from a given point
     * @param {int} fromX
     * @param {int} fromY
     * @param {function} callback Will be called for every path item with arguments "x" and "y"
     */
    ROT.Path.prototype.compute = function(fromX, fromY, callback)
    {};

    ROT.Path.prototype._getNeighbors = function(cx, cy)
    {
        var result = [];
        for (var i = 0; i < this._dirs.length; i++)
        {
            var dir = this._dirs[i];
            var x = cx + dir[0];
            var y = cy + dir[1];

            if (!this._passableCallback(x, y))
            {
                continue;
            }
            result.push([x, y]);
        }

        return result;
    };
    /**
     * @class Simplified Dijkstra's algorithm: all edges have a value of 1
     * @augments ROT.Path
     * @see ROT.Path
     */
    ROT.Path.Dijkstra = function(toX, toY, passableCallback, options)
    {
        ROT.Path.call(this, toX, toY, passableCallback, options);

        this._computed = {};
        this._todo = [];
        this._add(toX, toY, null);
    };
    ROT.Path.Dijkstra.extend(ROT.Path);

    /**
     * Compute a path from a given point
     * @see ROT.Path#compute
     */
    ROT.Path.Dijkstra.prototype.compute = function(fromX, fromY, callback)
    {
        var key = fromX + "," + fromY;
        if (!(key in this._computed))
        {
            this._compute(fromX, fromY);
        }
        if (!(key in this._computed))
        {
            return;
        }

        var item = this._computed[key];
        while (item)
        {
            callback(item.x, item.y);
            item = item.prev;
        }
    };

    /**
     * Compute a non-cached value
     */
    ROT.Path.Dijkstra.prototype._compute = function(fromX, fromY)
    {
        while (this._todo.length)
        {
            var item = this._todo.shift();
            if (item.x == fromX && item.y == fromY)
            {
                return;
            }

            var neighbors = this._getNeighbors(item.x, item.y);

            for (var i = 0; i < neighbors.length; i++)
            {
                var neighbor = neighbors[i];
                var x = neighbor[0];
                var y = neighbor[1];
                var id = x + "," + y;
                if (id in this._computed)
                {
                    continue;
                } /* already done */
                this._add(x, y, item);
            }
        }
    };

    ROT.Path.Dijkstra.prototype._add = function(x, y, prev)
    {
        var obj = {
            x: x,
            y: y,
            prev: prev
        };
        this._computed[x + "," + y] = obj;
        this._todo.push(obj);
    };
    /**
     * @class Simplified A* algorithm: all edges have a value of 1
     * @augments ROT.Path
     * @see ROT.Path
     */
    ROT.Path.AStar = function(toX, toY, passableCallback, options)
    {
        ROT.Path.call(this, toX, toY, passableCallback, options);

        this._todo = [];
        this._done = {};
        this._fromX = null;
        this._fromY = null;
    };
    ROT.Path.AStar.extend(ROT.Path);

    /**
     * Compute a path from a given point
     * @see ROT.Path#compute
     */
    ROT.Path.AStar.prototype.compute = function(fromX, fromY, callback)
    {
        this._todo = [];
        this._done = {};
        this._fromX = fromX;
        this._fromY = fromY;
        this._add(this._toX, this._toY, null);

        while (this._todo.length)
        {
            var item = this._todo.shift();
            var id = item.x + "," + item.y;
            if (id in this._done)
            {
                continue;
            }
            this._done[id] = item;
            if (item.x == fromX && item.y == fromY)
            {
                break;
            }

            var neighbors = this._getNeighbors(item.x, item.y);

            for (var i = 0; i < neighbors.length; i++)
            {
                var neighbor = neighbors[i];
                var x = neighbor[0];
                var y = neighbor[1];
                var id = x + "," + y;
                if (id in this._done)
                {
                    continue;
                }
                this._add(x, y, item);
            }
        }

        var item = this._done[fromX + "," + fromY];
        if (!item)
        {
            return;
        }

        while (item)
        {
            callback(item.x, item.y);
            item = item.prev;
        }
    };

    ROT.Path.AStar.prototype._add = function(x, y, prev)
    {
        var h = this._distance(x, y);
        var obj = {
            x: x,
            y: y,
            prev: prev,
            g: (prev ? prev.g + 1 : 0),
            h: h
        };

        /* insert into priority queue */

        var f = obj.g + obj.h;
        for (var i = 0; i < this._todo.length; i++)
        {
            var item = this._todo[i];
            var itemF = item.g + item.h;
            if (f < itemF || (f == itemF && h < item.h))
            {
                this._todo.splice(i, 0, obj);
                return;
            }
        }

        this._todo.push(obj);
    };

    ROT.Path.AStar.prototype._distance = function(x, y)
    {
        switch (this._options.topology)
        {
            case 4:
                return (Math.abs(x - this._fromX) + Math.abs(y - this._fromY));
                break;

            case 6:
                var dx = Math.abs(x - this._fromX);
                var dy = Math.abs(y - this._fromY);
                return dy + Math.max(0, (dx - dy) / 2);
                break;

            case 8:
                return Math.max(Math.abs(x - this._fromX), Math.abs(y - this._fromY));
                break;
        }

        throw new Error("Illegal topology");
    };
    return ROT;
}));
@@BYTES
LyoKCVRoaXMgaXMgcm90LmpzLCB0aGUgUk9ndWVsaWtlIFRvb2xraXQgaW4gSmF2YVNjcmlwdC4KCVZlcnNpb24gMC43fmRldiwgZ2VuZXJhdGVkIG9uIFRodSBTZXAgMTMgMTI6NTE6MTkgQ0VTVCAyMDE4LgoqLwooZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkKewogICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkKICAgIHsKICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuCiAgICAgICAgZGVmaW5lKFtdLCBmYWN0b3J5KTsKICAgIH0KICAgIGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JykKICAgIHsKICAgICAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXQKICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cywKICAgICAgICAvLyBsaWtlIE5vZGUuCiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7CiAgICB9CiAgICBlbHNlCiAgICB7CiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdykKICAgICAgICByb290LlJPVCA9IGZhY3RvcnkoKTsKICAgIH0KfSh0aGlzLCBmdW5jdGlvbigpCnsKICAgIC8qKgogICAgICogQG5hbWVzcGFjZSBUb3AtbGV2ZWwgUk9UIG5hbWVzcGFjZQogICAgICovCiAgICB2YXIgUk9UID0gewogICAgICAgIC8qKgogICAgICAgICAqIEByZXR1cm5zIHtib29sfSBJcyByb3QuanMgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlcj8KICAgICAgICAgKi8KICAgICAgICBpc1N1cHBvcnRlZDogZnVuY3Rpb24oKQogICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuICEhKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpLmdldENvbnRleHQgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpOwogICAgICAgIH0sCgogICAgICAgIC8qKiBEZWZhdWx0IHdpdGggZm9yIGRpc3BsYXkgYW5kIG1hcCBnZW5lcmF0b3JzICovCiAgICAgICAgREVGQVVMVF9XSURUSDogODAsCiAgICAgICAgLyoqIERlZmF1bHQgaGVpZ2h0IGZvciBkaXNwbGF5IGFuZCBtYXAgZ2VuZXJhdG9ycyAqLwogICAgICAgIERFRkFVTFRfSEVJR0hUOiAyNSwKCiAgICAgICAgLyoqIERpcmVjdGlvbmFsIGNvbnN0YW50cy4gT3JkZXJpbmcgaXMgaW1wb3J0YW50ISAqLwogICAgICAgIERJUlM6IHsKICAgICAgICAgICAgIjQiOiBbCiAgICAgICAgICAgIFswLCAtMV0sCiAgICAgICAgICAgIFsxLCAwXSwKICAgICAgICAgICAgWzAsIDFdLAogICAgICAgICAgICBbLTEsIDBdCiAgICAgICAgXSwKICAgICAgICAgICAgIjgiOiBbCiAgICAgICAgICAgIFswLCAtMV0sCiAgICAgICAgICAgIFsxLCAtMV0sCiAgICAgICAgICAgIFsxLCAwXSwKICAgICAgICAgICAgWzEsIDFdLAogICAgICAgICAgICBbMCwgMV0sCiAgICAgICAgICAgIFstMSwgMV0sCiAgICAgICAgICAgIFstMSwgMF0sCiAgICAgICAgICAgIFstMSwgLTFdCiAgICAgICAgXSwKICAgICAgICAgICAgIjYiOiBbCiAgICAgICAgICAgIFstMSwgLTFdLAogICAgICAgICAgICBbMSwgLTFdLAogICAgICAgICAgICBbMiwgMF0sCiAgICAgICAgICAgIFsxLCAxXSwKICAgICAgICAgICAgWy0xLCAxXSwKICAgICAgICAgICAgWy0yLCAwXQogICAgICAgIF0KICAgICAgICB9LAoKICAgICAgICAvKiogQ2FuY2VsIGtleS4gKi8KICAgICAgICBWS19DQU5DRUw6IDMsCiAgICAgICAgLyoqIEhlbHAga2V5LiAqLwogICAgICAgIFZLX0hFTFA6IDYsCiAgICAgICAgLyoqIEJhY2tzcGFjZSBrZXkuICovCiAgICAgICAgVktfQkFDS19TUEFDRTogOCwKICAgICAgICAvKiogVGFiIGtleS4gKi8KICAgICAgICBWS19UQUI6IDksCiAgICAgICAgLyoqIDUga2V5IG9uIE51bXBhZCB3aGVuIE51bUxvY2sgaXMgdW5sb2NrZWQuIE9yIG9uIE1hYywgY2xlYXIga2V5IHdoaWNoIGlzIHBvc2l0aW9uZWQgYXQgTnVtTG9jayBrZXkuICovCiAgICAgICAgVktfQ0xFQVI6IDEyLAogICAgICAgIC8qKiBSZXR1cm4vZW50ZXIga2V5IG9uIHRoZSBtYWluIGtleWJvYXJkLiAqLwogICAgICAgIFZLX1JFVFVSTjogMTMsCiAgICAgICAgLyoqIFJlc2VydmVkLCBidXQgbm90IHVzZWQuICovCiAgICAgICAgVktfRU5URVI6IDE0LAogICAgICAgIC8qKiBTaGlmdCBrZXkuICovCiAgICAgICAgVktfU0hJRlQ6IDE2LAogICAgICAgIC8qKiBDb250cm9sIGtleS4gKi8KICAgICAgICBWS19DT05UUk9MOiAxNywKICAgICAgICAvKiogQWx0IChPcHRpb24gb24gTWFjKSBrZXkuICovCiAgICAgICAgVktfQUxUOiAxOCwKICAgICAgICAvKiogUGF1c2Uga2V5LiAqLwogICAgICAgIFZLX1BBVVNFOiAxOSwKICAgICAgICAvKiogQ2FwcyBsb2NrLiAqLwogICAgICAgIFZLX0NBUFNfTE9DSzogMjAsCiAgICAgICAgLyoqIEVzY2FwZSBrZXkuICovCiAgICAgICAgVktfRVNDQVBFOiAyNywKICAgICAgICAvKiogU3BhY2UgYmFyLiAqLwogICAgICAgIFZLX1NQQUNFOiAzMiwKICAgICAgICAvKiogUGFnZSBVcCBrZXkuICovCiAgICAgICAgVktfUEFHRV9VUDogMzMsCiAgICAgICAgLyoqIFBhZ2UgRG93biBrZXkuICovCiAgICAgICAgVktfUEFHRV9ET1dOOiAzNCwKICAgICAgICAvKiogRW5kIGtleS4gKi8KICAgICAgICBWS19FTkQ6IDM1LAogICAgICAgIC8qKiBIb21lIGtleS4gKi8KICAgICAgICBWS19IT01FOiAzNiwKICAgICAgICAvKiogTGVmdCBhcnJvdy4gKi8KICAgICAgICBWS19MRUZUOiAzNywKICAgICAgICAvKiogVXAgYXJyb3cuICovCiAgICAgICAgVktfVVA6IDM4LAogICAgICAgIC8qKiBSaWdodCBhcnJvdy4gKi8KICAgICAgICBWS19SSUdIVDogMzksCiAgICAgICAgLyoqIERvd24gYXJyb3cuICovCiAgICAgICAgVktfRE9XTjogNDAsCiAgICAgICAgLyoqIFByaW50IFNjcmVlbiBrZXkuICovCiAgICAgICAgVktfUFJJTlRTQ1JFRU46IDQ0LAogICAgICAgIC8qKiBJbnMoZXJ0KSBrZXkuICovCiAgICAgICAgVktfSU5TRVJUOiA0NSwKICAgICAgICAvKiogRGVsKGV0ZSkga2V5LiAqLwogICAgICAgIFZLX0RFTEVURTogNDYsCiAgICAgICAgLyoqKi8KICAgICAgICBWS18wOiA0OCwKICAgICAgICAvKioqLwogICAgICAgIFZLXzE6IDQ5LAogICAgICAgIC8qKiovCiAgICAgICAgVktfMjogNTAsCiAgICAgICAgLyoqKi8KICAgICAgICBWS18zOiA1MSwKICAgICAgICAvKioqLwogICAgICAgIFZLXzQ6IDUyLAogICAgICAgIC8qKiovCiAgICAgICAgVktfNTogNTMsCiAgICAgICAgLyoqKi8KICAgICAgICBWS182OiA1NCwKICAgICAgICAvKioqLwogICAgICAgIFZLXzc6IDU1LAogICAgICAgIC8qKiovCiAgICAgICAgVktfODogNTYsCiAgICAgICAgLyoqKi8KICAgICAgICBWS185OiA1NywKICAgICAgICAvKiogQ29sb24gKDopIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqLwogICAgICAgIFZLX0NPTE9OOiA1OCwKICAgICAgICAvKiogU2VtaWNvbG9uICg7KSBrZXkuICovCiAgICAgICAgVktfU0VNSUNPTE9OOiA1OSwKICAgICAgICAvKiogTGVzcy10aGFuICg8KSBrZXkuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi8KICAgICAgICBWS19MRVNTX1RIQU46IDYwLAogICAgICAgIC8qKiBFcXVhbHMgKD0pIGtleS4gKi8KICAgICAgICBWS19FUVVBTFM6IDYxLAogICAgICAgIC8qKiBHcmVhdGVyLXRoYW4gKD4pIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqLwogICAgICAgIFZLX0dSRUFURVJfVEhBTjogNjIsCiAgICAgICAgLyoqIFF1ZXN0aW9uIG1hcmsgKD8pIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqLwogICAgICAgIFZLX1FVRVNUSU9OX01BUks6IDYzLAogICAgICAgIC8qKiBBdG1hcmsgKEApIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqLwogICAgICAgIFZLX0FUOiA2NCwKICAgICAgICAvKioqLwogICAgICAgIFZLX0E6IDY1LAogICAgICAgIC8qKiovCiAgICAgICAgVktfQjogNjYsCiAgICAgICAgLyoqKi8KICAgICAgICBWS19DOiA2NywKICAgICAgICAvKioqLwogICAgICAgIFZLX0Q6IDY4LAogICAgICAgIC8qKiovCiAgICAgICAgVktfRTogNjksCiAgICAgICAgLyoqKi8KICAgICAgICBWS19GOiA3MCwKICAgICAgICAvKioqLwogICAgICAgIFZLX0c6IDcxLAogICAgICAgIC8qKiovCiAgICAgICAgVktfSDogNzIsCiAgICAgICAgLyoqKi8KICAgICAgICBWS19JOiA3MywKICAgICAgICAvKioqLwogICAgICAgIFZLX0o6IDc0LAogICAgICAgIC8qKiovCiAgICAgICAgVktfSzogNzUsCiAgICAgICAgLyoqKi8KICAgICAgICBWS19MOiA3NiwKICAgICAgICAvKioqLwogICAgICAgIFZLX006IDc3LAogICAgICAgIC8qKiovCiAgICAgICAgVktfTjogNzgsCiAgICAgICAgLyoqKi8KICAgICAgICBWS19POiA3OSwKICAgICAgICAvKioqLwogICAgICAgIFZLX1A6IDgwLAogICAgICAgIC8qKiovCiAgICAgICAgVktfUTogODEsCiAgICAgICAgLyoqKi8KICAgICAgICBWS19SOiA4MiwKICAgICAgICAvKioqLwogICAgICAgIFZLX1M6IDgzLAogICAgICAgIC8qKiovCiAgICAgICAgVktfVDogODQsCiAgICAgICAgLyoqKi8KICAgICAgICBWS19VOiA4NSwKICAgICAgICAvKioqLwogICAgICAgIFZLX1Y6IDg2LAogICAgICAgIC8qKiovCiAgICAgICAgVktfVzogODcsCiAgICAgICAgLyoqKi8KICAgICAgICBWS19YOiA4OCwKICAgICAgICAvKioqLwogICAgICAgIFZLX1k6IDg5LAogICAgICAgIC8qKiovCiAgICAgICAgVktfWjogOTAsCiAgICAgICAgLyoqKi8KICAgICAgICBWS19DT05URVhUX01FTlU6IDkzLAogICAgICAgIC8qKiAwIG9uIHRoZSBudW1lcmljIGtleXBhZC4gKi8KICAgICAgICBWS19OVU1QQUQwOiA5NiwKICAgICAgICAvKiogMSBvbiB0aGUgbnVtZXJpYyBrZXlwYWQuICovCiAgICAgICAgVktfTlVNUEFEMTogOTcsCiAgICAgICAgLyoqIDIgb24gdGhlIG51bWVyaWMga2V5cGFkLiAqLwogICAgICAgIFZLX05VTVBBRDI6IDk4LAogICAgICAgIC8qKiAzIG9uIHRoZSBudW1lcmljIGtleXBhZC4gKi8KICAgICAgICBWS19OVU1QQUQzOiA5OSwKICAgICAgICAvKiogNCBvbiB0aGUgbnVtZXJpYyBrZXlwYWQuICovCiAgICAgICAgVktfTlVNUEFENDogMTAwLAogICAgICAgIC8qKiA1IG9uIHRoZSBudW1lcmljIGtleXBhZC4gKi8KICAgICAgICBWS19OVU1QQUQ1OiAxMDEsCiAgICAgICAgLyoqIDYgb24gdGhlIG51bWVyaWMga2V5cGFkLiAqLwogICAgICAgIFZLX05VTVBBRDY6IDEwMiwKICAgICAgICAvKiogNyBvbiB0aGUgbnVtZXJpYyBrZXlwYWQuICovCiAgICAgICAgVktfTlVNUEFENzogMTAzLAogICAgICAgIC8qKiA4IG9uIHRoZSBudW1lcmljIGtleXBhZC4gKi8KICAgICAgICBWS19OVU1QQUQ4OiAxMDQsCiAgICAgICAgLyoqIDkgb24gdGhlIG51bWVyaWMga2V5cGFkLiAqLwogICAgICAgIFZLX05VTVBBRDk6IDEwNSwKICAgICAgICAvKiogKiBvbiB0aGUgbnVtZXJpYyBrZXlwYWQuICovCiAgICAgICAgVktfTVVMVElQTFk6IDEwNiwKICAgICAgICAvKiogKyBvbiB0aGUgbnVtZXJpYyBrZXlwYWQuICovCiAgICAgICAgVktfQUREOiAxMDcsCiAgICAgICAgLyoqKi8KICAgICAgICBWS19TRVBBUkFUT1I6IDEwOCwKICAgICAgICAvKiogLSBvbiB0aGUgbnVtZXJpYyBrZXlwYWQuICovCiAgICAgICAgVktfU1VCVFJBQ1Q6IDEwOSwKICAgICAgICAvKiogRGVjaW1hbCBwb2ludCBvbiB0aGUgbnVtZXJpYyBrZXlwYWQuICovCiAgICAgICAgVktfREVDSU1BTDogMTEwLAogICAgICAgIC8qKiAvIG9uIHRoZSBudW1lcmljIGtleXBhZC4gKi8KICAgICAgICBWS19ESVZJREU6IDExMSwKICAgICAgICAvKiogRjEga2V5LiAqLwogICAgICAgIFZLX0YxOiAxMTIsCiAgICAgICAgLyoqIEYyIGtleS4gKi8KICAgICAgICBWS19GMjogMTEzLAogICAgICAgIC8qKiBGMyBrZXkuICovCiAgICAgICAgVktfRjM6IDExNCwKICAgICAgICAvKiogRjQga2V5LiAqLwogICAgICAgIFZLX0Y0OiAxMTUsCiAgICAgICAgLyoqIEY1IGtleS4gKi8KICAgICAgICBWS19GNTogMTE2LAogICAgICAgIC8qKiBGNiBrZXkuICovCiAgICAgICAgVktfRjY6IDExNywKICAgICAgICAvKiogRjcga2V5LiAqLwogICAgICAgIFZLX0Y3OiAxMTgsCiAgICAgICAgLyoqIEY4IGtleS4gKi8KICAgICAgICBWS19GODogMTE5LAogICAgICAgIC8qKiBGOSBrZXkuICovCiAgICAgICAgVktfRjk6IDEyMCwKICAgICAgICAvKiogRjEwIGtleS4gKi8KICAgICAgICBWS19GMTA6IDEyMSwKICAgICAgICAvKiogRjExIGtleS4gKi8KICAgICAgICBWS19GMTE6IDEyMiwKICAgICAgICAvKiogRjEyIGtleS4gKi8KICAgICAgICBWS19GMTI6IDEyMywKICAgICAgICAvKiogRjEzIGtleS4gKi8KICAgICAgICBWS19GMTM6IDEyNCwKICAgICAgICAvKiogRjE0IGtleS4gKi8KICAgICAgICBWS19GMTQ6IDEyNSwKICAgICAgICAvKiogRjE1IGtleS4gKi8KICAgICAgICBWS19GMTU6IDEyNiwKICAgICAgICAvKiogRjE2IGtleS4gKi8KICAgICAgICBWS19GMTY6IDEyNywKICAgICAgICAvKiogRjE3IGtleS4gKi8KICAgICAgICBWS19GMTc6IDEyOCwKICAgICAgICAvKiogRjE4IGtleS4gKi8KICAgICAgICBWS19GMTg6IDEyOSwKICAgICAgICAvKiogRjE5IGtleS4gKi8KICAgICAgICBWS19GMTk6IDEzMCwKICAgICAgICAvKiogRjIwIGtleS4gKi8KICAgICAgICBWS19GMjA6IDEzMSwKICAgICAgICAvKiogRjIxIGtleS4gKi8KICAgICAgICBWS19GMjE6IDEzMiwKICAgICAgICAvKiogRjIyIGtleS4gKi8KICAgICAgICBWS19GMjI6IDEzMywKICAgICAgICAvKiogRjIzIGtleS4gKi8KICAgICAgICBWS19GMjM6IDEzNCwKICAgICAgICAvKiogRjI0IGtleS4gKi8KICAgICAgICBWS19GMjQ6IDEzNSwKICAgICAgICAvKiogTnVtIExvY2sga2V5LiAqLwogICAgICAgIFZLX05VTV9MT0NLOiAxNDQsCiAgICAgICAgLyoqIFNjcm9sbCBMb2NrIGtleS4gKi8KICAgICAgICBWS19TQ1JPTExfTE9DSzogMTQ1LAogICAgICAgIC8qKiBDaXJjdW1mbGV4ICheKSBrZXkuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi8KICAgICAgICBWS19DSVJDVU1GTEVYOiAxNjAsCiAgICAgICAgLyoqIEV4Y2xhbWF0aW9uICghKSBrZXkuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi8KICAgICAgICBWS19FWENMQU1BVElPTjogMTYxLAogICAgICAgIC8qKiBEb3VibGUgcXVvdGUgKCkga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovCiAgICAgICAgVktfRE9VQkxFX1FVT1RFOiAxNjIsCiAgICAgICAgLyoqIEhhc2ggKCMpIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqLwogICAgICAgIFZLX0hBU0g6IDE2MywKICAgICAgICAvKiogRG9sbGFyIHNpZ24gKCQpIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqLwogICAgICAgIFZLX0RPTExBUjogMTY0LAogICAgICAgIC8qKiBQZXJjZW50ICglKSBrZXkuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi8KICAgICAgICBWS19QRVJDRU5UOiAxNjUsCiAgICAgICAgLyoqIEFtcGVyc2FuZCAoJikga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovCiAgICAgICAgVktfQU1QRVJTQU5EOiAxNjYsCiAgICAgICAgLyoqIFVuZGVyc2NvcmUgKF8pIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqLwogICAgICAgIFZLX1VOREVSU0NPUkU6IDE2NywKICAgICAgICAvKiogT3BlbiBwYXJlbnRoZXNpcyAoKCkga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovCiAgICAgICAgVktfT1BFTl9QQVJFTjogMTY4LAogICAgICAgIC8qKiBDbG9zZSBwYXJlbnRoZXNpcyAoKSkga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovCiAgICAgICAgVktfQ0xPU0VfUEFSRU46IDE2OSwKICAgICAgICAvKiBBc3RlcmlzayAoKikga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovCiAgICAgICAgVktfQVNURVJJU0s6IDE3MCwKICAgICAgICAvKiogUGx1cyAoKykga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovCiAgICAgICAgVktfUExVUzogMTcxLAogICAgICAgIC8qKiBQaXBlICh8KSBrZXkuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi8KICAgICAgICBWS19QSVBFOiAxNzIsCiAgICAgICAgLyoqIEh5cGhlbi1VUy9kb2NzL01pbnVzICgtKSBrZXkuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi8KICAgICAgICBWS19IWVBIRU5fTUlOVVM6IDE3MywKICAgICAgICAvKiogT3BlbiBjdXJseSBicmFja2V0ICh7KSBrZXkuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi8KICAgICAgICBWS19PUEVOX0NVUkxZX0JSQUNLRVQ6IDE3NCwKICAgICAgICAvKiogQ2xvc2UgY3VybHkgYnJhY2tldCAofSkga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovCiAgICAgICAgVktfQ0xPU0VfQ1VSTFlfQlJBQ0tFVDogMTc1LAogICAgICAgIC8qKiBUaWxkZSAofikga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovCiAgICAgICAgVktfVElMREU6IDE3NiwKICAgICAgICAvKiogQ29tbWEgKCwpIGtleS4gKi8KICAgICAgICBWS19DT01NQTogMTg4LAogICAgICAgIC8qKiBQZXJpb2QgKC4pIGtleS4gKi8KICAgICAgICBWS19QRVJJT0Q6IDE5MCwKICAgICAgICAvKiogU2xhc2ggKC8pIGtleS4gKi8KICAgICAgICBWS19TTEFTSDogMTkxLAogICAgICAgIC8qKiBCYWNrIHRpY2sgKGApIGtleS4gKi8KICAgICAgICBWS19CQUNLX1FVT1RFOiAxOTIsCiAgICAgICAgLyoqIE9wZW4gc3F1YXJlIGJyYWNrZXQgKFspIGtleS4gKi8KICAgICAgICBWS19PUEVOX0JSQUNLRVQ6IDIxOSwKICAgICAgICAvKiogQmFjayBzbGFzaCAoXCkga2V5LiAqLwogICAgICAgIFZLX0JBQ0tfU0xBU0g6IDIyMCwKICAgICAgICAvKiogQ2xvc2Ugc3F1YXJlIGJyYWNrZXQgKF0pIGtleS4gKi8KICAgICAgICBWS19DTE9TRV9CUkFDS0VUOiAyMjEsCiAgICAgICAgLyoqIFF1b3RlICgnJycpIGtleS4gKi8KICAgICAgICBWS19RVU9URTogMjIyLAogICAgICAgIC8qKiBNZXRhIGtleSBvbiBMaW51eCwgQ29tbWFuZCBrZXkgb24gTWFjLiAqLwogICAgICAgIFZLX01FVEE6IDIyNCwKICAgICAgICAvKiogQWx0R3Iga2V5IG9uIExpbnV4LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovCiAgICAgICAgVktfQUxUR1I6IDIyNSwKICAgICAgICAvKiogV2luZG93cyBsb2dvIGtleSBvbiBXaW5kb3dzLiBPciBTdXBlciBvciBIeXBlciBrZXkgb24gTGludXguIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi8KICAgICAgICBWS19XSU46IDkxLAogICAgICAgIC8qKiBMaW51eCBzdXBwb3J0IGZvciB0aGlzIGtleWNvZGUgd2FzIGFkZGVkIGluIEdlY2tvIDQuMC4gKi8KICAgICAgICBWS19LQU5BOiAyMSwKICAgICAgICAvKiogTGludXggc3VwcG9ydCBmb3IgdGhpcyBrZXljb2RlIHdhcyBhZGRlZCBpbiBHZWNrbyA0LjAuICovCiAgICAgICAgVktfSEFOR1VMOiAyMSwKICAgICAgICAvKiogPz8ga2V5IG9uIEphcGFuZXNlIE1hYyBrZXlib2FyZC4gUmVxdWlyZXMgR2Vja28gMTUuMCAqLwogICAgICAgIFZLX0VJU1U6IDIyLAogICAgICAgIC8qKiBMaW51eCBzdXBwb3J0IGZvciB0aGlzIGtleWNvZGUgd2FzIGFkZGVkIGluIEdlY2tvIDQuMC4gKi8KICAgICAgICBWS19KVU5KQTogMjMsCiAgICAgICAgLyoqIExpbnV4IHN1cHBvcnQgZm9yIHRoaXMga2V5Y29kZSB3YXMgYWRkZWQgaW4gR2Vja28gNC4wLiAqLwogICAgICAgIFZLX0ZJTkFMOiAyNCwKICAgICAgICAvKiogTGludXggc3VwcG9ydCBmb3IgdGhpcyBrZXljb2RlIHdhcyBhZGRlZCBpbiBHZWNrbyA0LjAuICovCiAgICAgICAgVktfSEFOSkE6IDI1LAogICAgICAgIC8qKiBMaW51eCBzdXBwb3J0IGZvciB0aGlzIGtleWNvZGUgd2FzIGFkZGVkIGluIEdlY2tvIDQuMC4gKi8KICAgICAgICBWS19LQU5KSTogMjUsCiAgICAgICAgLyoqIExpbnV4IHN1cHBvcnQgZm9yIHRoaXMga2V5Y29kZSB3YXMgYWRkZWQgaW4gR2Vja28gNC4wLiAqLwogICAgICAgIFZLX0NPTlZFUlQ6IDI4LAogICAgICAgIC8qKiBMaW51eCBzdXBwb3J0IGZvciB0aGlzIGtleWNvZGUgd2FzIGFkZGVkIGluIEdlY2tvIDQuMC4gKi8KICAgICAgICBWS19OT05DT05WRVJUOiAyOSwKICAgICAgICAvKiogTGludXggc3VwcG9ydCBmb3IgdGhpcyBrZXljb2RlIHdhcyBhZGRlZCBpbiBHZWNrbyA0LjAuICovCiAgICAgICAgVktfQUNDRVBUOiAzMCwKICAgICAgICAvKiogTGludXggc3VwcG9ydCBmb3IgdGhpcyBrZXljb2RlIHdhcyBhZGRlZCBpbiBHZWNrbyA0LjAuICovCiAgICAgICAgVktfTU9ERUNIQU5HRTogMzEsCiAgICAgICAgLyoqIExpbnV4IHN1cHBvcnQgZm9yIHRoaXMga2V5Y29kZSB3YXMgYWRkZWQgaW4gR2Vja28gNC4wLiAqLwogICAgICAgIFZLX1NFTEVDVDogNDEsCiAgICAgICAgLyoqIExpbnV4IHN1cHBvcnQgZm9yIHRoaXMga2V5Y29kZSB3YXMgYWRkZWQgaW4gR2Vja28gNC4wLiAqLwogICAgICAgIFZLX1BSSU5UOiA0MiwKICAgICAgICAvKiogTGludXggc3VwcG9ydCBmb3IgdGhpcyBrZXljb2RlIHdhcyBhZGRlZCBpbiBHZWNrbyA0LjAuICovCiAgICAgICAgVktfRVhFQ1VURTogNDMsCiAgICAgICAgLyoqIExpbnV4IHN1cHBvcnQgZm9yIHRoaXMga2V5Y29kZSB3YXMgYWRkZWQgaW4gR2Vja28gNC4wLgkgKi8KICAgICAgICBWS19TTEVFUDogOTUKICAgIH07CiAgICAvKioKICAgICAqIEBuYW1lc3BhY2UKICAgICAqIENvbnRhaW5zIHRleHQgdG9rZW5pemF0aW9uIGFuZCBicmVha2luZyByb3V0aW5lcwogICAgICovCiAgICBST1QuVGV4dCA9IHsKICAgICAgICBSRV9DT0xPUlM6IC8lKFtiY10peyhbXn1dKil9L2csCgogICAgICAgIC8qIHRva2VuIHR5cGVzICovCiAgICAgICAgVFlQRV9URVhUOiAwLAogICAgICAgIFRZUEVfTkVXTElORTogMSwKICAgICAgICBUWVBFX0ZHOiAyLAogICAgICAgIFRZUEVfQkc6IDMsCgogICAgICAgIC8qKgogICAgICAgICAqIE1lYXN1cmUgc2l6ZSBvZiBhIHJlc3VsdGluZyB0ZXh0IGJsb2NrCiAgICAgICAgICovCiAgICAgICAgbWVhc3VyZTogZnVuY3Rpb24oc3RyLCBtYXhXaWR0aCkKICAgICAgICB7CiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7CiAgICAgICAgICAgICAgICB3aWR0aDogMCwKICAgICAgICAgICAgICAgIGhlaWdodDogMQogICAgICAgICAgICB9OwogICAgICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbml6ZShzdHIsIG1heFdpZHRoKTsKICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IDA7CgogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldOwogICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5UWVBFX1RFWFQ6CiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCArPSB0b2tlbi52YWx1ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuVFlQRV9ORVdMSU5FOgogICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaGVpZ2h0Kys7CiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC53aWR0aCA9IE1hdGgubWF4KHJlc3VsdC53aWR0aCwgbGluZVdpZHRoKTsKICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmVzdWx0LndpZHRoID0gTWF0aC5tYXgocmVzdWx0LndpZHRoLCBsaW5lV2lkdGgpOwoKICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9LAoKICAgICAgICAvKioKICAgICAgICAgKiBDb252ZXJ0IHN0cmluZyB0byBhIHNlcmllcyBvZiBhIGZvcm1hdHRpbmcgY29tbWFuZHMKICAgICAgICAgKi8KICAgICAgICB0b2tlbml6ZTogZnVuY3Rpb24oc3RyLCBtYXhXaWR0aCkKICAgICAgICB7CiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTsKCiAgICAgICAgICAgIC8qIGZpcnN0IHRva2VuaXphdGlvbiBwYXNzIC0gc3BsaXQgdGV4dHMgYW5kIGNvbG9yIGZvcm1hdHRpbmcgY29tbWFuZHMgKi8KICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7CiAgICAgICAgICAgIHN0ci5yZXBsYWNlKHRoaXMuUkVfQ09MT1JTLCBmdW5jdGlvbihtYXRjaCwgdHlwZSwgbmFtZSwgaW5kZXgpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIC8qIHN0cmluZyBiZWZvcmUgKi8KICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gc3RyLnN1YnN0cmluZyhvZmZzZXQsIGluZGV4KTsKICAgICAgICAgICAgICAgIGlmIChwYXJ0Lmxlbmd0aCkKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFJPVC5UZXh0LlRZUEVfVEVYVCwKICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcnQKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAvKiBjb2xvciBjb21tYW5kICovCiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICB0eXBlOiAodHlwZSA9PSAiYyIgPyBST1QuVGV4dC5UWVBFX0ZHIDogUk9ULlRleHQuVFlQRV9CRyksCiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5hbWUudHJpbSgpCiAgICAgICAgICAgICAgICB9KTsKCiAgICAgICAgICAgICAgICBvZmZzZXQgPSBpbmRleCArIG1hdGNoLmxlbmd0aDsKICAgICAgICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAvKiBsYXN0IHJlbWFpbmluZyBwYXJ0ICovCiAgICAgICAgICAgIHZhciBwYXJ0ID0gc3RyLnN1YnN0cmluZyhvZmZzZXQpOwogICAgICAgICAgICBpZiAocGFydC5sZW5ndGgpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKAogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIHR5cGU6IFJPVC5UZXh0LlRZUEVfVEVYVCwKICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFydAogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9icmVha0xpbmVzKHJlc3VsdCwgbWF4V2lkdGgpOwogICAgICAgIH0sCgogICAgICAgIC8qIGluc2VydCBsaW5lIGJyZWFrcyBpbnRvIGZpcnN0LXBhc3MgdG9rZW5pemVkIGRhdGEgKi8KICAgICAgICBfYnJlYWtMaW5lczogZnVuY3Rpb24odG9rZW5zLCBtYXhXaWR0aCkKICAgICAgICB7CiAgICAgICAgICAgIGlmICghbWF4V2lkdGgpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIG1heFdpZHRoID0gSW5maW5pdHk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHZhciBpID0gMDsKICAgICAgICAgICAgdmFyIGxpbmVMZW5ndGggPSAwOwogICAgICAgICAgICB2YXIgbGFzdFRva2VuV2l0aFNwYWNlID0gLTE7CgogICAgICAgICAgICB3aGlsZSAoaSA8IHRva2Vucy5sZW5ndGgpCiAgICAgICAgICAgIHsgLyogdGFrZSBhbGwgdGV4dCB0b2tlbnMsIHJlbW92ZSBzcGFjZSwgYXBwbHkgbGluZWJyZWFrcyAqLwogICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldOwogICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT0gUk9ULlRleHQuVFlQRV9ORVdMSU5FKQogICAgICAgICAgICAgICAgeyAvKiByZXNldCAqLwogICAgICAgICAgICAgICAgICAgIGxpbmVMZW5ndGggPSAwOwogICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbldpdGhTcGFjZSA9IC0xOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT0gUk9ULlRleHQuVFlQRV9URVhUKQogICAgICAgICAgICAgICAgeyAvKiBza2lwIG5vbi10ZXh0IHRva2VucyAqLwogICAgICAgICAgICAgICAgICAgIGkrKzsKICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAvKiByZW1vdmUgc3BhY2VzIGF0IHRoZSBiZWdpbm5pbmcgb2YgbGluZSAqLwogICAgICAgICAgICAgICAgd2hpbGUgKGxpbmVMZW5ndGggPT0gMCAmJiB0b2tlbi52YWx1ZS5jaGFyQXQoMCkgPT0gIiAiKQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlID0gdG9rZW4udmFsdWUuc3Vic3RyaW5nKDEpOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIC8qIGZvcmNlZCBuZXdsaW5lPyBpbnNlcnQgdHdvIG5ldyB0b2tlbnMgYWZ0ZXIgdGhpcyBvbmUgKi8KICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRva2VuLnZhbHVlLmluZGV4T2YoIlxuIik7CiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSB0aGlzLl9icmVha0luc2lkZVRva2VuKHRva2VucywgaSwgaW5kZXgsIHRydWUpOwoKICAgICAgICAgICAgICAgICAgICAvKiBpZiB0aGVyZSBhcmUgc3BhY2VzIGF0IHRoZSBlbmQsIHdlIG11c3QgcmVtb3ZlIHRoZW0gKHdlIGRvIG5vdCB3YW50IHRoZSBsaW5lIHRvbyBsb25nKSAqLwogICAgICAgICAgICAgICAgICAgIHZhciBhcnIgPSB0b2tlbi52YWx1ZS5zcGxpdCgiIik7CiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFyci5sZW5ndGggJiYgYXJyW2Fyci5sZW5ndGggLSAxXSA9PSAiICIpCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICBhcnIucG9wKCk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlID0gYXJyLmpvaW4oIiIpOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIC8qIHRva2VuIGRlZ2VuZXJhdGVkPyAqLwogICAgICAgICAgICAgICAgaWYgKCF0b2tlbi52YWx1ZS5sZW5ndGgpCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxKTsKICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBpZiAobGluZUxlbmd0aCArIHRva2VuLnZhbHVlLmxlbmd0aCA+IG1heFdpZHRoKQogICAgICAgICAgICAgICAgeyAvKiBsaW5lIHRvbyBsb25nLCBmaW5kIGEgc3VpdGFibGUgYnJlYWtpbmcgc3BvdCAqLwoKICAgICAgICAgICAgICAgICAgICAvKiBpcyBpdCBwb3NzaWJsZSB0byBicmVhayB3aXRoaW4gdGhpcyB0b2tlbj8gKi8KICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAtMTsKICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0SW5kZXggPSB0b2tlbi52YWx1ZS5pbmRleE9mKCIgIiwgaW5kZXggKyAxKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRJbmRleCA9PSAtMSkKICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVMZW5ndGggKyBuZXh0SW5kZXggPiBtYXhXaWR0aCkKICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBuZXh0SW5kZXg7CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpCiAgICAgICAgICAgICAgICAgICAgeyAvKiBicmVhayBhdCBzcGFjZSB3aXRoaW4gdGhpcyBvbmUgKi8KICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSB0aGlzLl9icmVha0luc2lkZVRva2VuKHRva2VucywgaSwgaW5kZXgsIHRydWUpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChsYXN0VG9rZW5XaXRoU3BhY2UgIT0gLTEpCiAgICAgICAgICAgICAgICAgICAgeyAvKiBpcyB0aGVyZSBhIHByZXZpb3VzIHRva2VuIHdoZXJlIGEgYnJlYWsgY2FuIG9jY3VyPyAqLwogICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbbGFzdFRva2VuV2l0aFNwYWNlXTsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJyZWFrSW5kZXggPSB0b2tlbi52YWx1ZS5sYXN0SW5kZXhPZigiICIpOwogICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZSA9IHRoaXMuX2JyZWFrSW5zaWRlVG9rZW4odG9rZW5zLCBsYXN0VG9rZW5XaXRoU3BhY2UsIGJyZWFrSW5kZXgsIHRydWUpOwogICAgICAgICAgICAgICAgICAgICAgICBpID0gbGFzdFRva2VuV2l0aFNwYWNlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICAgICAgeyAvKiBmb3JjZSBicmVhayBpbiB0aGlzIHRva2VuICovCiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlID0gdGhpcy5fYnJlYWtJbnNpZGVUb2tlbih0b2tlbnMsIGksIG1heFdpZHRoIC0gbGluZUxlbmd0aCwgZmFsc2UpOwogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICB7IC8qIGxpbmUgbm90IGxvbmcsIGNvbnRpbnVlICovCiAgICAgICAgICAgICAgICAgICAgbGluZUxlbmd0aCArPSB0b2tlbi52YWx1ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlLmluZGV4T2YoIiAiKSAhPSAtMSkKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbldpdGhTcGFjZSA9IGk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGkrKzsgLyogYWR2YW5jZSB0byBuZXh0IHRva2VuICovCiAgICAgICAgICAgIH0KCgogICAgICAgICAgICB0b2tlbnMucHVzaCgKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdHlwZTogUk9ULlRleHQuVFlQRV9ORVdMSU5FCiAgICAgICAgICAgIH0pOyAvKiBpbnNlcnQgZmFrZSBuZXdsaW5lIHRvIGZpeCB0aGUgbGFzdCB0ZXh0IGxpbmUgKi8KCiAgICAgICAgICAgIC8qIHJlbW92ZSB0cmFpbGluZyBzcGFjZSBmcm9tIHRleHQgdG9rZW5zIGJlZm9yZSBuZXdsaW5lcyAqLwogICAgICAgICAgICB2YXIgbGFzdFRleHRUb2tlbiA9IG51bGw7CiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07CiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgY2FzZSBST1QuVGV4dC5UWVBFX1RFWFQ6CiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RUZXh0VG9rZW4gPSB0b2tlbjsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgY2FzZSBST1QuVGV4dC5UWVBFX05FV0xJTkU6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0VGV4dFRva2VuKQogICAgICAgICAgICAgICAgICAgICAgICB7IC8qIHJlbW92ZSB0cmFpbGluZyBzcGFjZSAqLwogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyciA9IGxhc3RUZXh0VG9rZW4udmFsdWUuc3BsaXQoIiIpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFyci5sZW5ndGggJiYgYXJyW2Fyci5sZW5ndGggLSAxXSA9PSAiICIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnBvcCgpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFRleHRUb2tlbi52YWx1ZSA9IGFyci5qb2luKCIiKTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBsYXN0VGV4dFRva2VuID0gbnVsbDsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHRva2Vucy5wb3AoKTsgLyogcmVtb3ZlIGZha2UgdG9rZW4gKi8KCiAgICAgICAgICAgIHJldHVybiB0b2tlbnM7CiAgICAgICAgfSwKCiAgICAgICAgLyoqCiAgICAgICAgICogQ3JlYXRlIG5ldyB0b2tlbnMgYW5kIGluc2VydCB0aGVtIGludG8gdGhlIHN0cmVhbQogICAgICAgICAqIEBwYXJhbSB7b2JqZWN0W119IHRva2VucwogICAgICAgICAqIEBwYXJhbSB7aW50fSB0b2tlbkluZGV4IFRva2VuIGJlaW5nIHByb2Nlc3NlZAogICAgICAgICAqIEBwYXJhbSB7aW50fSBicmVha0luZGV4IEluZGV4IHdpdGhpbiBjdXJyZW50IHRva2VuJ3MgdmFsdWUKICAgICAgICAgKiBAcGFyYW0ge2Jvb2x9IHJlbW92ZUJyZWFrQ2hhciBEbyB3ZSB3YW50IHRvIHJlbW92ZSB0aGUgYnJlYWtpbmcgY2hhcmFjdGVyPwogICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHJlbWFpbmluZyB1bmJyb2tlbiB0b2tlbiB2YWx1ZQogICAgICAgICAqLwogICAgICAgIF9icmVha0luc2lkZVRva2VuOiBmdW5jdGlvbih0b2tlbnMsIHRva2VuSW5kZXgsIGJyZWFrSW5kZXgsIHJlbW92ZUJyZWFrQ2hhcikKICAgICAgICB7CiAgICAgICAgICAgIHZhciBuZXdCcmVha1Rva2VuID0gewogICAgICAgICAgICAgICAgdHlwZTogUk9ULlRleHQuVFlQRV9ORVdMSU5FCiAgICAgICAgICAgIH07CiAgICAgICAgICAgIHZhciBuZXdUZXh0VG9rZW4gPSB7CiAgICAgICAgICAgICAgICB0eXBlOiBST1QuVGV4dC5UWVBFX1RFWFQsCiAgICAgICAgICAgICAgICB2YWx1ZTogdG9rZW5zW3Rva2VuSW5kZXhdLnZhbHVlLnN1YnN0cmluZyhicmVha0luZGV4ICsgKHJlbW92ZUJyZWFrQ2hhciA/IDEgOiAwKSkKICAgICAgICAgICAgfTsKICAgICAgICAgICAgdG9rZW5zLnNwbGljZSh0b2tlbkluZGV4ICsgMSwgMCwgbmV3QnJlYWtUb2tlbiwgbmV3VGV4dFRva2VuKTsKICAgICAgICAgICAgcmV0dXJuIHRva2Vuc1t0b2tlbkluZGV4XS52YWx1ZS5zdWJzdHJpbmcoMCwgYnJlYWtJbmRleCk7CiAgICAgICAgfQogICAgfTsKICAgIC8qKgogICAgICogQHJldHVybnMge2FueX0gUmFuZG9tbHkgcGlja2VkIGl0ZW0sIG51bGwgd2hlbiBsZW5ndGg9MAogICAgICovCiAgICBBcnJheS5wcm90b3R5cGUucmFuZG9tID0gQXJyYXkucHJvdG90eXBlLnJhbmRvbSB8fCBmdW5jdGlvbigpCiAgICB7CiAgICAgICAgaWYgKCF0aGlzLmxlbmd0aCkKICAgICAgICB7CiAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpc1tNYXRoLmZsb29yKFJPVC5STkcuZ2V0VW5pZm9ybSgpICogdGhpcy5sZW5ndGgpXTsKICAgIH07CgogICAgLyoqCiAgICAgKiBAcmV0dXJucyB7YXJyYXl9IE5ldyBhcnJheSB3aXRoIHJhbmRvbWl6ZWQgaXRlbXMKICAgICAqLwogICAgQXJyYXkucHJvdG90eXBlLnJhbmRvbWl6ZSA9IEFycmF5LnByb3RvdHlwZS5yYW5kb21pemUgfHwgZnVuY3Rpb24oKQogICAgewogICAgICAgIHZhciByZXN1bHQgPSBbXTsKICAgICAgICB2YXIgY2xvbmUgPSB0aGlzLnNsaWNlKCk7CiAgICAgICAgd2hpbGUgKGNsb25lLmxlbmd0aCkKICAgICAgICB7CiAgICAgICAgICAgIHZhciBpbmRleCA9IGNsb25lLmluZGV4T2YoY2xvbmUucmFuZG9tKCkpOwogICAgICAgICAgICByZXN1bHQucHVzaChjbG9uZS5zcGxpY2UoaW5kZXgsIDEpWzBdKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH07CiAgICAvKioKICAgICAqIEFsd2F5cyBwb3NpdGl2ZSBtb2R1bHVzCiAgICAgKiBAcGFyYW0ge2ludH0gbiBNb2R1bHVzCiAgICAgKiBAcmV0dXJucyB7aW50fSB0aGlzIG1vZHVsbyBuCiAgICAgKi8KICAgIE51bWJlci5wcm90b3R5cGUubW9kID0gTnVtYmVyLnByb3RvdHlwZS5tb2QgfHwgZnVuY3Rpb24obikKICAgIHsKICAgICAgICByZXR1cm4gKCh0aGlzICUgbikgKyBuKSAlIG47CiAgICB9OwogICAgLyoqCiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBGaXJzdCBsZXR0ZXIgY2FwaXRhbGl6ZWQKICAgICAqLwogICAgU3RyaW5nLnByb3RvdHlwZS5jYXBpdGFsaXplID0gU3RyaW5nLnByb3RvdHlwZS5jYXBpdGFsaXplIHx8IGZ1bmN0aW9uKCkKICAgIHsKICAgICAgICByZXR1cm4gdGhpcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRoaXMuc3Vic3RyaW5nKDEpOwogICAgfTsKCiAgICAvKiogCiAgICAgKiBMZWZ0IHBhZAogICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFyYWN0ZXI9IjAiXQogICAgICogQHBhcmFtIHtpbnR9IFtjb3VudD0yXQogICAgICovCiAgICBTdHJpbmcucHJvdG90eXBlLmxwYWQgPSBTdHJpbmcucHJvdG90eXBlLmxwYWQgfHwgZnVuY3Rpb24oY2hhcmFjdGVyLCBjb3VudCkKICAgIHsKICAgICAgICB2YXIgY2ggPSBjaGFyYWN0ZXIgfHwgIjAiOwogICAgICAgIHZhciBjbnQgPSBjb3VudCB8fCAyOwoKICAgICAgICB2YXIgcyA9ICIiOwogICAgICAgIHdoaWxlIChzLmxlbmd0aCA8IChjbnQgLSB0aGlzLmxlbmd0aCkpCiAgICAgICAgewogICAgICAgICAgICBzICs9IGNoOwogICAgICAgIH0KICAgICAgICBzID0gcy5zdWJzdHJpbmcoMCwgY250IC0gdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiBzICsgdGhpczsKICAgIH07CgogICAgLyoqIAogICAgICogUmlnaHQgcGFkCiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJhY3Rlcj0iMCJdCiAgICAgKiBAcGFyYW0ge2ludH0gW2NvdW50PTJdCiAgICAgKi8KICAgIFN0cmluZy5wcm90b3R5cGUucnBhZCA9IFN0cmluZy5wcm90b3R5cGUucnBhZCB8fCBmdW5jdGlvbihjaGFyYWN0ZXIsIGNvdW50KQogICAgewogICAgICAgIHZhciBjaCA9IGNoYXJhY3RlciB8fCAiMCI7CiAgICAgICAgdmFyIGNudCA9IGNvdW50IHx8IDI7CgogICAgICAgIHZhciBzID0gIiI7CiAgICAgICAgd2hpbGUgKHMubGVuZ3RoIDwgKGNudCAtIHRoaXMubGVuZ3RoKSkKICAgICAgICB7CiAgICAgICAgICAgIHMgKz0gY2g7CiAgICAgICAgfQogICAgICAgIHMgPSBzLnN1YnN0cmluZygwLCBjbnQgLSB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXMgKyBzOwogICAgfTsKCiAgICAvKioKICAgICAqIEZvcm1hdCBhIHN0cmluZyBpbiBhIGZsZXhpYmxlIHdheS4gU2NhbnMgZm9yICVzIHN0cmluZ3MgYW5kIHJlcGxhY2VzIHRoZW0gd2l0aCBhcmd1bWVudHMuIExpc3Qgb2YgcGF0dGVybnMgaXMgbW9kaWZpYWJsZSB2aWEgU3RyaW5nLmZvcm1hdC5tYXAuCiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGUKICAgICAqIEBwYXJhbSB7YW55fSBbYXJndl0KICAgICAqLwogICAgU3RyaW5nLmZvcm1hdCA9IFN0cmluZy5mb3JtYXQgfHwgZnVuY3Rpb24odGVtcGxhdGUpCiAgICB7CiAgICAgICAgdmFyIG1hcCA9IFN0cmluZy5mb3JtYXQubWFwOwogICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsKCiAgICAgICAgdmFyIHJlcGxhY2VyID0gZnVuY3Rpb24obWF0Y2gsIGdyb3VwMSwgZ3JvdXAyLCBpbmRleCkKICAgICAgICB7CiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoaW5kZXggLSAxKSA9PSAiJSIpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaC5zdWJzdHJpbmcoMSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKCFhcmdzLmxlbmd0aCkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBvYmogPSBhcmdzWzBdOwoKICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXAxIHx8IGdyb3VwMjsKICAgICAgICAgICAgdmFyIHBhcnRzID0gZ3JvdXAuc3BsaXQoIiwiKTsKICAgICAgICAgICAgdmFyIG5hbWUgPSBwYXJ0cy5zaGlmdCgpOwogICAgICAgICAgICB2YXIgbWV0aG9kID0gbWFwW25hbWUudG9Mb3dlckNhc2UoKV07CiAgICAgICAgICAgIGlmICghbWV0aG9kKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHZhciBvYmogPSBhcmdzLnNoaWZ0KCk7CiAgICAgICAgICAgIHZhciByZXBsYWNlZCA9IG9ialttZXRob2RdLmFwcGx5KG9iaiwgcGFydHMpOwoKICAgICAgICAgICAgdmFyIGZpcnN0ID0gbmFtZS5jaGFyQXQoMCk7CiAgICAgICAgICAgIGlmIChmaXJzdCAhPSBmaXJzdC50b0xvd2VyQ2FzZSgpKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICByZXBsYWNlZCA9IHJlcGxhY2VkLmNhcGl0YWxpemUoKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VkOwogICAgICAgIH07CiAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoLyUoPzooW2Etel0rKXwoPzp7KFtefV0rKX0pKS9naSwgcmVwbGFjZXIpOwogICAgfTsKCiAgICBTdHJpbmcuZm9ybWF0Lm1hcCA9IFN0cmluZy5mb3JtYXQubWFwIHx8IHsKICAgICAgICAicyI6ICJ0b1N0cmluZyIKICAgIH07CgogICAgLyoqCiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCB0byBTdHJpbmcuZm9ybWF0KHRoaXMpCiAgICAgKi8KICAgIFN0cmluZy5wcm90b3R5cGUuZm9ybWF0ID0gU3RyaW5nLnByb3RvdHlwZS5mb3JtYXQgfHwgZnVuY3Rpb24oKQogICAgewogICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTsKICAgICAgICBhcmdzLnVuc2hpZnQodGhpcyk7CiAgICAgICAgcmV0dXJuIFN0cmluZy5mb3JtYXQuYXBwbHkoU3RyaW5nLCBhcmdzKTsKICAgIH07CgogICAgaWYgKCFPYmplY3QuY3JlYXRlKQogICAgewogICAgICAgIC8qKgogICAgICAgICAqIEVTNSBPYmplY3QuY3JlYXRlCiAgICAgICAgICovCiAgICAgICAgT2JqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uKG8pCiAgICAgICAgewogICAgICAgICAgICB2YXIgdG1wID0gZnVuY3Rpb24oKQogICAgICAgICAgICB7fTsKICAgICAgICAgICAgdG1wLnByb3RvdHlwZSA9IG87CiAgICAgICAgICAgIHJldHVybiBuZXcgdG1wKCk7CiAgICAgICAgfTsKICAgIH0KICAgIC8qKgogICAgICogU2V0cyBwcm90b3R5cGUgb2YgdGhpcyBmdW5jdGlvbiB0byBhbiBpbnN0YW5jZSBvZiBwYXJlbnQgZnVuY3Rpb24KICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHBhcmVudAogICAgICovCiAgICBGdW5jdGlvbi5wcm90b3R5cGUuZXh0ZW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmV4dGVuZCB8fCBmdW5jdGlvbihwYXJlbnQpCiAgICB7CiAgICAgICAgdGhpcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5wcm90b3R5cGUpOwogICAgICAgIHRoaXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gdGhpczsKICAgICAgICByZXR1cm4gdGhpczsKICAgIH07CiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPSAidW5kZWZpbmVkIikKICAgIHsKICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0KICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGZ1bmN0aW9uKGNiKQogICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBjYihEYXRlLm5vdygpKTsKICAgICAgICAgICAgfSwgMTAwMCAvIDYwKTsKICAgICAgICB9OwoKICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPQogICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cub0NhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGZ1bmN0aW9uKGlkKQogICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChpZCk7CiAgICAgICAgfTsKICAgIH0KICAgIC8qKgogICAgICogQGNsYXNzIFZpc3VhbCBtYXAgZGlzcGxheQogICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXQogICAgICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLndpZHRoPVJPVC5ERUZBVUxUX1dJRFRIXQogICAgICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLmhlaWdodD1ST1QuREVGQVVMVF9IRUlHSFRdCiAgICAgKiBAcGFyYW0ge2ludH0gW29wdGlvbnMuZm9udFNpemU9MTVdCiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZm9udEZhbWlseT0ibW9ub3NwYWNlIl0KICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mb250U3R5bGU9IiJdIGJvbGQvaXRhbGljL25vbmUvYm90aAogICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZnPSIjY2NjIl0KICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5iZz0iIzAwMCJdCiAgICAgKiBAcGFyYW0ge2Zsb2F0fSBbb3B0aW9ucy5zcGFjaW5nPTFdCiAgICAgKiBAcGFyYW0ge2Zsb2F0fSBbb3B0aW9ucy5ib3JkZXI9MF0KICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYXlvdXQ9InJlY3QiXQogICAgICogQHBhcmFtIHtib29sfSBbb3B0aW9ucy5mb3JjZVNxdWFyZVJhdGlvPWZhbHNlXQogICAgICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLnRpbGVXaWR0aD0zMl0KICAgICAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy50aWxlSGVpZ2h0PTMyXQogICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnRpbGVNYXA9e31dCiAgICAgKiBAcGFyYW0ge2ltYWdlfSBbb3B0aW9ucy50aWxlU2V0PW51bGxdCiAgICAgKiBAcGFyYW0ge2ltYWdlfSBbb3B0aW9ucy50aWxlQ29sb3JpemU9ZmFsc2VdCiAgICAgKi8KICAgIFJPVC5EaXNwbGF5ID0gZnVuY3Rpb24ob3B0aW9ucykKICAgIHsKICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIik7CiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCIyZCIpOwogICAgICAgIHRoaXMuX2RhdGEgPSB7fTsKICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlOyAvKiBmYWxzZSA9IG5vdGhpbmcsIHRydWUgPSBhbGwsIG9iamVjdCA9IGRpcnR5IGNlbGxzICovCiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHt9OwogICAgICAgIHRoaXMuX2JhY2tlbmQgPSBudWxsOwoKICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7CiAgICAgICAgICAgIHdpZHRoOiBST1QuREVGQVVMVF9XSURUSCwKICAgICAgICAgICAgaGVpZ2h0OiBST1QuREVGQVVMVF9IRUlHSFQsCiAgICAgICAgICAgIHRyYW5zcG9zZTogZmFsc2UsCiAgICAgICAgICAgIGxheW91dDogInJlY3QiLAogICAgICAgICAgICBmb250U2l6ZTogMTUsCiAgICAgICAgICAgIHNwYWNpbmc6IDEsCiAgICAgICAgICAgIGJvcmRlcjogMCwKICAgICAgICAgICAgZm9yY2VTcXVhcmVSYXRpbzogZmFsc2UsCiAgICAgICAgICAgIGZvbnRGYW1pbHk6ICJtb25vc3BhY2UiLAogICAgICAgICAgICBmb250U3R5bGU6ICIiLAogICAgICAgICAgICBmZzogIiNjY2MiLAogICAgICAgICAgICBiZzogIiMwMDAiLAogICAgICAgICAgICB0aWxlV2lkdGg6IDMyLAogICAgICAgICAgICB0aWxlSGVpZ2h0OiAzMiwKICAgICAgICAgICAgdGlsZU1hcDoge30sCiAgICAgICAgICAgIHRpbGVTZXQ6IG51bGwsCiAgICAgICAgICAgIHRpbGVDb2xvcml6ZTogZmFsc2UsCiAgICAgICAgICAgIHRlcm1Db2xvcjogInh0ZXJtIgogICAgICAgIH07CiAgICAgICAgZm9yICh2YXIgcCBpbiBvcHRpb25zKQogICAgICAgIHsKICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnNbcF0gPSBvcHRpb25zW3BdOwogICAgICAgIH0KICAgICAgICB0aGlzLnNldE9wdGlvbnMoZGVmYXVsdE9wdGlvbnMpOwogICAgICAgIHRoaXMuREVCVUcgPSB0aGlzLkRFQlVHLmJpbmQodGhpcyk7CgogICAgICAgIHRoaXMuX3RpY2sgPSB0aGlzLl90aWNrLmJpbmQodGhpcyk7CiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RpY2spOwogICAgfTsKCiAgICAvKioKICAgICAqIERlYnVnIGhlbHBlciwgaWRlYWwgYXMgYSBtYXAgZ2VuZXJhdG9yIGNhbGxiYWNrLiBBbHdheXMgYm91bmQgdG8gdGhpcy4KICAgICAqIEBwYXJhbSB7aW50fSB4CiAgICAgKiBAcGFyYW0ge2ludH0geQogICAgICogQHBhcmFtIHtpbnR9IHdoYXQKICAgICAqLwogICAgUk9ULkRpc3BsYXkucHJvdG90eXBlLkRFQlVHID0gZnVuY3Rpb24oeCwgeSwgd2hhdCkKICAgIHsKICAgICAgICB2YXIgY29sb3JzID0gW3RoaXMuX29wdGlvbnMuYmcsIHRoaXMuX29wdGlvbnMuZmddOwogICAgICAgIHRoaXMuZHJhdyh4LCB5LCBudWxsLCBudWxsLCBjb2xvcnNbd2hhdCAlIGNvbG9ycy5sZW5ndGhdKTsKICAgIH07CgogICAgLyoqCiAgICAgKiBDbGVhciB0aGUgd2hvbGUgZGlzcGxheSAoY292ZXIgaXQgd2l0aCBiYWNrZ3JvdW5kIGNvbG9yKQogICAgICovCiAgICBST1QuRGlzcGxheS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpCiAgICB7CiAgICAgICAgdGhpcy5fZGF0YSA9IHt9OwogICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTsKICAgIH07CgogICAgLyoqCiAgICAgKiBAc2VlIFJPVC5EaXNwbGF5CiAgICAgKi8KICAgIFJPVC5EaXNwbGF5LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykKICAgIHsKICAgICAgICBmb3IgKHZhciBwIGluIG9wdGlvbnMpCiAgICAgICAgewogICAgICAgICAgICB0aGlzLl9vcHRpb25zW3BdID0gb3B0aW9uc1twXTsKICAgICAgICB9CiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggfHwgb3B0aW9ucy5oZWlnaHQgfHwgb3B0aW9ucy5mb250U2l6ZSB8fCBvcHRpb25zLmZvbnRGYW1pbHkgfHwgb3B0aW9ucy5zcGFjaW5nIHx8IG9wdGlvbnMubGF5b3V0KQogICAgICAgIHsKICAgICAgICAgICAgaWYgKG9wdGlvbnMubGF5b3V0KQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICB0aGlzLl9iYWNrZW5kID0gbmV3IFJPVC5EaXNwbGF5W29wdGlvbnMubGF5b3V0LmNhcGl0YWxpemUoKV0odGhpcy5fY29udGV4dCk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHZhciBmb250ID0gKHRoaXMuX29wdGlvbnMuZm9udFN0eWxlID8gdGhpcy5fb3B0aW9ucy5mb250U3R5bGUgKyAiICIgOiAiIikgKyB0aGlzLl9vcHRpb25zLmZvbnRTaXplICsgInB4ICIgKyB0aGlzLl9vcHRpb25zLmZvbnRGYW1pbHk7CiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZm9udCA9IGZvbnQ7CiAgICAgICAgICAgIHRoaXMuX2JhY2tlbmQuY29tcHV0ZSh0aGlzLl9vcHRpb25zKTsKICAgICAgICAgICAgdGhpcy5fY29udGV4dC5mb250ID0gZm9udDsKICAgICAgICAgICAgdGhpcy5fY29udGV4dC50ZXh0QWxpZ24gPSAiY2VudGVyIjsKICAgICAgICAgICAgdGhpcy5fY29udGV4dC50ZXh0QmFzZWxpbmUgPSAibWlkZGxlIjsKICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgIH07CgogICAgLyoqCiAgICAgKiBSZXR1cm5zIGN1cnJlbnRseSBzZXQgb3B0aW9ucwogICAgICogQHJldHVybnMge29iamVjdH0gQ3VycmVudCBvcHRpb25zIG9iamVjdAogICAgICovCiAgICBST1QuRGlzcGxheS5wcm90b3R5cGUuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uKCkKICAgIHsKICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9uczsKICAgIH07CgogICAgLyoqCiAgICAgKiBSZXR1cm5zIHRoZSBET00gbm9kZSBvZiB0aGlzIGRpc3BsYXkKICAgICAqIEByZXR1cm5zIHtub2RlfSBET00gbm9kZQogICAgICovCiAgICBST1QuRGlzcGxheS5wcm90b3R5cGUuZ2V0Q29udGFpbmVyID0gZnVuY3Rpb24oKQogICAgewogICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmNhbnZhczsKICAgIH07CgogICAgLyoqCiAgICAgKiBDb21wdXRlIHRoZSBtYXhpbXVtIHdpZHRoL2hlaWdodCB0byBmaXQgaW50byBhIHNldCBvZiBnaXZlbiBjb25zdHJhaW50cwogICAgICogQHBhcmFtIHtpbnR9IGF2YWlsV2lkdGggTWF4aW11bSBhbGxvd2VkIHBpeGVsIHdpZHRoCiAgICAgKiBAcGFyYW0ge2ludH0gYXZhaWxIZWlnaHQgTWF4aW11bSBhbGxvd2VkIHBpeGVsIGhlaWdodAogICAgICogQHJldHVybnMge2ludFsyXX0gY2VsbFdpZHRoLGNlbGxIZWlnaHQKICAgICAqLwogICAgUk9ULkRpc3BsYXkucHJvdG90eXBlLmNvbXB1dGVTaXplID0gZnVuY3Rpb24oYXZhaWxXaWR0aCwgYXZhaWxIZWlnaHQpCiAgICB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2JhY2tlbmQuY29tcHV0ZVNpemUoYXZhaWxXaWR0aCwgYXZhaWxIZWlnaHQsIHRoaXMuX29wdGlvbnMpOwogICAgfTsKCiAgICAvKioKICAgICAqIENvbXB1dGUgdGhlIG1heGltdW0gZm9udCBzaXplIHRvIGZpdCBpbnRvIGEgc2V0IG9mIGdpdmVuIGNvbnN0cmFpbnRzCiAgICAgKiBAcGFyYW0ge2ludH0gYXZhaWxXaWR0aCBNYXhpbXVtIGFsbG93ZWQgcGl4ZWwgd2lkdGgKICAgICAqIEBwYXJhbSB7aW50fSBhdmFpbEhlaWdodCBNYXhpbXVtIGFsbG93ZWQgcGl4ZWwgaGVpZ2h0CiAgICAgKiBAcmV0dXJucyB7aW50fSBmb250U2l6ZQogICAgICovCiAgICBST1QuRGlzcGxheS5wcm90b3R5cGUuY29tcHV0ZUZvbnRTaXplID0gZnVuY3Rpb24oYXZhaWxXaWR0aCwgYXZhaWxIZWlnaHQpCiAgICB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2JhY2tlbmQuY29tcHV0ZUZvbnRTaXplKGF2YWlsV2lkdGgsIGF2YWlsSGVpZ2h0LCB0aGlzLl9vcHRpb25zKTsKICAgIH07CgogICAgLyoqCiAgICAgKiBDb252ZXJ0IGEgRE9NIGV2ZW50IChtb3VzZSBvciB0b3VjaCkgdG8gbWFwIGNvb3JkaW5hdGVzLiBVc2VzIGZpcnN0IHRvdWNoIGZvciBtdWx0aS10b3VjaC4KICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgZXZlbnQKICAgICAqIEByZXR1cm5zIHtpbnRbMl19IC0xIGZvciB2YWx1ZXMgb3V0c2lkZSBvZiB0aGUgY2FudmFzCiAgICAgKi8KICAgIFJPVC5EaXNwbGF5LnByb3RvdHlwZS5ldmVudFRvUG9zaXRpb24gPSBmdW5jdGlvbihlKQogICAgewogICAgICAgIGlmIChlLnRvdWNoZXMpCiAgICAgICAgewogICAgICAgICAgICB2YXIgeCA9IGUudG91Y2hlc1swXS5jbGllbnRYOwogICAgICAgICAgICB2YXIgeSA9IGUudG91Y2hlc1swXS5jbGllbnRZOwogICAgICAgIH0KICAgICAgICBlbHNlCiAgICAgICAgewogICAgICAgICAgICB2YXIgeCA9IGUuY2xpZW50WDsKICAgICAgICAgICAgdmFyIHkgPSBlLmNsaWVudFk7CiAgICAgICAgfQoKICAgICAgICB2YXIgcmVjdCA9IHRoaXMuX2NvbnRleHQuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOwogICAgICAgIHggLT0gcmVjdC5sZWZ0OwogICAgICAgIHkgLT0gcmVjdC50b3A7CgogICAgICAgIHggKj0gdGhpcy5fY29udGV4dC5jYW52YXMud2lkdGggLyByZWN0LndpZHRoOwogICAgICAgIHkgKj0gdGhpcy5fY29udGV4dC5jYW52YXMuaGVpZ2h0IC8gcmVjdC5oZWlnaHQ7CgogICAgICAgIGlmICh4IDwgMCB8fCB5IDwgMCB8fCB4ID49IHRoaXMuX2NvbnRleHQuY2FudmFzLndpZHRoIHx8IHkgPj0gdGhpcy5fY29udGV4dC5jYW52YXMuaGVpZ2h0KQogICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuIFstMSwgLTFdOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIHRoaXMuX2JhY2tlbmQuZXZlbnRUb1Bvc2l0aW9uKHgsIHkpOwogICAgfTsKCiAgICAvKioKICAgICAqIEBwYXJhbSB7aW50fSB4CiAgICAgKiBAcGFyYW0ge2ludH0geQogICAgICogQHBhcmFtIHtzdHJpbmcgfHwgc3RyaW5nW119IGNoIE9uZSBvciBtb3JlIGNoYXJzICh3aWxsIGJlIG92ZXJsYXBwaW5nIHRoZW1zZWx2ZXMpCiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZnXSBmb3JlZ3JvdW5kIGNvbG9yCiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2JnXSBiYWNrZ3JvdW5kIGNvbG9yCiAgICAgKi8KICAgIFJPVC5EaXNwbGF5LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oeCwgeSwgY2gsIGZnLCBiZykKICAgIHsKICAgICAgICBpZiAoIWZnKQogICAgICAgIHsKICAgICAgICAgICAgZmcgPSB0aGlzLl9vcHRpb25zLmZnOwogICAgICAgIH0KICAgICAgICBpZiAoIWJnKQogICAgICAgIHsKICAgICAgICAgICAgYmcgPSB0aGlzLl9vcHRpb25zLmJnOwogICAgICAgIH0KICAgICAgICB0aGlzLl9kYXRhW3ggKyAiLCIgKyB5XSA9IFt4LCB5LCBjaCwgZmcsIGJnXTsKCiAgICAgICAgaWYgKHRoaXMuX2RpcnR5ID09PSB0cnVlKQogICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgIH0gLyogd2lsbCBhbHJlYWR5IHJlZHJhdyBldmVyeXRoaW5nICovCiAgICAgICAgaWYgKCF0aGlzLl9kaXJ0eSkKICAgICAgICB7CiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0ge307CiAgICAgICAgfSAvKiBmaXJzdCEgKi8KICAgICAgICB0aGlzLl9kaXJ0eVt4ICsgIiwiICsgeV0gPSB0cnVlOwogICAgfTsKCiAgICAvKioKICAgICAqIERyYXdzIGEgdGV4dCBhdCBnaXZlbiBwb3NpdGlvbi4gT3B0aW9uYWxseSB3cmFwcyBhdCBhIG1heGltdW0gbGVuZ3RoLiBDdXJyZW50bHkgZG9lcyBub3Qgd29yayB3aXRoIGhleCBsYXlvdXQuCiAgICAgKiBAcGFyYW0ge2ludH0geAogICAgICogQHBhcmFtIHtpbnR9IHkKICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IE1heSBjb250YWluIGNvbG9yL2JhY2tncm91bmQgZm9ybWF0IHNwZWNpZmllcnMsICVje25hbWV9LyVie25hbWV9LCBib3RoIG9wdGlvbmFsLiAlY3t9LyVie30gcmVzZXRzIHRvIGRlZmF1bHQuCiAgICAgKiBAcGFyYW0ge2ludH0gW21heFdpZHRoXSB3cmFwIGF0IHdoYXQgd2lkdGg/CiAgICAgKiBAcmV0dXJucyB7aW50fSBsaW5lcyBkcmF3bgogICAgICovCiAgICBST1QuRGlzcGxheS5wcm90b3R5cGUuZHJhd1RleHQgPSBmdW5jdGlvbih4LCB5LCB0ZXh0LCBtYXhXaWR0aCkKICAgIHsKICAgICAgICB2YXIgZmcgPSBudWxsOwogICAgICAgIHZhciBiZyA9IG51bGw7CiAgICAgICAgdmFyIGN4ID0geDsKICAgICAgICB2YXIgY3kgPSB5OwogICAgICAgIHZhciBsaW5lcyA9IDE7CiAgICAgICAgaWYgKCFtYXhXaWR0aCkKICAgICAgICB7CiAgICAgICAgICAgIG1heFdpZHRoID0gdGhpcy5fb3B0aW9ucy53aWR0aCAtIHg7CiAgICAgICAgfQoKICAgICAgICB2YXIgdG9rZW5zID0gUk9ULlRleHQudG9rZW5pemUodGV4dCwgbWF4V2lkdGgpOwoKICAgICAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkKICAgICAgICB7IC8qIGludGVycHJldCB0b2tlbml6ZWQgb3Bjb2RlIHN0cmVhbSAqLwogICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnMuc2hpZnQoKTsKICAgICAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBjYXNlIFJPVC5UZXh0LlRZUEVfVEVYVDoKICAgICAgICAgICAgICAgICAgICB2YXIgaXNTcGFjZSA9IGZhbHNlLAogICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZTcGFjZSA9IGZhbHNlLAogICAgICAgICAgICAgICAgICAgICAgICBpc0Z1bGxXaWR0aCA9IGZhbHNlLAogICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZGdWxsV2lkdGggPSBmYWxzZTsKICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2VuLnZhbHVlLmxlbmd0aDsgaSsrKQogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNjID0gdG9rZW4udmFsdWUuY2hhckNvZGVBdChpKTsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSB0b2tlbi52YWx1ZS5jaGFyQXQoaSk7CiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiB0byBgdHJ1ZWAgd2hlbiB0aGUgY3VycmVudCBjaGFyIGlzIGZ1bGwtd2lkdGguCiAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVsbFdpZHRoID0gKGNjID4gMHhmZjAwICYmIGNjIDwgMHhmZjYxKSB8fCAoY2MgPiAweGZmZGMgJiYgY2MgPCAweGZmZTgpIHx8IGNjID4gMHhmZmVlOwogICAgICAgICAgICAgICAgICAgICAgICAvLyBDdXJyZW50IGNoYXIgaXMgc3BhY2UsIHdoYXRldmVyIGZ1bGwtd2lkdGggb3IgaGFsZi13aWR0aCBib3RoIGFyZSBPSy4KICAgICAgICAgICAgICAgICAgICAgICAgaXNTcGFjZSA9IChjLmNoYXJDb2RlQXQoMCkgPT0gMHgyMCB8fCBjLmNoYXJDb2RlQXQoMCkgPT0gMHgzMDAwKTsKICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHByZXZpb3VzIGNoYXIgaXMgZnVsbC13aWR0aCBhbmQKICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBjaGFyIGlzIG5ldGhlciBoYWxmLXdpZHRoIG5vciBhIHNwYWNlLgogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcmV2RnVsbFdpZHRoICYmICFpc0Z1bGxXaWR0aCAmJiAhaXNTcGFjZSkKICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY3grKzsKICAgICAgICAgICAgICAgICAgICAgICAgfSAvLyBhZGQgYW4gZXh0cmEgcG9zaXRpb24KICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgY2hhciBpcyBmdWxsLXdpZHRoIGFuZAogICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcHJldmlvdXMgY2hhciBpcyBub3QgYSBzcGFjZS4KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVsbFdpZHRoICYmICFpc1ByZXZTcGFjZSkKICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY3grKzsKICAgICAgICAgICAgICAgICAgICAgICAgfSAvLyBhZGQgYW4gZXh0cmEgcG9zaXRpb24KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3KGN4KyssIGN5LCBjLCBmZywgYmcpOwogICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZTcGFjZSA9IGlzU3BhY2U7CiAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJldkZ1bGxXaWR0aCA9IGlzRnVsbFdpZHRoOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgICBjYXNlIFJPVC5UZXh0LlRZUEVfRkc6CiAgICAgICAgICAgICAgICAgICAgZmcgPSB0b2tlbi52YWx1ZSB8fCBudWxsOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICAgIGNhc2UgUk9ULlRleHQuVFlQRV9CRzoKICAgICAgICAgICAgICAgICAgICBiZyA9IHRva2VuLnZhbHVlIHx8IG51bGw7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgICAgY2FzZSBST1QuVGV4dC5UWVBFX05FV0xJTkU6CiAgICAgICAgICAgICAgICAgICAgY3ggPSB4OwogICAgICAgICAgICAgICAgICAgIGN5Kys7CiAgICAgICAgICAgICAgICAgICAgbGluZXMrKzsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIGxpbmVzOwogICAgfTsKCiAgICAvKioKICAgICAqIFRpbWVyIHRpY2s6IHVwZGF0ZSBkaXJ0eSBwYXJ0cwogICAgICovCiAgICBST1QuRGlzcGxheS5wcm90b3R5cGUuX3RpY2sgPSBmdW5jdGlvbigpCiAgICB7CiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RpY2spOwoKICAgICAgICBpZiAoIXRoaXMuX2RpcnR5KQogICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgaWYgKHRoaXMuX2RpcnR5ID09PSB0cnVlKQogICAgICAgIHsgLyogZHJhdyBhbGwgKi8KICAgICAgICAgICAgdGhpcy5fY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLl9vcHRpb25zLmJnOwogICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxSZWN0KDAsIDAsIHRoaXMuX2NvbnRleHQuY2FudmFzLndpZHRoLCB0aGlzLl9jb250ZXh0LmNhbnZhcy5oZWlnaHQpOwoKICAgICAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fZGF0YSkKICAgICAgICAgICAgeyAvKiByZWRyYXcgY2FjaGVkIGRhdGEgKi8KICAgICAgICAgICAgICAgIHRoaXMuX2RyYXcoaWQsIGZhbHNlKTsKICAgICAgICAgICAgfQoKICAgICAgICB9CiAgICAgICAgZWxzZQogICAgICAgIHsgLyogZHJhdyBvbmx5IGRpcnR5ICovCiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9kaXJ0eSkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdGhpcy5fZHJhdyhrZXksIHRydWUpOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlOwogICAgfTsKCiAgICAvKioKICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgV2hhdCB0byBkcmF3CiAgICAgKiBAcGFyYW0ge2Jvb2x9IGNsZWFyQmVmb3JlIElzIGl0IG5lY2Vzc2FyeSB0byBjbGVhbiBiZWZvcmU/CiAgICAgKi8KICAgIFJPVC5EaXNwbGF5LnByb3RvdHlwZS5fZHJhdyA9IGZ1bmN0aW9uKGtleSwgY2xlYXJCZWZvcmUpCiAgICB7CiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhW2tleV07CiAgICAgICAgaWYgKGRhdGFbNF0gIT0gdGhpcy5fb3B0aW9ucy5iZykKICAgICAgICB7CiAgICAgICAgICAgIGNsZWFyQmVmb3JlID0gdHJ1ZTsKICAgICAgICB9CgogICAgICAgIHRoaXMuX2JhY2tlbmQuZHJhdyhkYXRhLCBjbGVhckJlZm9yZSk7CiAgICB9OwogICAgLyoqCiAgICAgKiBAY2xhc3MgQWJzdHJhY3QgZGlzcGxheSBiYWNrZW5kIG1vZHVsZQogICAgICogQHByaXZhdGUKICAgICAqLwogICAgUk9ULkRpc3BsYXkuQmFja2VuZCA9IGZ1bmN0aW9uKGNvbnRleHQpCiAgICB7CiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7CiAgICB9OwoKICAgIFJPVC5EaXNwbGF5LkJhY2tlbmQucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbihvcHRpb25zKQogICAge307CgogICAgUk9ULkRpc3BsYXkuQmFja2VuZC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGRhdGEsIGNsZWFyQmVmb3JlKQogICAge307CgogICAgUk9ULkRpc3BsYXkuQmFja2VuZC5wcm90b3R5cGUuY29tcHV0ZVNpemUgPSBmdW5jdGlvbihhdmFpbFdpZHRoLCBhdmFpbEhlaWdodCkKICAgIHt9OwoKICAgIFJPVC5EaXNwbGF5LkJhY2tlbmQucHJvdG90eXBlLmNvbXB1dGVGb250U2l6ZSA9IGZ1bmN0aW9uKGF2YWlsV2lkdGgsIGF2YWlsSGVpZ2h0KQogICAge307CgogICAgUk9ULkRpc3BsYXkuQmFja2VuZC5wcm90b3R5cGUuZXZlbnRUb1Bvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSkKICAgIHt9OwogICAgLyoqCiAgICAgKiBAY2xhc3MgUmVjdGFuZ3VsYXIgYmFja2VuZAogICAgICogQHByaXZhdGUKICAgICAqLwogICAgUk9ULkRpc3BsYXkuUmVjdCA9IGZ1bmN0aW9uKGNvbnRleHQpCiAgICB7CiAgICAgICAgUk9ULkRpc3BsYXkuQmFja2VuZC5jYWxsKHRoaXMsIGNvbnRleHQpOwoKICAgICAgICB0aGlzLl9zcGFjaW5nWCA9IDA7CiAgICAgICAgdGhpcy5fc3BhY2luZ1kgPSAwOwogICAgICAgIHRoaXMuX2NhbnZhc0NhY2hlID0ge307CiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHt9OwogICAgfTsKICAgIFJPVC5EaXNwbGF5LlJlY3QuZXh0ZW5kKFJPVC5EaXNwbGF5LkJhY2tlbmQpOwoKICAgIFJPVC5EaXNwbGF5LlJlY3QuY2FjaGUgPSBmYWxzZTsKCiAgICBST1QuRGlzcGxheS5SZWN0LnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24ob3B0aW9ucykKICAgIHsKICAgICAgICB0aGlzLl9jYW52YXNDYWNoZSA9IHt9OwogICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zOwoKICAgICAgICB2YXIgY2hhcldpZHRoID0gTWF0aC5jZWlsKHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQoIlciKS53aWR0aCk7CiAgICAgICAgdGhpcy5fc3BhY2luZ1ggPSBNYXRoLmNlaWwob3B0aW9ucy5zcGFjaW5nICogY2hhcldpZHRoKTsKICAgICAgICB0aGlzLl9zcGFjaW5nWSA9IE1hdGguY2VpbChvcHRpb25zLnNwYWNpbmcgKiBvcHRpb25zLmZvbnRTaXplKTsKCiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZm9yY2VTcXVhcmVSYXRpbykKICAgICAgICB7CiAgICAgICAgICAgIHRoaXMuX3NwYWNpbmdYID0gdGhpcy5fc3BhY2luZ1kgPSBNYXRoLm1heCh0aGlzLl9zcGFjaW5nWCwgdGhpcy5fc3BhY2luZ1kpOwogICAgICAgIH0KCiAgICAgICAgdGhpcy5fY29udGV4dC5jYW52YXMud2lkdGggPSBvcHRpb25zLndpZHRoICogdGhpcy5fc3BhY2luZ1g7CiAgICAgICAgdGhpcy5fY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgKiB0aGlzLl9zcGFjaW5nWTsKICAgIH07CgogICAgUk9ULkRpc3BsYXkuUmVjdC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGRhdGEsIGNsZWFyQmVmb3JlKQogICAgewogICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLmNhY2hlKQogICAgICAgIHsKICAgICAgICAgICAgdGhpcy5fZHJhd1dpdGhDYWNoZShkYXRhLCBjbGVhckJlZm9yZSk7CiAgICAgICAgfQogICAgICAgIGVsc2UKICAgICAgICB7CiAgICAgICAgICAgIHRoaXMuX2RyYXdOb0NhY2hlKGRhdGEsIGNsZWFyQmVmb3JlKTsKICAgICAgICB9CiAgICB9OwoKICAgIFJPVC5EaXNwbGF5LlJlY3QucHJvdG90eXBlLl9kcmF3V2l0aENhY2hlID0gZnVuY3Rpb24oZGF0YSwgY2xlYXJCZWZvcmUpCiAgICB7CiAgICAgICAgdmFyIHggPSBkYXRhWzBdOwogICAgICAgIHZhciB5ID0gZGF0YVsxXTsKICAgICAgICB2YXIgY2ggPSBkYXRhWzJdOwogICAgICAgIHZhciBmZyA9IGRhdGFbM107CiAgICAgICAgdmFyIGJnID0gZGF0YVs0XTsKCiAgICAgICAgdmFyIGhhc2ggPSAiIiArIGNoICsgZmcgKyBiZzsKICAgICAgICBpZiAoaGFzaCBpbiB0aGlzLl9jYW52YXNDYWNoZSkKICAgICAgICB7CiAgICAgICAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXNDYWNoZVtoYXNoXTsKICAgICAgICB9CiAgICAgICAgZWxzZQogICAgICAgIHsKICAgICAgICAgICAgdmFyIGIgPSB0aGlzLl9vcHRpb25zLmJvcmRlcjsKICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpOwogICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoIjJkIik7CiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuX3NwYWNpbmdYOwogICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5fc3BhY2luZ1k7CiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBiZzsKICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGIsIGIsIGNhbnZhcy53aWR0aCAtIGIsIGNhbnZhcy5oZWlnaHQgLSBiKTsKCiAgICAgICAgICAgIGlmIChjaCkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZnOwogICAgICAgICAgICAgICAgY3R4LmZvbnQgPSB0aGlzLl9jb250ZXh0LmZvbnQ7CiAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gImNlbnRlciI7CiAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gIm1pZGRsZSI7CgogICAgICAgICAgICAgICAgdmFyIGNoYXJzID0gW10uY29uY2F0KGNoKTsKICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJzW2ldLCB0aGlzLl9zcGFjaW5nWCAvIDIsIE1hdGguY2VpbCh0aGlzLl9zcGFjaW5nWSAvIDIpKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLl9jYW52YXNDYWNoZVtoYXNoXSA9IGNhbnZhczsKICAgICAgICB9CgogICAgICAgIHRoaXMuX2NvbnRleHQuZHJhd0ltYWdlKGNhbnZhcywgeCAqIHRoaXMuX3NwYWNpbmdYLCB5ICogdGhpcy5fc3BhY2luZ1kpOwogICAgfTsKCiAgICBST1QuRGlzcGxheS5SZWN0LnByb3RvdHlwZS5fZHJhd05vQ2FjaGUgPSBmdW5jdGlvbihkYXRhLCBjbGVhckJlZm9yZSkKICAgIHsKICAgICAgICB2YXIgeCA9IGRhdGFbMF07CiAgICAgICAgdmFyIHkgPSBkYXRhWzFdOwogICAgICAgIHZhciBjaCA9IGRhdGFbMl07CiAgICAgICAgdmFyIGZnID0gZGF0YVszXTsKICAgICAgICB2YXIgYmcgPSBkYXRhWzRdOwoKICAgICAgICBpZiAoY2xlYXJCZWZvcmUpCiAgICAgICAgewogICAgICAgICAgICB2YXIgYiA9IHRoaXMuX29wdGlvbnMuYm9yZGVyOwogICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxTdHlsZSA9IGJnOwogICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxSZWN0KHggKiB0aGlzLl9zcGFjaW5nWCArIGIsIHkgKiB0aGlzLl9zcGFjaW5nWSArIGIsIHRoaXMuX3NwYWNpbmdYIC0gYiwgdGhpcy5fc3BhY2luZ1kgLSBiKTsKICAgICAgICB9CgogICAgICAgIGlmICghY2gpCiAgICAgICAgewogICAgICAgICAgICByZXR1cm47CiAgICAgICAgfQoKICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxTdHlsZSA9IGZnOwoKICAgICAgICB2YXIgY2hhcnMgPSBbXS5jb25jYXQoY2gpOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspCiAgICAgICAgewogICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxUZXh0KGNoYXJzW2ldLCAoeCArIDAuNSkgKiB0aGlzLl9zcGFjaW5nWCwgTWF0aC5jZWlsKCh5ICsgMC41KSAqIHRoaXMuX3NwYWNpbmdZKSk7CiAgICAgICAgfQogICAgfTsKCiAgICBST1QuRGlzcGxheS5SZWN0LnByb3RvdHlwZS5jb21wdXRlU2l6ZSA9IGZ1bmN0aW9uKGF2YWlsV2lkdGgsIGF2YWlsSGVpZ2h0KQogICAgewogICAgICAgIHZhciB3aWR0aCA9IE1hdGguZmxvb3IoYXZhaWxXaWR0aCAvIHRoaXMuX3NwYWNpbmdYKTsKICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5mbG9vcihhdmFpbEhlaWdodCAvIHRoaXMuX3NwYWNpbmdZKTsKICAgICAgICByZXR1cm4gW3dpZHRoLCBoZWlnaHRdOwogICAgfTsKCiAgICBST1QuRGlzcGxheS5SZWN0LnByb3RvdHlwZS5jb21wdXRlRm9udFNpemUgPSBmdW5jdGlvbihhdmFpbFdpZHRoLCBhdmFpbEhlaWdodCkKICAgIHsKICAgICAgICB2YXIgYm94V2lkdGggPSBNYXRoLmZsb29yKGF2YWlsV2lkdGggLyB0aGlzLl9vcHRpb25zLndpZHRoKTsKICAgICAgICB2YXIgYm94SGVpZ2h0ID0gTWF0aC5mbG9vcihhdmFpbEhlaWdodCAvIHRoaXMuX29wdGlvbnMuaGVpZ2h0KTsKCiAgICAgICAgLyogY29tcHV0ZSBjaGFyIHJhdGlvICovCiAgICAgICAgdmFyIG9sZEZvbnQgPSB0aGlzLl9jb250ZXh0LmZvbnQ7CiAgICAgICAgdGhpcy5fY29udGV4dC5mb250ID0gIjEwMHB4ICIgKyB0aGlzLl9vcHRpb25zLmZvbnRGYW1pbHk7CiAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5jZWlsKHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQoIlciKS53aWR0aCk7CiAgICAgICAgdGhpcy5fY29udGV4dC5mb250ID0gb2xkRm9udDsKICAgICAgICB2YXIgcmF0aW8gPSB3aWR0aCAvIDEwMDsKCiAgICAgICAgdmFyIHdpZHRoRnJhY3Rpb24gPSByYXRpbyAqIGJveEhlaWdodCAvIGJveFdpZHRoOwogICAgICAgIGlmICh3aWR0aEZyYWN0aW9uID4gMSkKICAgICAgICB7IC8qIHRvbyB3aWRlIHdpdGggY3VycmVudCBhc3BlY3QgcmF0aW8gKi8KICAgICAgICAgICAgYm94SGVpZ2h0ID0gTWF0aC5mbG9vcihib3hIZWlnaHQgLyB3aWR0aEZyYWN0aW9uKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoYm94SGVpZ2h0IC8gdGhpcy5fb3B0aW9ucy5zcGFjaW5nKTsKICAgIH07CgogICAgUk9ULkRpc3BsYXkuUmVjdC5wcm90b3R5cGUuZXZlbnRUb1Bvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSkKICAgIHsKICAgICAgICByZXR1cm4gW01hdGguZmxvb3IoeCAvIHRoaXMuX3NwYWNpbmdYKSwgTWF0aC5mbG9vcih5IC8gdGhpcy5fc3BhY2luZ1kpXTsKICAgIH07CiAgICAvKioKICAgICAqIEBjbGFzcyBIZXhhZ29uYWwgYmFja2VuZAogICAgICogQHByaXZhdGUKICAgICAqLwogICAgUk9ULkRpc3BsYXkuSGV4ID0gZnVuY3Rpb24oY29udGV4dCkKICAgIHsKICAgICAgICBST1QuRGlzcGxheS5CYWNrZW5kLmNhbGwodGhpcywgY29udGV4dCk7CgogICAgICAgIHRoaXMuX3NwYWNpbmdYID0gMDsKICAgICAgICB0aGlzLl9zcGFjaW5nWSA9IDA7CiAgICAgICAgdGhpcy5faGV4U2l6ZSA9IDA7CiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHt9OwogICAgfTsKICAgIFJPVC5EaXNwbGF5LkhleC5leHRlbmQoUk9ULkRpc3BsYXkuQmFja2VuZCk7CgogICAgUk9ULkRpc3BsYXkuSGV4LnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24ob3B0aW9ucykKICAgIHsKICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uczsKCiAgICAgICAgLyogRklYTUUgY2hhciBzaXplIGNvbXB1dGF0aW9uIGRvZXMgbm90IHJlc3BlY3QgdHJhbnNwb3NlZCBoZXhlcyAqLwogICAgICAgIHZhciBjaGFyV2lkdGggPSBNYXRoLmNlaWwodGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dCgiVyIpLndpZHRoKTsKICAgICAgICB0aGlzLl9oZXhTaXplID0gTWF0aC5mbG9vcihvcHRpb25zLnNwYWNpbmcgKiAob3B0aW9ucy5mb250U2l6ZSArIGNoYXJXaWR0aCAvIE1hdGguc3FydCgzKSkgLyAyKTsKICAgICAgICB0aGlzLl9zcGFjaW5nWCA9IHRoaXMuX2hleFNpemUgKiBNYXRoLnNxcnQoMykgLyAyOwogICAgICAgIHRoaXMuX3NwYWNpbmdZID0gdGhpcy5faGV4U2l6ZSAqIDEuNTsKCiAgICAgICAgaWYgKG9wdGlvbnMudHJhbnNwb3NlKQogICAgICAgIHsKICAgICAgICAgICAgdmFyIHhwcm9wID0gImhlaWdodCI7CiAgICAgICAgICAgIHZhciB5cHJvcCA9ICJ3aWR0aCI7CiAgICAgICAgfQogICAgICAgIGVsc2UKICAgICAgICB7CiAgICAgICAgICAgIHZhciB4cHJvcCA9ICJ3aWR0aCI7CiAgICAgICAgICAgIHZhciB5cHJvcCA9ICJoZWlnaHQiOwogICAgICAgIH0KICAgICAgICB0aGlzLl9jb250ZXh0LmNhbnZhc1t4cHJvcF0gPSBNYXRoLmNlaWwoKG9wdGlvbnMud2lkdGggKyAxKSAqIHRoaXMuX3NwYWNpbmdYKTsKICAgICAgICB0aGlzLl9jb250ZXh0LmNhbnZhc1t5cHJvcF0gPSBNYXRoLmNlaWwoKG9wdGlvbnMuaGVpZ2h0IC0gMSkgKiB0aGlzLl9zcGFjaW5nWSArIDIgKiB0aGlzLl9oZXhTaXplKTsKICAgIH07CgogICAgUk9ULkRpc3BsYXkuSGV4LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZGF0YSwgY2xlYXJCZWZvcmUpCiAgICB7CiAgICAgICAgdmFyIHggPSBkYXRhWzBdOwogICAgICAgIHZhciB5ID0gZGF0YVsxXTsKICAgICAgICB2YXIgY2ggPSBkYXRhWzJdOwogICAgICAgIHZhciBmZyA9IGRhdGFbM107CiAgICAgICAgdmFyIGJnID0gZGF0YVs0XTsKCiAgICAgICAgdmFyIHB4ID0gWwogICAgICAgICh4ICsgMSkgKiB0aGlzLl9zcGFjaW5nWCwKICAgICAgICB5ICogdGhpcy5fc3BhY2luZ1kgKyB0aGlzLl9oZXhTaXplCiAgICBdOwogICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnRyYW5zcG9zZSkKICAgICAgICB7CiAgICAgICAgICAgIHB4LnJldmVyc2UoKTsKICAgICAgICB9CgogICAgICAgIGlmIChjbGVhckJlZm9yZSkKICAgICAgICB7CiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlID0gYmc7CiAgICAgICAgICAgIHRoaXMuX2ZpbGwocHhbMF0sIHB4WzFdKTsKICAgICAgICB9CgogICAgICAgIGlmICghY2gpCiAgICAgICAgewogICAgICAgICAgICByZXR1cm47CiAgICAgICAgfQoKICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxTdHlsZSA9IGZnOwoKICAgICAgICB2YXIgY2hhcnMgPSBbXS5jb25jYXQoY2gpOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspCiAgICAgICAgewogICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxUZXh0KGNoYXJzW2ldLCBweFswXSwgTWF0aC5jZWlsKHB4WzFdKSk7CiAgICAgICAgfQogICAgfTsKCiAgICBST1QuRGlzcGxheS5IZXgucHJvdG90eXBlLmNvbXB1dGVTaXplID0gZnVuY3Rpb24oYXZhaWxXaWR0aCwgYXZhaWxIZWlnaHQpCiAgICB7CiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMudHJhbnNwb3NlKQogICAgICAgIHsKICAgICAgICAgICAgYXZhaWxXaWR0aCArPSBhdmFpbEhlaWdodDsKICAgICAgICAgICAgYXZhaWxIZWlnaHQgPSBhdmFpbFdpZHRoIC0gYXZhaWxIZWlnaHQ7CiAgICAgICAgICAgIGF2YWlsV2lkdGggLT0gYXZhaWxIZWlnaHQ7CiAgICAgICAgfQoKICAgICAgICB2YXIgd2lkdGggPSBNYXRoLmZsb29yKGF2YWlsV2lkdGggLyB0aGlzLl9zcGFjaW5nWCkgLSAxOwogICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLmZsb29yKChhdmFpbEhlaWdodCAtIDIgKiB0aGlzLl9oZXhTaXplKSAvIHRoaXMuX3NwYWNpbmdZICsgMSk7CiAgICAgICAgcmV0dXJuIFt3aWR0aCwgaGVpZ2h0XTsKICAgIH07CgogICAgUk9ULkRpc3BsYXkuSGV4LnByb3RvdHlwZS5jb21wdXRlRm9udFNpemUgPSBmdW5jdGlvbihhdmFpbFdpZHRoLCBhdmFpbEhlaWdodCkKICAgIHsKICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy50cmFuc3Bvc2UpCiAgICAgICAgewogICAgICAgICAgICBhdmFpbFdpZHRoICs9IGF2YWlsSGVpZ2h0OwogICAgICAgICAgICBhdmFpbEhlaWdodCA9IGF2YWlsV2lkdGggLSBhdmFpbEhlaWdodDsKICAgICAgICAgICAgYXZhaWxXaWR0aCAtPSBhdmFpbEhlaWdodDsKICAgICAgICB9CgogICAgICAgIHZhciBoZXhTaXplV2lkdGggPSAyICogYXZhaWxXaWR0aCAvICgodGhpcy5fb3B0aW9ucy53aWR0aCArIDEpICogTWF0aC5zcXJ0KDMpKSAtIDE7CiAgICAgICAgdmFyIGhleFNpemVIZWlnaHQgPSBhdmFpbEhlaWdodCAvICgyICsgMS41ICogKHRoaXMuX29wdGlvbnMuaGVpZ2h0IC0gMSkpOwogICAgICAgIHZhciBoZXhTaXplID0gTWF0aC5taW4oaGV4U2l6ZVdpZHRoLCBoZXhTaXplSGVpZ2h0KTsKCiAgICAgICAgLyogY29tcHV0ZSBjaGFyIHJhdGlvICovCiAgICAgICAgdmFyIG9sZEZvbnQgPSB0aGlzLl9jb250ZXh0LmZvbnQ7CiAgICAgICAgdGhpcy5fY29udGV4dC5mb250ID0gIjEwMHB4ICIgKyB0aGlzLl9vcHRpb25zLmZvbnRGYW1pbHk7CiAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5jZWlsKHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQoIlciKS53aWR0aCk7CiAgICAgICAgdGhpcy5fY29udGV4dC5mb250ID0gb2xkRm9udDsKICAgICAgICB2YXIgcmF0aW8gPSB3aWR0aCAvIDEwMDsKCiAgICAgICAgaGV4U2l6ZSA9IE1hdGguZmxvb3IoaGV4U2l6ZSkgKyAxOyAvKiBjbG9zZXN0IGxhcmdlciBoZXhTaXplICovCgogICAgICAgIC8qIEZJWE1FIGNoYXIgc2l6ZSBjb21wdXRhdGlvbiBkb2VzIG5vdCByZXNwZWN0IHRyYW5zcG9zZWQgaGV4ZXMgKi8KICAgICAgICB2YXIgZm9udFNpemUgPSAyICogaGV4U2l6ZSAvICh0aGlzLl9vcHRpb25zLnNwYWNpbmcgKiAoMSArIHJhdGlvIC8gTWF0aC5zcXJ0KDMpKSk7CgogICAgICAgIC8qIGNsb3Nlc3Qgc21hbGxlciBmb250U2l6ZSAqLwogICAgICAgIHJldHVybiBNYXRoLmNlaWwoZm9udFNpemUpIC0gMTsKICAgIH07CgogICAgUk9ULkRpc3BsYXkuSGV4LnByb3RvdHlwZS5ldmVudFRvUG9zaXRpb24gPSBmdW5jdGlvbih4LCB5KQogICAgewogICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnRyYW5zcG9zZSkKICAgICAgICB7CiAgICAgICAgICAgIHggKz0geTsKICAgICAgICAgICAgeSA9IHggLSB5OwogICAgICAgICAgICB4IC09IHk7CiAgICAgICAgICAgIHZhciBub2RlU2l6ZSA9IHRoaXMuX2NvbnRleHQuY2FudmFzLndpZHRoOwogICAgICAgIH0KICAgICAgICBlbHNlCiAgICAgICAgewogICAgICAgICAgICB2YXIgbm9kZVNpemUgPSB0aGlzLl9jb250ZXh0LmNhbnZhcy5oZWlnaHQ7CiAgICAgICAgfQogICAgICAgIHZhciBzaXplID0gbm9kZVNpemUgLyB0aGlzLl9vcHRpb25zLmhlaWdodDsKICAgICAgICB5ID0gTWF0aC5mbG9vcih5IC8gc2l6ZSk7CgogICAgICAgIGlmICh5Lm1vZCgyKSkKICAgICAgICB7IC8qIG9kZCByb3cgKi8KICAgICAgICAgICAgeCAtPSB0aGlzLl9zcGFjaW5nWDsKICAgICAgICAgICAgeCA9IDEgKyAyICogTWF0aC5mbG9vcih4IC8gKDIgKiB0aGlzLl9zcGFjaW5nWCkpOwogICAgICAgIH0KICAgICAgICBlbHNlCiAgICAgICAgewogICAgICAgICAgICB4ID0gMiAqIE1hdGguZmxvb3IoeCAvICgyICogdGhpcy5fc3BhY2luZ1gpKTsKICAgICAgICB9CgogICAgICAgIHJldHVybiBbeCwgeV07CiAgICB9OwoKICAgIC8qKgogICAgICogQXJndW1lbnRzIGFyZSBwaXhlbCB2YWx1ZXMuIElmICJ0cmFuc3Bvc2VkIiBtb2RlIGlzIGVuYWJsZWQsIHRoZW4gdGhlc2UgdHdvIGFyZSBhbHJlYWR5IHN3YXBwZWQuCiAgICAgKi8KICAgIFJPVC5EaXNwbGF5LkhleC5wcm90b3R5cGUuX2ZpbGwgPSBmdW5jdGlvbihjeCwgY3kpCiAgICB7CiAgICAgICAgdmFyIGEgPSB0aGlzLl9oZXhTaXplOwogICAgICAgIHZhciBiID0gdGhpcy5fb3B0aW9ucy5ib3JkZXI7CgogICAgICAgIHRoaXMuX2NvbnRleHQuYmVnaW5QYXRoKCk7CgogICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnRyYW5zcG9zZSkKICAgICAgICB7CiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKGN4IC0gYSArIGIsIGN5KTsKICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oY3ggLSBhIC8gMiArIGIsIGN5ICsgdGhpcy5fc3BhY2luZ1ggLSBiKTsKICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oY3ggKyBhIC8gMiAtIGIsIGN5ICsgdGhpcy5fc3BhY2luZ1ggLSBiKTsKICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oY3ggKyBhIC0gYiwgY3kpOwogICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyhjeCArIGEgLyAyIC0gYiwgY3kgLSB0aGlzLl9zcGFjaW5nWCArIGIpOwogICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyhjeCAtIGEgLyAyICsgYiwgY3kgLSB0aGlzLl9zcGFjaW5nWCArIGIpOwogICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyhjeCAtIGEgKyBiLCBjeSk7CiAgICAgICAgfQogICAgICAgIGVsc2UKICAgICAgICB7CiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKGN4LCBjeSAtIGEgKyBiKTsKICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oY3ggKyB0aGlzLl9zcGFjaW5nWCAtIGIsIGN5IC0gYSAvIDIgKyBiKTsKICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oY3ggKyB0aGlzLl9zcGFjaW5nWCAtIGIsIGN5ICsgYSAvIDIgLSBiKTsKICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oY3gsIGN5ICsgYSAtIGIpOwogICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyhjeCAtIHRoaXMuX3NwYWNpbmdYICsgYiwgY3kgKyBhIC8gMiAtIGIpOwogICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyhjeCAtIHRoaXMuX3NwYWNpbmdYICsgYiwgY3kgLSBhIC8gMiArIGIpOwogICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyhjeCwgY3kgLSBhICsgYik7CiAgICAgICAgfQogICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbCgpOwogICAgfTsKICAgIC8qKgogICAgICogQGNsYXNzIFRpbGUgYmFja2VuZAogICAgICogQHByaXZhdGUKICAgICAqLwogICAgUk9ULkRpc3BsYXkuVGlsZSA9IGZ1bmN0aW9uKGNvbnRleHQpCiAgICB7CiAgICAgICAgUk9ULkRpc3BsYXkuUmVjdC5jYWxsKHRoaXMsIGNvbnRleHQpOwoKICAgICAgICB0aGlzLl9vcHRpb25zID0ge307CiAgICAgICAgdGhpcy5fY29sb3JDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKTsKICAgIH07CiAgICBST1QuRGlzcGxheS5UaWxlLmV4dGVuZChST1QuRGlzcGxheS5SZWN0KTsKCiAgICBST1QuRGlzcGxheS5UaWxlLnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24ob3B0aW9ucykKICAgIHsKICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uczsKICAgICAgICB0aGlzLl9jb250ZXh0LmNhbnZhcy53aWR0aCA9IG9wdGlvbnMud2lkdGggKiBvcHRpb25zLnRpbGVXaWR0aDsKICAgICAgICB0aGlzLl9jb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCAqIG9wdGlvbnMudGlsZUhlaWdodDsKICAgICAgICB0aGlzLl9jb2xvckNhbnZhcy53aWR0aCA9IG9wdGlvbnMudGlsZVdpZHRoOwogICAgICAgIHRoaXMuX2NvbG9yQ2FudmFzLmhlaWdodCA9IG9wdGlvbnMudGlsZUhlaWdodDsKICAgIH07CgogICAgUk9ULkRpc3BsYXkuVGlsZS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGRhdGEsIGNsZWFyQmVmb3JlKQogICAgewogICAgICAgIHZhciB4ID0gZGF0YVswXTsKICAgICAgICB2YXIgeSA9IGRhdGFbMV07CiAgICAgICAgdmFyIGNoID0gZGF0YVsyXTsKICAgICAgICB2YXIgZmcgPSBkYXRhWzNdOwogICAgICAgIHZhciBiZyA9IGRhdGFbNF07CgogICAgICAgIHZhciB0aWxlV2lkdGggPSB0aGlzLl9vcHRpb25zLnRpbGVXaWR0aDsKICAgICAgICB2YXIgdGlsZUhlaWdodCA9IHRoaXMuX29wdGlvbnMudGlsZUhlaWdodDsKCiAgICAgICAgaWYgKGNsZWFyQmVmb3JlKQogICAgICAgIHsKICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMudGlsZUNvbG9yaXplKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmNsZWFyUmVjdCh4ICogdGlsZVdpZHRoLCB5ICogdGlsZUhlaWdodCwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlID0gYmc7CiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxSZWN0KHggKiB0aWxlV2lkdGgsIHkgKiB0aWxlSGVpZ2h0LCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQpOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAoIWNoKQogICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgdmFyIGNoYXJzID0gW10uY29uY2F0KGNoKTsKICAgICAgICB2YXIgZmdzID0gW10uY29uY2F0KGZnKTsKICAgICAgICB2YXIgYmdzID0gW10uY29uY2F0KGJnKTsKCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykKICAgICAgICB7CiAgICAgICAgICAgIHZhciB0aWxlID0gdGhpcy5fb3B0aW9ucy50aWxlTWFwW2NoYXJzW2ldXTsKICAgICAgICAgICAgaWYgKCF0aWxlKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkNoYXIgJyIgKyBjaGFyc1tpXSArICInIG5vdCBmb3VuZCBpbiB0aWxlTWFwIik7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnRpbGVDb2xvcml6ZSkKICAgICAgICAgICAgeyAvKiBhcHBseSBjb2xvcml6YXRpb24gKi8KICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9jb2xvckNhbnZhczsKICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoIjJkIik7CiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICJzb3VyY2Utb3ZlciI7CiAgICAgICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQpOwoKICAgICAgICAgICAgICAgIHZhciBmZyA9IGZnc1tpXTsKICAgICAgICAgICAgICAgIHZhciBiZyA9IGJnc1tpXTsKCiAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSgKICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMudGlsZVNldCwKICAgICAgICAgICAgICAgIHRpbGVbMF0sIHRpbGVbMV0sIHRpbGVXaWR0aCwgdGlsZUhlaWdodCwKICAgICAgICAgICAgICAgIDAsIDAsIHRpbGVXaWR0aCwgdGlsZUhlaWdodCk7CgogICAgICAgICAgICAgICAgaWYgKGZnICE9ICJ0cmFuc3BhcmVudCIpCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBmZzsKICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICJzb3VyY2UtYXRvcCI7CiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQpOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGlmIChiZyAhPSAidHJhbnNwYXJlbnQiKQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gYmc7CiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAiZGVzdGluYXRpb24tb3ZlciI7CiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQpOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZHJhd0ltYWdlKGNhbnZhcywgeCAqIHRpbGVXaWR0aCwgeSAqIHRpbGVIZWlnaHQsIHRpbGVXaWR0aCwgdGlsZUhlaWdodCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZQogICAgICAgICAgICB7IC8qIG5vIGNvbG9yaXppbmcsIGVhc3kgKi8KICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZHJhd0ltYWdlKAogICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy50aWxlU2V0LAogICAgICAgICAgICAgICAgdGlsZVswXSwgdGlsZVsxXSwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0LAogICAgICAgICAgICAgICAgeCAqIHRpbGVXaWR0aCwgeSAqIHRpbGVIZWlnaHQsIHRpbGVXaWR0aCwgdGlsZUhlaWdodCk7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9OwoKICAgIFJPVC5EaXNwbGF5LlRpbGUucHJvdG90eXBlLmNvbXB1dGVTaXplID0gZnVuY3Rpb24oYXZhaWxXaWR0aCwgYXZhaWxIZWlnaHQpCiAgICB7CiAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5mbG9vcihhdmFpbFdpZHRoIC8gdGhpcy5fb3B0aW9ucy50aWxlV2lkdGgpOwogICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLmZsb29yKGF2YWlsSGVpZ2h0IC8gdGhpcy5fb3B0aW9ucy50aWxlSGVpZ2h0KTsKICAgICAgICByZXR1cm4gW3dpZHRoLCBoZWlnaHRdOwogICAgfTsKCiAgICBST1QuRGlzcGxheS5UaWxlLnByb3RvdHlwZS5jb21wdXRlRm9udFNpemUgPSBmdW5jdGlvbihhdmFpbFdpZHRoLCBhdmFpbEhlaWdodCkKICAgIHsKICAgICAgICB2YXIgd2lkdGggPSBNYXRoLmZsb29yKGF2YWlsV2lkdGggLyB0aGlzLl9vcHRpb25zLndpZHRoKTsKICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5mbG9vcihhdmFpbEhlaWdodCAvIHRoaXMuX29wdGlvbnMuaGVpZ2h0KTsKICAgICAgICByZXR1cm4gW3dpZHRoLCBoZWlnaHRdOwogICAgfTsKCiAgICBST1QuRGlzcGxheS5UaWxlLnByb3RvdHlwZS5ldmVudFRvUG9zaXRpb24gPSBmdW5jdGlvbih4LCB5KQogICAgewogICAgICAgIHJldHVybiBbTWF0aC5mbG9vcih4IC8gdGhpcy5fb3B0aW9ucy50aWxlV2lkdGgpLCBNYXRoLmZsb29yKHkgLyB0aGlzLl9vcHRpb25zLnRpbGVIZWlnaHQpXTsKICAgIH07CiAgICAvKioKICAgICAqIEBuYW1lc3BhY2UKICAgICAqIFRoaXMgY29kZSBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBBbGVhIGFsZ29yaXRobTsgKEMpIDIwMTAgSm9oYW5uZXMgQmFhZz9lLgogICAgICogQWxlYSBpcyBsaWNlbnNlZCBhY2NvcmRpbmcgdG8gdGhlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UuCiAgICAgKi8KICAgIFJPVC5STkcgPSB7CiAgICAgICAgLyoqCiAgICAgICAgICogQHJldHVybnMge251bWJlcn0KICAgICAgICAgKi8KICAgICAgICBnZXRTZWVkOiBmdW5jdGlvbigpCiAgICAgICAgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VlZDsKICAgICAgICB9LAoKICAgICAgICAvKioKICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2VlZCBTZWVkIHRoZSBudW1iZXIgZ2VuZXJhdG9yCiAgICAgICAgICovCiAgICAgICAgc2V0U2VlZDogZnVuY3Rpb24oc2VlZCkKICAgICAgICB7CiAgICAgICAgICAgIHNlZWQgPSAoc2VlZCA8IDEgPyAxIC8gc2VlZCA6IHNlZWQpOwoKICAgICAgICAgICAgdGhpcy5fc2VlZCA9IHNlZWQ7CiAgICAgICAgICAgIHRoaXMuX3MwID0gKHNlZWQgPj4+IDApICogdGhpcy5fZnJhYzsKCiAgICAgICAgICAgIHNlZWQgPSAoc2VlZCAqIDY5MDY5ICsgMSkgPj4+IDA7CiAgICAgICAgICAgIHRoaXMuX3MxID0gc2VlZCAqIHRoaXMuX2ZyYWM7CgogICAgICAgICAgICBzZWVkID0gKHNlZWQgKiA2OTA2OSArIDEpID4+PiAwOwogICAgICAgICAgICB0aGlzLl9zMiA9IHNlZWQgKiB0aGlzLl9mcmFjOwoKICAgICAgICAgICAgdGhpcy5fYyA9IDE7CiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0sCgogICAgICAgIC8qKgogICAgICAgICAqIEByZXR1cm5zIHtmbG9hdH0gUHNldWRvcmFuZG9tIHZhbHVlIFswLDEpLCB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQKICAgICAgICAgKi8KICAgICAgICBnZXRVbmlmb3JtOiBmdW5jdGlvbigpCiAgICAgICAgewogICAgICAgICAgICB2YXIgdCA9IDIwOTE2MzkgKiB0aGlzLl9zMCArIHRoaXMuX2MgKiB0aGlzLl9mcmFjOwogICAgICAgICAgICB0aGlzLl9zMCA9IHRoaXMuX3MxOwogICAgICAgICAgICB0aGlzLl9zMSA9IHRoaXMuX3MyOwogICAgICAgICAgICB0aGlzLl9jID0gdCB8IDA7CiAgICAgICAgICAgIHRoaXMuX3MyID0gdCAtIHRoaXMuX2M7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zMjsKICAgICAgICB9LAoKICAgICAgICAvKioKICAgICAgICAgKiBAcGFyYW0ge2ludH0gbG93ZXJCb3VuZCBUaGUgbG93ZXIgZW5kIG9mIHRoZSByYW5nZSB0byByZXR1cm4gYSB2YWx1ZSBmcm9tLCBpbmNsdXNpdmUKICAgICAgICAgKiBAcGFyYW0ge2ludH0gdXBwZXJCb3VuZCBUaGUgdXBwZXIgZW5kIG9mIHRoZSByYW5nZSB0byByZXR1cm4gYSB2YWx1ZSBmcm9tLCBpbmNsdXNpdmUKICAgICAgICAgKiBAcmV0dXJucyB7aW50fSBQc2V1ZG9yYW5kb20gdmFsdWUgW2xvd2VyQm91bmQsIHVwcGVyQm91bmRdLCB1c2luZyBST1QuUk5HLmdldFVuaWZvcm0oKSB0byBkaXN0cmlidXRlIHRoZSB2YWx1ZQogICAgICAgICAqLwogICAgICAgIGdldFVuaWZvcm1JbnQ6IGZ1bmN0aW9uKGxvd2VyQm91bmQsIHVwcGVyQm91bmQpCiAgICAgICAgewogICAgICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgobG93ZXJCb3VuZCwgdXBwZXJCb3VuZCk7CiAgICAgICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihsb3dlckJvdW5kLCB1cHBlckJvdW5kKTsKICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5nZXRVbmlmb3JtKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluOwogICAgICAgIH0sCgogICAgICAgIC8qKgogICAgICAgICAqIEBwYXJhbSB7ZmxvYXR9IFttZWFuPTBdIE1lYW4gdmFsdWUKICAgICAgICAgKiBAcGFyYW0ge2Zsb2F0fSBbc3RkZGV2PTFdIFN0YW5kYXJkIGRldmlhdGlvbi4gfjk1JSBvZiB0aGUgYWJzb2x1dGUgdmFsdWVzIHdpbGwgYmUgbG93ZXIgdGhhbiAyKnN0ZGRldi4KICAgICAgICAgKiBAcmV0dXJucyB7ZmxvYXR9IEEgbm9ybWFsbHkgZGlzdHJpYnV0ZWQgcHNldWRvcmFuZG9tIHZhbHVlCiAgICAgICAgICovCiAgICAgICAgZ2V0Tm9ybWFsOiBmdW5jdGlvbihtZWFuLCBzdGRkZXYpCiAgICAgICAgewogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICB2YXIgdSA9IDIgKiB0aGlzLmdldFVuaWZvcm0oKSAtIDE7CiAgICAgICAgICAgICAgICB2YXIgdiA9IDIgKiB0aGlzLmdldFVuaWZvcm0oKSAtIDE7CiAgICAgICAgICAgICAgICB2YXIgciA9IHUgKiB1ICsgdiAqIHY7CiAgICAgICAgICAgIH0gd2hpbGUgKHIgPiAxIHx8IHIgPT0gMCk7CgogICAgICAgICAgICB2YXIgZ2F1c3MgPSB1ICogTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocikgLyByKTsKICAgICAgICAgICAgcmV0dXJuIChtZWFuIHx8IDApICsgZ2F1c3MgKiAoc3RkZGV2IHx8IDEpOwogICAgICAgIH0sCgogICAgICAgIC8qKgogICAgICAgICAqIEByZXR1cm5zIHtpbnR9IFBzZXVkb3JhbmRvbSB2YWx1ZSBbMSwxMDBdIGluY2x1c2l2ZSwgdW5pZm9ybWx5IGRpc3RyaWJ1dGVkCiAgICAgICAgICovCiAgICAgICAgZ2V0UGVyY2VudGFnZTogZnVuY3Rpb24oKQogICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuIDEgKyBNYXRoLmZsb29yKHRoaXMuZ2V0VW5pZm9ybSgpICogMTAwKTsKICAgICAgICB9LAoKICAgICAgICAvKioKICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBrZXk9d2hhdGV2ZXIsIHZhbHVlPXdlaWdodCAocmVsYXRpdmUgcHJvYmFiaWxpdHkpCiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gd2hhdGV2ZXIKICAgICAgICAgKi8KICAgICAgICBnZXRXZWlnaHRlZFZhbHVlOiBmdW5jdGlvbihkYXRhKQogICAgICAgIHsKICAgICAgICAgICAgdmFyIHRvdGFsID0gMDsKCiAgICAgICAgICAgIGZvciAodmFyIGlkIGluIGRhdGEpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHRvdGFsICs9IGRhdGFbaWRdOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciByYW5kb20gPSB0aGlzLmdldFVuaWZvcm0oKSAqIHRvdGFsOwoKICAgICAgICAgICAgdmFyIHBhcnQgPSAwOwogICAgICAgICAgICBmb3IgKHZhciBpZCBpbiBkYXRhKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBwYXJ0ICs9IGRhdGFbaWRdOwogICAgICAgICAgICAgICAgaWYgKHJhbmRvbSA8IHBhcnQpCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICAvLyBJZiBieSBzb21lIGZsb2F0aW5nLXBvaW50IGFubm95YW5jZSB3ZSBoYXZlCiAgICAgICAgICAgIC8vIHJhbmRvbSA+PSB0b3RhbCwganVzdCByZXR1cm4gdGhlIGxhc3QgaWQuCiAgICAgICAgICAgIHJldHVybiBpZDsKICAgICAgICB9LAoKICAgICAgICAvKioKICAgICAgICAgKiBHZXQgUk5HIHN0YXRlLiBVc2VmdWwgZm9yIHN0b3JpbmcgdGhlIHN0YXRlIGFuZCByZS1zZXR0aW5nIGl0IHZpYSBzZXRTdGF0ZS4KICAgICAgICAgKiBAcmV0dXJucyB7P30gSW50ZXJuYWwgc3RhdGUKICAgICAgICAgKi8KICAgICAgICBnZXRTdGF0ZTogZnVuY3Rpb24oKQogICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuIFt0aGlzLl9zMCwgdGhpcy5fczEsIHRoaXMuX3MyLCB0aGlzLl9jXTsKICAgICAgICB9LAoKICAgICAgICAvKioKICAgICAgICAgKiBTZXQgYSBwcmV2aW91c2x5IHJldHJpZXZlZCBzdGF0ZS4KICAgICAgICAgKiBAcGFyYW0gez99IHN0YXRlCiAgICAgICAgICovCiAgICAgICAgc2V0U3RhdGU6IGZ1bmN0aW9uKHN0YXRlKQogICAgICAgIHsKICAgICAgICAgICAgdGhpcy5fczAgPSBzdGF0ZVswXTsKICAgICAgICAgICAgdGhpcy5fczEgPSBzdGF0ZVsxXTsKICAgICAgICAgICAgdGhpcy5fczIgPSBzdGF0ZVsyXTsKICAgICAgICAgICAgdGhpcy5fYyA9IHN0YXRlWzNdOwogICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9LAoKICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIGEgY2xvbmVkIFJORwogICAgICAgICAqLwogICAgICAgIGNsb25lOiBmdW5jdGlvbigpCiAgICAgICAgewogICAgICAgICAgICB2YXIgY2xvbmUgPSBPYmplY3QuY3JlYXRlKHRoaXMpOwogICAgICAgICAgICBjbG9uZS5zZXRTdGF0ZSh0aGlzLmdldFN0YXRlKCkpOwogICAgICAgICAgICByZXR1cm4gY2xvbmU7CiAgICAgICAgfSwKCiAgICAgICAgX3MwOiAwLAogICAgICAgIF9zMTogMCwKICAgICAgICBfczI6IDAsCiAgICAgICAgX2M6IDAsCiAgICAgICAgX2ZyYWM6IDIuMzI4MzA2NDM2NTM4Njk2M2UtMTAgLyogMl4tMzIgKi8KICAgIH07CgogICAgUk9ULlJORy5zZXRTZWVkKERhdGUubm93KCkpOwogICAgLyoqCiAgICAgKiBAY2xhc3MgKE1hcmtvdiBwcm9jZXNzKS1iYXNlZCBzdHJpbmcgZ2VuZXJhdG9yLgogICAgICogQ29waWVkIGZyb20gYSA8YSBocmVmPSJodHRwOi8vd3d3LnJvZ3VlYmFzaW4ucm9ndWVsaWtlZGV2ZWxvcG1lbnQub3JnL2luZGV4LnBocD90aXRsZT1OYW1lc19mcm9tX2FfaGlnaF9vcmRlcl9NYXJrb3ZfUHJvY2Vzc19hbmRfYV9zaW1wbGlmaWVkX0thdHpfYmFjay1vZmZfc2NoZW1lIj5Sb2d1ZUJhc2luIGFydGljbGU8L2E+LgogICAgICogT2ZmZXJzIGNvbmZpZ3VyYWJsZSBvcmRlciBhbmQgcHJpb3IuCiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdCiAgICAgKiBAcGFyYW0ge2Jvb2x9IFtvcHRpb25zLndvcmRzPWZhbHNlXSBVc2Ugd29yZCBtb2RlPwogICAgICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLm9yZGVyPTNdCiAgICAgKiBAcGFyYW0ge2Zsb2F0fSBbb3B0aW9ucy5wcmlvcj0wLjAwMV0KICAgICAqLwogICAgUk9ULlN0cmluZ0dlbmVyYXRvciA9IGZ1bmN0aW9uKG9wdGlvbnMpCiAgICB7CiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHsKICAgICAgICAgICAgd29yZHM6IGZhbHNlLAogICAgICAgICAgICBvcmRlcjogMywKICAgICAgICAgICAgcHJpb3I6IDAuMDAxCiAgICAgICAgfTsKICAgICAgICBmb3IgKHZhciBwIGluIG9wdGlvbnMpCiAgICAgICAgewogICAgICAgICAgICB0aGlzLl9vcHRpb25zW3BdID0gb3B0aW9uc1twXTsKICAgICAgICB9CgogICAgICAgIHRoaXMuX2JvdW5kYXJ5ID0gU3RyaW5nLmZyb21DaGFyQ29kZSgwKTsKICAgICAgICB0aGlzLl9zdWZmaXggPSB0aGlzLl9ib3VuZGFyeTsKICAgICAgICB0aGlzLl9wcmVmaXggPSBbXTsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX29wdGlvbnMub3JkZXI7IGkrKykKICAgICAgICB7CiAgICAgICAgICAgIHRoaXMuX3ByZWZpeC5wdXNoKHRoaXMuX2JvdW5kYXJ5KTsKICAgICAgICB9CgogICAgICAgIHRoaXMuX3ByaW9yVmFsdWVzID0ge307CiAgICAgICAgdGhpcy5fcHJpb3JWYWx1ZXNbdGhpcy5fYm91bmRhcnldID0gdGhpcy5fb3B0aW9ucy5wcmlvcjsKCiAgICAgICAgdGhpcy5fZGF0YSA9IHt9OwogICAgfTsKCiAgICAvKioKICAgICAqIFJlbW92ZSBhbGwgbGVhcm5pbmcgZGF0YQogICAgICovCiAgICBST1QuU3RyaW5nR2VuZXJhdG9yLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkKICAgIHsKICAgICAgICB0aGlzLl9kYXRhID0ge307CiAgICAgICAgdGhpcy5fcHJpb3JWYWx1ZXMgPSB7fTsKICAgIH07CgogICAgLyoqCiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBHZW5lcmF0ZWQgc3RyaW5nCiAgICAgKi8KICAgIFJPVC5TdHJpbmdHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24oKQogICAgewogICAgICAgIHZhciByZXN1bHQgPSBbdGhpcy5fc2FtcGxlKHRoaXMuX3ByZWZpeCldOwogICAgICAgIHdoaWxlIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdICE9IHRoaXMuX2JvdW5kYXJ5KQogICAgICAgIHsKICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5fc2FtcGxlKHJlc3VsdCkpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpcy5fam9pbihyZXN1bHQuc2xpY2UoMCwgLTEpKTsKICAgIH07CgogICAgLyoqCiAgICAgKiBPYnNlcnZlIChsZWFybikgYSBzdHJpbmcgZnJvbSBhIHRyYWluaW5nIHNldAogICAgICovCiAgICBST1QuU3RyaW5nR2VuZXJhdG9yLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24oc3RyaW5nKQogICAgewogICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLl9zcGxpdChzdHJpbmcpOwoKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykKICAgICAgICB7CiAgICAgICAgICAgIHRoaXMuX3ByaW9yVmFsdWVzW3Rva2Vuc1tpXV0gPSB0aGlzLl9vcHRpb25zLnByaW9yOwogICAgICAgIH0KCiAgICAgICAgdG9rZW5zID0gdGhpcy5fcHJlZml4LmNvbmNhdCh0b2tlbnMpLmNvbmNhdCh0aGlzLl9zdWZmaXgpOyAvKiBhZGQgYm91bmRhcnkgc3ltYm9scyAqLwoKICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fb3B0aW9ucy5vcmRlcjsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykKICAgICAgICB7CiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdG9rZW5zLnNsaWNlKGkgLSB0aGlzLl9vcHRpb25zLm9yZGVyLCBpKTsKICAgICAgICAgICAgdmFyIGV2ZW50ID0gdG9rZW5zW2ldOwogICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbnRleHQubGVuZ3RoOyBqKyspCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHZhciBzdWJjb250ZXh0ID0gY29udGV4dC5zbGljZShqKTsKICAgICAgICAgICAgICAgIHRoaXMuX29ic2VydmVFdmVudChzdWJjb250ZXh0LCBldmVudCk7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9OwoKICAgIFJPVC5TdHJpbmdHZW5lcmF0b3IucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24oKQogICAgewogICAgICAgIHZhciBwYXJ0cyA9IFtdOwoKICAgICAgICB2YXIgcHJpb3JDb3VudCA9IDA7CiAgICAgICAgZm9yICh2YXIgcCBpbiB0aGlzLl9wcmlvclZhbHVlcykKICAgICAgICB7CiAgICAgICAgICAgIHByaW9yQ291bnQrKzsKICAgICAgICB9CiAgICAgICAgcHJpb3JDb3VudC0tOyAvKiBib3VuZGFyeSAqLwogICAgICAgIHBhcnRzLnB1c2goImRpc3RpbmN0IHNhbXBsZXM6ICIgKyBwcmlvckNvdW50KTsKCiAgICAgICAgdmFyIGRhdGFDb3VudCA9IDA7CiAgICAgICAgdmFyIGV2ZW50Q291bnQgPSAwOwogICAgICAgIGZvciAodmFyIHAgaW4gdGhpcy5fZGF0YSkKICAgICAgICB7CiAgICAgICAgICAgIGRhdGFDb3VudCsrOwogICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fZGF0YVtwXSkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgZXZlbnRDb3VudCsrOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHBhcnRzLnB1c2goImRpY3Rpb25hcnkgc2l6ZSAoY29udGV4dHMpOiAiICsgZGF0YUNvdW50KTsKICAgICAgICBwYXJ0cy5wdXNoKCJkaWN0aW9uYXJ5IHNpemUgKGV2ZW50cyk6ICIgKyBldmVudENvdW50KTsKCiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oIiwgIik7CiAgICB9OwoKICAgIC8qKgogICAgICogQHBhcmFtIHtzdHJpbmd9CiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119CiAgICAgKi8KICAgIFJPVC5TdHJpbmdHZW5lcmF0b3IucHJvdG90eXBlLl9zcGxpdCA9IGZ1bmN0aW9uKHN0cikKICAgIHsKICAgICAgICByZXR1cm4gc3RyLnNwbGl0KHRoaXMuX29wdGlvbnMud29yZHMgPyAvXHMrLyA6ICIiKTsKICAgIH07CgogICAgLyoqCiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfQogICAgICogQHJldHVybnMge3N0cmluZ30KICAgICAqLwogICAgUk9ULlN0cmluZ0dlbmVyYXRvci5wcm90b3R5cGUuX2pvaW4gPSBmdW5jdGlvbihhcnIpCiAgICB7CiAgICAgICAgcmV0dXJuIGFyci5qb2luKHRoaXMuX29wdGlvbnMud29yZHMgPyAiICIgOiAiIik7CiAgICB9OwoKICAgIC8qKgogICAgICogQHBhcmFtIHtzdHJpbmdbXX0gY29udGV4dAogICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50CiAgICAgKi8KICAgIFJPVC5TdHJpbmdHZW5lcmF0b3IucHJvdG90eXBlLl9vYnNlcnZlRXZlbnQgPSBmdW5jdGlvbihjb250ZXh0LCBldmVudCkKICAgIHsKICAgICAgICB2YXIga2V5ID0gdGhpcy5fam9pbihjb250ZXh0KTsKICAgICAgICBpZiAoIShrZXkgaW4gdGhpcy5fZGF0YSkpCiAgICAgICAgewogICAgICAgICAgICB0aGlzLl9kYXRhW2tleV0gPSB7fTsKICAgICAgICB9CiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhW2tleV07CgogICAgICAgIGlmICghKGV2ZW50IGluIGRhdGEpKQogICAgICAgIHsKICAgICAgICAgICAgZGF0YVtldmVudF0gPSAwOwogICAgICAgIH0KICAgICAgICBkYXRhW2V2ZW50XSsrOwogICAgfTsKCiAgICAvKioKICAgICAqIEBwYXJhbSB7c3RyaW5nW119CiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfQogICAgICovCiAgICBST1QuU3RyaW5nR2VuZXJhdG9yLnByb3RvdHlwZS5fc2FtcGxlID0gZnVuY3Rpb24oY29udGV4dCkKICAgIHsKICAgICAgICBjb250ZXh0ID0gdGhpcy5fYmFja29mZihjb250ZXh0KTsKICAgICAgICB2YXIga2V5ID0gdGhpcy5fam9pbihjb250ZXh0KTsKICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGFba2V5XTsKCiAgICAgICAgdmFyIGF2YWlsYWJsZSA9IHt9OwoKICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5wcmlvcikKICAgICAgICB7CiAgICAgICAgICAgIGZvciAodmFyIGV2ZW50IGluIHRoaXMuX3ByaW9yVmFsdWVzKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBhdmFpbGFibGVbZXZlbnRdID0gdGhpcy5fcHJpb3JWYWx1ZXNbZXZlbnRdOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGZvciAodmFyIGV2ZW50IGluIGRhdGEpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGF2YWlsYWJsZVtldmVudF0gKz0gZGF0YVtldmVudF07CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZWxzZQogICAgICAgIHsKICAgICAgICAgICAgYXZhaWxhYmxlID0gZGF0YTsKICAgICAgICB9CgogICAgICAgIHJldHVybiBST1QuUk5HLmdldFdlaWdodGVkVmFsdWUoYXZhaWxhYmxlKTsKICAgIH07CgogICAgLyoqCiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfQogICAgICogQHJldHVybnMge3N0cmluZ1tdfQogICAgICovCiAgICBST1QuU3RyaW5nR2VuZXJhdG9yLnByb3RvdHlwZS5fYmFja29mZiA9IGZ1bmN0aW9uKGNvbnRleHQpCiAgICB7CiAgICAgICAgaWYgKGNvbnRleHQubGVuZ3RoID4gdGhpcy5fb3B0aW9ucy5vcmRlcikKICAgICAgICB7CiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnNsaWNlKC10aGlzLl9vcHRpb25zLm9yZGVyKTsKICAgICAgICB9CiAgICAgICAgZWxzZSBpZiAoY29udGV4dC5sZW5ndGggPCB0aGlzLl9vcHRpb25zLm9yZGVyKQogICAgICAgIHsKICAgICAgICAgICAgY29udGV4dCA9IHRoaXMuX3ByZWZpeC5zbGljZSgwLCB0aGlzLl9vcHRpb25zLm9yZGVyIC0gY29udGV4dC5sZW5ndGgpLmNvbmNhdChjb250ZXh0KTsKICAgICAgICB9CgogICAgICAgIHdoaWxlICghKHRoaXMuX2pvaW4oY29udGV4dCkgaW4gdGhpcy5fZGF0YSkgJiYgY29udGV4dC5sZW5ndGggPiAwKQogICAgICAgIHsKICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQuc2xpY2UoMSk7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gY29udGV4dDsKICAgIH07CiAgICAvKioKICAgICAqIEBjbGFzcyBHZW5lcmljIGV2ZW50IHF1ZXVlOiBzdG9yZXMgZXZlbnRzIGFuZCByZXRyaWV2ZXMgdGhlbSBiYXNlZCBvbiB0aGVpciB0aW1lCiAgICAgKi8KICAgIFJPVC5FdmVudFF1ZXVlID0gZnVuY3Rpb24oKQogICAgewogICAgICAgIHRoaXMuX3RpbWUgPSAwOwogICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdOwogICAgICAgIHRoaXMuX2V2ZW50VGltZXMgPSBbXTsKICAgIH07CgogICAgLyoqCiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBFbGFwc2VkIHRpbWUKICAgICAqLwogICAgUk9ULkV2ZW50UXVldWUucHJvdG90eXBlLmdldFRpbWUgPSBmdW5jdGlvbigpCiAgICB7CiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWU7CiAgICB9OwoKICAgIC8qKgogICAgICogQ2xlYXIgYWxsIHNjaGVkdWxlZCBldmVudHMKICAgICAqLwogICAgUk9ULkV2ZW50UXVldWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKQogICAgewogICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdOwogICAgICAgIHRoaXMuX2V2ZW50VGltZXMgPSBbXTsKICAgICAgICByZXR1cm4gdGhpczsKICAgIH07CgogICAgLyoqCiAgICAgKiBAcGFyYW0gez99IGV2ZW50CiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZQogICAgICovCiAgICBST1QuRXZlbnRRdWV1ZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZXZlbnQsIHRpbWUpCiAgICB7CiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZXZlbnRzLmxlbmd0aDsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2V2ZW50VGltZXMubGVuZ3RoOyBpKyspCiAgICAgICAgewogICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRUaW1lc1tpXSA+IHRpbWUpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGluZGV4ID0gaTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICB0aGlzLl9ldmVudHMuc3BsaWNlKGluZGV4LCAwLCBldmVudCk7CiAgICAgICAgdGhpcy5fZXZlbnRUaW1lcy5zcGxpY2UoaW5kZXgsIDAsIHRpbWUpOwogICAgfTsKCiAgICAvKioKICAgICAqIExvY2F0ZXMgdGhlIG5lYXJlc3QgZXZlbnQsIGFkdmFuY2VzIHRpbWUgaWYgbmVjZXNzYXJ5LiBSZXR1cm5zIHRoYXQgZXZlbnQgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgcXVldWUuCiAgICAgKiBAcmV0dXJucyB7PyB8fCBudWxsfSBUaGUgZXZlbnQgcHJldmlvdXNseSBhZGRlZCBieSBhZGRFdmVudCwgbnVsbCBpZiBubyBldmVudCBhdmFpbGFibGUKICAgICAqLwogICAgUk9ULkV2ZW50UXVldWUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkKICAgIHsKICAgICAgICBpZiAoIXRoaXMuX2V2ZW50cy5sZW5ndGgpCiAgICAgICAgewogICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICB9CgogICAgICAgIHZhciB0aW1lID0gdGhpcy5fZXZlbnRUaW1lcy5zcGxpY2UoMCwgMSlbMF07CiAgICAgICAgaWYgKHRpbWUgPiAwKQogICAgICAgIHsgLyogYWR2YW5jZSAqLwogICAgICAgICAgICB0aGlzLl90aW1lICs9IHRpbWU7CiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXZlbnRUaW1lcy5sZW5ndGg7IGkrKykKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRUaW1lc1tpXSAtPSB0aW1lOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLnNwbGljZSgwLCAxKVswXTsKICAgIH07CgogICAgLyoqCiAgICAgKiBHZXQgdGhlIHRpbWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBldmVudAogICAgICogQHBhcmFtIHs/fSBldmVudAogICAgICogQHJldHVybnMge251bWJlcn0gdGltZQogICAgICovCiAgICBST1QuRXZlbnRRdWV1ZS5wcm90b3R5cGUuZ2V0RXZlbnRUaW1lID0gZnVuY3Rpb24oZXZlbnQpCiAgICB7CiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZXZlbnRzLmluZGV4T2YoZXZlbnQpOwogICAgICAgIGlmIChpbmRleCA9PSAtMSkKICAgICAgICB7CiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50VGltZXNbaW5kZXhdOwogICAgfTsKCiAgICAvKioKICAgICAqIFJlbW92ZSBhbiBldmVudCBmcm9tIHRoZSBxdWV1ZQogICAgICogQHBhcmFtIHs/fSBldmVudAogICAgICogQHJldHVybnMge2Jvb2x9IHN1Y2Nlc3M/CiAgICAgKi8KICAgIFJPVC5FdmVudFF1ZXVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihldmVudCkKICAgIHsKICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9ldmVudHMuaW5kZXhPZihldmVudCk7CiAgICAgICAgaWYgKGluZGV4ID09IC0xKQogICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgICAgfQogICAgICAgIHRoaXMuX3JlbW92ZShpbmRleCk7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICB9OwoKICAgIC8qKgogICAgICogUmVtb3ZlIGFuIGV2ZW50IGZyb20gdGhlIHF1ZXVlCiAgICAgKiBAcGFyYW0ge2ludH0gaW5kZXgKICAgICAqLwogICAgUk9ULkV2ZW50UXVldWUucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbihpbmRleCkKICAgIHsKICAgICAgICB0aGlzLl9ldmVudHMuc3BsaWNlKGluZGV4LCAxKTsKICAgICAgICB0aGlzLl9ldmVudFRpbWVzLnNwbGljZShpbmRleCwgMSk7CiAgICB9OwogICAgLyoqCiAgICAgKiBAY2xhc3MgQWJzdHJhY3Qgc2NoZWR1bGVyCiAgICAgKi8KICAgIFJPVC5TY2hlZHVsZXIgPSBmdW5jdGlvbigpCiAgICB7CiAgICAgICAgdGhpcy5fcXVldWUgPSBuZXcgUk9ULkV2ZW50UXVldWUoKTsKICAgICAgICB0aGlzLl9yZXBlYXQgPSBbXTsKICAgICAgICB0aGlzLl9jdXJyZW50ID0gbnVsbDsKICAgIH07CgogICAgLyoqCiAgICAgKiBAc2VlIFJPVC5FdmVudFF1ZXVlI2dldFRpbWUKICAgICAqLwogICAgUk9ULlNjaGVkdWxlci5wcm90b3R5cGUuZ2V0VGltZSA9IGZ1bmN0aW9uKCkKICAgIHsKICAgICAgICByZXR1cm4gdGhpcy5fcXVldWUuZ2V0VGltZSgpOwogICAgfTsKCiAgICAvKioKICAgICAqIEBwYXJhbSB7P30gaXRlbQogICAgICogQHBhcmFtIHtib29sfSByZXBlYXQKICAgICAqLwogICAgUk9ULlNjaGVkdWxlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oaXRlbSwgcmVwZWF0KQogICAgewogICAgICAgIGlmIChyZXBlYXQpCiAgICAgICAgewogICAgICAgICAgICB0aGlzLl9yZXBlYXQucHVzaChpdGVtKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICB9OwoKICAgIC8qKgogICAgICogR2V0IHRoZSB0aW1lIHRoZSBnaXZlbiBpdGVtIGlzIHNjaGVkdWxlZCBmb3IKICAgICAqIEBwYXJhbSB7P30gaXRlbQogICAgICogQHJldHVybnMge251bWJlcn0gdGltZQogICAgICovCiAgICBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5nZXRUaW1lT2YgPSBmdW5jdGlvbihpdGVtKQogICAgewogICAgICAgIHJldHVybiB0aGlzLl9xdWV1ZS5nZXRFdmVudFRpbWUoaXRlbSk7CiAgICB9OwoKICAgIC8qKgogICAgICogQ2xlYXIgYWxsIGl0ZW1zCiAgICAgKi8KICAgIFJPVC5TY2hlZHVsZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKQogICAgewogICAgICAgIHRoaXMuX3F1ZXVlLmNsZWFyKCk7CiAgICAgICAgdGhpcy5fcmVwZWF0ID0gW107CiAgICAgICAgdGhpcy5fY3VycmVudCA9IG51bGw7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICB9OwoKICAgIC8qKgogICAgICogUmVtb3ZlIGEgcHJldmlvdXNseSBhZGRlZCBpdGVtCiAgICAgKiBAcGFyYW0gez99IGl0ZW0KICAgICAqIEByZXR1cm5zIHtib29sfSBzdWNjZXNzZnVsPwogICAgICovCiAgICBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihpdGVtKQogICAgewogICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9xdWV1ZS5yZW1vdmUoaXRlbSk7CgogICAgICAgIHZhciBpbmRleCA9IHRoaXMuX3JlcGVhdC5pbmRleE9mKGl0ZW0pOwogICAgICAgIGlmIChpbmRleCAhPSAtMSkKICAgICAgICB7CiAgICAgICAgICAgIHRoaXMuX3JlcGVhdC5zcGxpY2UoaW5kZXgsIDEpOwogICAgICAgIH0KCiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnQgPT0gaXRlbSkKICAgICAgICB7CiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBudWxsOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH07CgogICAgLyoqCiAgICAgKiBTY2hlZHVsZSBuZXh0IGl0ZW0KICAgICAqIEByZXR1cm5zIHs/fQogICAgICovCiAgICBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKQogICAgewogICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9xdWV1ZS5nZXQoKTsKICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudDsKICAgIH07CiAgICAvKioKICAgICAqIEBjbGFzcyBTaW1wbGUgZmFpciBzY2hlZHVsZXIgKHJvdW5kLXJvYmluIHN0eWxlKQogICAgICogQGF1Z21lbnRzIFJPVC5TY2hlZHVsZXIKICAgICAqLwogICAgUk9ULlNjaGVkdWxlci5TaW1wbGUgPSBmdW5jdGlvbigpCiAgICB7CiAgICAgICAgUk9ULlNjaGVkdWxlci5jYWxsKHRoaXMpOwogICAgfTsKICAgIFJPVC5TY2hlZHVsZXIuU2ltcGxlLmV4dGVuZChST1QuU2NoZWR1bGVyKTsKCiAgICAvKioKICAgICAqIEBzZWUgUk9ULlNjaGVkdWxlciNhZGQKICAgICAqLwogICAgUk9ULlNjaGVkdWxlci5TaW1wbGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGl0ZW0sIHJlcGVhdCkKICAgIHsKICAgICAgICB0aGlzLl9xdWV1ZS5hZGQoaXRlbSwgMCk7CiAgICAgICAgcmV0dXJuIFJPVC5TY2hlZHVsZXIucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIGl0ZW0sIHJlcGVhdCk7CiAgICB9OwoKICAgIC8qKgogICAgICogQHNlZSBST1QuU2NoZWR1bGVyI25leHQKICAgICAqLwogICAgUk9ULlNjaGVkdWxlci5TaW1wbGUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpCiAgICB7CiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnQgJiYgdGhpcy5fcmVwZWF0LmluZGV4T2YodGhpcy5fY3VycmVudCkgIT0gLTEpCiAgICAgICAgewogICAgICAgICAgICB0aGlzLl9xdWV1ZS5hZGQodGhpcy5fY3VycmVudCwgMCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcyk7CiAgICB9OwogICAgLyoqCiAgICAgKiBAY2xhc3MgU3BlZWQtYmFzZWQgc2NoZWR1bGVyCiAgICAgKiBAYXVnbWVudHMgUk9ULlNjaGVkdWxlcgogICAgICovCiAgICBST1QuU2NoZWR1bGVyLlNwZWVkID0gZnVuY3Rpb24oKQogICAgewogICAgICAgIFJPVC5TY2hlZHVsZXIuY2FsbCh0aGlzKTsKICAgIH07CiAgICBST1QuU2NoZWR1bGVyLlNwZWVkLmV4dGVuZChST1QuU2NoZWR1bGVyKTsKCiAgICAvKioKICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIGFueXRoaW5nIHdpdGggImdldFNwZWVkIiBtZXRob2QKICAgICAqIEBwYXJhbSB7Ym9vbH0gcmVwZWF0CiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWU9MS9pdGVtLmdldFNwZWVkKCldCiAgICAgKiBAc2VlIFJPVC5TY2hlZHVsZXIjYWRkCiAgICAgKi8KICAgIFJPVC5TY2hlZHVsZXIuU3BlZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGl0ZW0sIHJlcGVhdCwgdGltZSkKICAgIHsKICAgICAgICB0aGlzLl9xdWV1ZS5hZGQoaXRlbSwgdGltZSAhPT0gdW5kZWZpbmVkID8gdGltZSA6IDEgLyBpdGVtLmdldFNwZWVkKCkpOwogICAgICAgIHJldHVybiBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBpdGVtLCByZXBlYXQpOwogICAgfTsKCiAgICAvKioKICAgICAqIEBzZWUgUk9ULlNjaGVkdWxlciNuZXh0CiAgICAgKi8KICAgIFJPVC5TY2hlZHVsZXIuU3BlZWQucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpCiAgICB7CiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnQgJiYgdGhpcy5fcmVwZWF0LmluZGV4T2YodGhpcy5fY3VycmVudCkgIT0gLTEpCiAgICAgICAgewogICAgICAgICAgICB0aGlzLl9xdWV1ZS5hZGQodGhpcy5fY3VycmVudCwgMSAvIHRoaXMuX2N1cnJlbnQuZ2V0U3BlZWQoKSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcyk7CiAgICB9OwogICAgLyoqCiAgICAgKiBAY2xhc3MgQWN0aW9uLWJhc2VkIHNjaGVkdWxlcgogICAgICogQGF1Z21lbnRzIFJPVC5TY2hlZHVsZXIKICAgICAqLwogICAgUk9ULlNjaGVkdWxlci5BY3Rpb24gPSBmdW5jdGlvbigpCiAgICB7CiAgICAgICAgUk9ULlNjaGVkdWxlci5jYWxsKHRoaXMpOwogICAgICAgIHRoaXMuX2RlZmF1bHREdXJhdGlvbiA9IDE7IC8qIGZvciBuZXdseSBhZGRlZCAqLwogICAgICAgIHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fZGVmYXVsdER1cmF0aW9uOyAvKiBmb3IgdGhpcy5fY3VycmVudCAqLwogICAgfTsKICAgIFJPVC5TY2hlZHVsZXIuQWN0aW9uLmV4dGVuZChST1QuU2NoZWR1bGVyKTsKCiAgICAvKioKICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtCiAgICAgKiBAcGFyYW0ge2Jvb2x9IHJlcGVhdAogICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTFdCiAgICAgKiBAc2VlIFJPVC5TY2hlZHVsZXIjYWRkCiAgICAgKi8KICAgIFJPVC5TY2hlZHVsZXIuQWN0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpdGVtLCByZXBlYXQsIHRpbWUpCiAgICB7CiAgICAgICAgdGhpcy5fcXVldWUuYWRkKGl0ZW0sIHRpbWUgfHwgdGhpcy5fZGVmYXVsdER1cmF0aW9uKTsKICAgICAgICByZXR1cm4gUk9ULlNjaGVkdWxlci5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgaXRlbSwgcmVwZWF0KTsKICAgIH07CgogICAgUk9ULlNjaGVkdWxlci5BY3Rpb24ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKQogICAgewogICAgICAgIHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fZGVmYXVsdER1cmF0aW9uOwogICAgICAgIHJldHVybiBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5jbGVhci5jYWxsKHRoaXMpOwogICAgfTsKCiAgICBST1QuU2NoZWR1bGVyLkFjdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaXRlbSkKICAgIHsKICAgICAgICBpZiAoaXRlbSA9PSB0aGlzLl9jdXJyZW50KQogICAgICAgIHsKICAgICAgICAgICAgdGhpcy5fZHVyYXRpb24gPSB0aGlzLl9kZWZhdWx0RHVyYXRpb247CiAgICAgICAgfQogICAgICAgIHJldHVybiBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCBpdGVtKTsKICAgIH07CgogICAgLyoqCiAgICAgKiBAc2VlIFJPVC5TY2hlZHVsZXIjbmV4dAogICAgICovCiAgICBST1QuU2NoZWR1bGVyLkFjdGlvbi5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkKICAgIHsKICAgICAgICBpZiAodGhpcy5fY3VycmVudCAmJiB0aGlzLl9yZXBlYXQuaW5kZXhPZih0aGlzLl9jdXJyZW50KSAhPSAtMSkKICAgICAgICB7CiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLmFkZCh0aGlzLl9jdXJyZW50LCB0aGlzLl9kdXJhdGlvbiB8fCB0aGlzLl9kZWZhdWx0RHVyYXRpb24pOwogICAgICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX2RlZmF1bHREdXJhdGlvbjsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIFJPVC5TY2hlZHVsZXIucHJvdG90eXBlLm5leHQuY2FsbCh0aGlzKTsKICAgIH07CgogICAgLyoqCiAgICAgKiBTZXQgZHVyYXRpb24gZm9yIHRoZSBhY3RpdmUgaXRlbQogICAgICovCiAgICBST1QuU2NoZWR1bGVyLkFjdGlvbi5wcm90b3R5cGUuc2V0RHVyYXRpb24gPSBmdW5jdGlvbih0aW1lKQogICAgewogICAgICAgIGlmICh0aGlzLl9jdXJyZW50KQogICAgICAgIHsKICAgICAgICAgICAgdGhpcy5fZHVyYXRpb24gPSB0aW1lOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgIH07CiAgICAvKioKICAgICAqIEBjbGFzcyBBc3luY2hyb25vdXMgbWFpbiBsb29wCiAgICAgKiBAcGFyYW0ge1JPVC5TY2hlZHVsZXJ9IHNjaGVkdWxlcgogICAgICovCiAgICBST1QuRW5naW5lID0gZnVuY3Rpb24oc2NoZWR1bGVyKQogICAgewogICAgICAgIHRoaXMuX3NjaGVkdWxlciA9IHNjaGVkdWxlcjsKICAgICAgICB0aGlzLl9sb2NrID0gMTsKICAgIH07CgogICAgLyoqCiAgICAgKiBTdGFydCB0aGUgbWFpbiBsb29wLiBXaGVuIHRoaXMgY2FsbCByZXR1cm5zLCB0aGUgbG9vcCBpcyBsb2NrZWQuCiAgICAgKi8KICAgIFJPVC5FbmdpbmUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKQogICAgewogICAgICAgIHJldHVybiB0aGlzLnVubG9jaygpOwogICAgfTsKCiAgICAvKioKICAgICAqIEludGVycnVwdCB0aGUgZW5naW5lIGJ5IGFuIGFzeW5jaHJvbm91cyBhY3Rpb24KICAgICAqLwogICAgUk9ULkVuZ2luZS5wcm90b3R5cGUubG9jayA9IGZ1bmN0aW9uKCkKICAgIHsKICAgICAgICB0aGlzLl9sb2NrKys7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICB9OwoKICAgIC8qKgogICAgICogUmVzdW1lIGV4ZWN1dGlvbiAocGF1c2VkIGJ5IGEgcHJldmlvdXMgbG9jaykKICAgICAqLwogICAgUk9ULkVuZ2luZS5wcm90b3R5cGUudW5sb2NrID0gZnVuY3Rpb24oKQogICAgewogICAgICAgIGlmICghdGhpcy5fbG9jaykKICAgICAgICB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiQ2Fubm90IHVubG9jayB1bmxvY2tlZCBlbmdpbmUiKTsKICAgICAgICB9CiAgICAgICAgdGhpcy5fbG9jay0tOwoKICAgICAgICB3aGlsZSAoIXRoaXMuX2xvY2spCiAgICAgICAgewogICAgICAgICAgICB2YXIgYWN0b3IgPSB0aGlzLl9zY2hlZHVsZXIubmV4dCgpOwogICAgICAgICAgICBpZiAoIWFjdG9yKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NrKCk7CiAgICAgICAgICAgIH0gLyogbm8gYWN0b3JzICovCiAgICAgICAgICAgIHZhciByZXN1bHQgPSBhY3Rvci5hY3QoKTsKICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikKICAgICAgICAgICAgeyAvKiBhY3RvciByZXR1cm5lZCBhICJ0aGVuYWJsZSIsIGxvb2tzIGxpa2UgYSBQcm9taXNlICovCiAgICAgICAgICAgICAgICB0aGlzLmxvY2soKTsKICAgICAgICAgICAgICAgIHJlc3VsdC50aGVuKHRoaXMudW5sb2NrLmJpbmQodGhpcykpOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gdGhpczsKICAgIH07CiAgICAvKioKICAgICAqIEBjbGFzcyBCYXNlIG1hcCBnZW5lcmF0b3IKICAgICAqIEBwYXJhbSB7aW50fSBbd2lkdGg9Uk9ULkRFRkFVTFRfV0lEVEhdCiAgICAgKiBAcGFyYW0ge2ludH0gW2hlaWdodD1ST1QuREVGQVVMVF9IRUlHSFRdCiAgICAgKi8KICAgIFJPVC5NYXAgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KQogICAgewogICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGggfHwgUk9ULkRFRkFVTFRfV0lEVEg7CiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0IHx8IFJPVC5ERUZBVUxUX0hFSUdIVDsKICAgIH07CgogICAgUk9ULk1hcC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spCiAgICB7fTsKCiAgICBST1QuTWFwLnByb3RvdHlwZS5fZmlsbE1hcCA9IGZ1bmN0aW9uKHZhbHVlKQogICAgewogICAgICAgIHZhciBtYXAgPSBbXTsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3dpZHRoOyBpKyspCiAgICAgICAgewogICAgICAgICAgICBtYXAucHVzaChbXSk7CiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5faGVpZ2h0OyBqKyspCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIG1hcFtpXS5wdXNoKHZhbHVlKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gbWFwOwogICAgfTsKICAgIC8qKgogICAgICogQGNsYXNzIFNpbXBsZSBlbXB0eSByZWN0YW5ndWxhciByb29tCiAgICAgKiBAYXVnbWVudHMgUk9ULk1hcAogICAgICovCiAgICBST1QuTWFwLkFyZW5hID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkKICAgIHsKICAgICAgICBST1QuTWFwLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCk7CiAgICB9OwogICAgUk9ULk1hcC5BcmVuYS5leHRlbmQoUk9ULk1hcCk7CgogICAgUk9ULk1hcC5BcmVuYS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spCiAgICB7CiAgICAgICAgdmFyIHcgPSB0aGlzLl93aWR0aCAtIDE7CiAgICAgICAgdmFyIGggPSB0aGlzLl9oZWlnaHQgLSAxOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHc7IGkrKykKICAgICAgICB7CiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDw9IGg7IGorKykKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdmFyIGVtcHR5ID0gKGkgJiYgaiAmJiBpIDwgdyAmJiBqIDwgaCk7CiAgICAgICAgICAgICAgICBjYWxsYmFjayhpLCBqLCBlbXB0eSA/IDAgOiAxKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgIH07CiAgICAvKioKICAgICAqIEBjbGFzcyBSZWN1cnNpdmVseSBkaXZpZGVkIG1hemUsIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWF6ZV9nZW5lcmF0aW9uX2FsZ29yaXRobSNSZWN1cnNpdmVfZGl2aXNpb25fbWV0aG9kCiAgICAgKiBAYXVnbWVudHMgUk9ULk1hcAogICAgICovCiAgICBST1QuTWFwLkRpdmlkZWRNYXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkKICAgIHsKICAgICAgICBST1QuTWFwLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCk7CiAgICAgICAgdGhpcy5fc3RhY2sgPSBbXTsKICAgIH07CiAgICBST1QuTWFwLkRpdmlkZWRNYXplLmV4dGVuZChST1QuTWFwKTsKCiAgICBST1QuTWFwLkRpdmlkZWRNYXplLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykKICAgIHsKICAgICAgICB2YXIgdyA9IHRoaXMuX3dpZHRoOwogICAgICAgIHZhciBoID0gdGhpcy5faGVpZ2h0OwoKICAgICAgICB0aGlzLl9tYXAgPSBbXTsKCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3OyBpKyspCiAgICAgICAgewogICAgICAgICAgICB0aGlzLl9tYXAucHVzaChbXSk7CiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaDsgaisrKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICB2YXIgYm9yZGVyID0gKGkgPT0gMCB8fCBqID09IDAgfHwgaSArIDEgPT0gdyB8fCBqICsgMSA9PSBoKTsKICAgICAgICAgICAgICAgIHRoaXMuX21hcFtpXS5wdXNoKGJvcmRlciA/IDEgOiAwKTsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgdGhpcy5fc3RhY2sgPSBbCiAgICAgICAgWzEsIDEsIHcgLSAyLCBoIC0gMl0KICAgIF07CiAgICAgICAgdGhpcy5fcHJvY2VzcygpOwoKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHc7IGkrKykKICAgICAgICB7CiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaDsgaisrKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBjYWxsYmFjayhpLCBqLCB0aGlzLl9tYXBbaV1bal0pOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRoaXMuX21hcCA9IG51bGw7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICB9OwoKICAgIFJPVC5NYXAuRGl2aWRlZE1hemUucHJvdG90eXBlLl9wcm9jZXNzID0gZnVuY3Rpb24oKQogICAgewogICAgICAgIHdoaWxlICh0aGlzLl9zdGFjay5sZW5ndGgpCiAgICAgICAgewogICAgICAgICAgICB2YXIgcm9vbSA9IHRoaXMuX3N0YWNrLnNoaWZ0KCk7IC8qIFtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21dICovCiAgICAgICAgICAgIHRoaXMuX3BhcnRpdGlvblJvb20ocm9vbSk7CiAgICAgICAgfQogICAgfTsKCiAgICBST1QuTWFwLkRpdmlkZWRNYXplLnByb3RvdHlwZS5fcGFydGl0aW9uUm9vbSA9IGZ1bmN0aW9uKHJvb20pCiAgICB7CiAgICAgICAgdmFyIGF2YWlsWCA9IFtdOwogICAgICAgIHZhciBhdmFpbFkgPSBbXTsKCiAgICAgICAgZm9yICh2YXIgaSA9IHJvb21bMF0gKyAxOyBpIDwgcm9vbVsyXTsgaSsrKQogICAgICAgIHsKICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMuX21hcFtpXVtyb29tWzFdIC0gMV07CiAgICAgICAgICAgIHZhciBib3R0b20gPSB0aGlzLl9tYXBbaV1bcm9vbVszXSArIDFdOwogICAgICAgICAgICBpZiAodG9wICYmIGJvdHRvbSAmJiAhKGkgJSAyKSkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgYXZhaWxYLnB1c2goaSk7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGZvciAodmFyIGogPSByb29tWzFdICsgMTsgaiA8IHJvb21bM107IGorKykKICAgICAgICB7CiAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5fbWFwW3Jvb21bMF0gLSAxXVtqXTsKICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5fbWFwW3Jvb21bMl0gKyAxXVtqXTsKICAgICAgICAgICAgaWYgKGxlZnQgJiYgcmlnaHQgJiYgIShqICUgMikpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGF2YWlsWS5wdXNoKGopOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAoIWF2YWlsWC5sZW5ndGggfHwgIWF2YWlsWS5sZW5ndGgpCiAgICAgICAgewogICAgICAgICAgICByZXR1cm47CiAgICAgICAgfQoKICAgICAgICB2YXIgeCA9IGF2YWlsWC5yYW5kb20oKTsKICAgICAgICB2YXIgeSA9IGF2YWlsWS5yYW5kb20oKTsKCiAgICAgICAgdGhpcy5fbWFwW3hdW3ldID0gMTsKCiAgICAgICAgdmFyIHdhbGxzID0gW107CgogICAgICAgIHZhciB3ID0gW107CiAgICAgICAgd2FsbHMucHVzaCh3KTsgLyogbGVmdCBwYXJ0ICovCiAgICAgICAgZm9yICh2YXIgaSA9IHJvb21bMF07IGkgPCB4OyBpKyspCiAgICAgICAgewogICAgICAgICAgICB0aGlzLl9tYXBbaV1beV0gPSAxOwogICAgICAgICAgICB3LnB1c2goW2ksIHldKTsKICAgICAgICB9CgogICAgICAgIHZhciB3ID0gW107CiAgICAgICAgd2FsbHMucHVzaCh3KTsgLyogcmlnaHQgcGFydCAqLwogICAgICAgIGZvciAodmFyIGkgPSB4ICsgMTsgaSA8PSByb29tWzJdOyBpKyspCiAgICAgICAgewogICAgICAgICAgICB0aGlzLl9tYXBbaV1beV0gPSAxOwogICAgICAgICAgICB3LnB1c2goW2ksIHldKTsKICAgICAgICB9CgogICAgICAgIHZhciB3ID0gW107CiAgICAgICAgd2FsbHMucHVzaCh3KTsgLyogdG9wIHBhcnQgKi8KICAgICAgICBmb3IgKHZhciBqID0gcm9vbVsxXTsgaiA8IHk7IGorKykKICAgICAgICB7CiAgICAgICAgICAgIHRoaXMuX21hcFt4XVtqXSA9IDE7CiAgICAgICAgICAgIHcucHVzaChbeCwgal0pOwogICAgICAgIH0KCiAgICAgICAgdmFyIHcgPSBbXTsKICAgICAgICB3YWxscy5wdXNoKHcpOyAvKiBib3R0b20gcGFydCAqLwogICAgICAgIGZvciAodmFyIGogPSB5ICsgMTsgaiA8PSByb29tWzNdOyBqKyspCiAgICAgICAgewogICAgICAgICAgICB0aGlzLl9tYXBbeF1bal0gPSAxOwogICAgICAgICAgICB3LnB1c2goW3gsIGpdKTsKICAgICAgICB9CgogICAgICAgIHZhciBzb2xpZCA9IHdhbGxzLnJhbmRvbSgpOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2FsbHMubGVuZ3RoOyBpKyspCiAgICAgICAgewogICAgICAgICAgICB2YXIgdyA9IHdhbGxzW2ldOwogICAgICAgICAgICBpZiAodyA9PSBzb2xpZCkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHZhciBob2xlID0gdy5yYW5kb20oKTsKICAgICAgICAgICAgdGhpcy5fbWFwW2hvbGVbMF1dW2hvbGVbMV1dID0gMDsKICAgICAgICB9CgogICAgICAgIHRoaXMuX3N0YWNrLnB1c2goW3Jvb21bMF0sIHJvb21bMV0sIHggLSAxLCB5IC0gMV0pOyAvKiBsZWZ0IHRvcCAqLwogICAgICAgIHRoaXMuX3N0YWNrLnB1c2goW3ggKyAxLCByb29tWzFdLCByb29tWzJdLCB5IC0gMV0pOyAvKiByaWdodCB0b3AgKi8KICAgICAgICB0aGlzLl9zdGFjay5wdXNoKFtyb29tWzBdLCB5ICsgMSwgeCAtIDEsIHJvb21bM11dKTsgLyogbGVmdCBib3R0b20gKi8KICAgICAgICB0aGlzLl9zdGFjay5wdXNoKFt4ICsgMSwgeSArIDEsIHJvb21bMl0sIHJvb21bM11dKTsgLyogcmlnaHQgYm90dG9tICovCiAgICB9OwogICAgLyoqCiAgICAgKiBAY2xhc3MgSWNleSdzIE1hemUgZ2VuZXJhdG9yCiAgICAgKiBTZWUgaHR0cDovL3d3dy5yb2d1ZWJhc2luLnJvZ3VlbGlrZWRldmVsb3BtZW50Lm9yZy9pbmRleC5waHA/dGl0bGU9U2ltcGxlX21hemUgZm9yIGV4cGxhbmF0aW9uCiAgICAgKiBAYXVnbWVudHMgUk9ULk1hcAogICAgICovCiAgICBST1QuTWFwLkljZXlNYXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgcmVndWxhcml0eSkKICAgIHsKICAgICAgICBST1QuTWFwLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCk7CiAgICAgICAgdGhpcy5fcmVndWxhcml0eSA9IHJlZ3VsYXJpdHkgfHwgMDsKICAgIH07CiAgICBST1QuTWFwLkljZXlNYXplLmV4dGVuZChST1QuTWFwKTsKCiAgICBST1QuTWFwLkljZXlNYXplLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykKICAgIHsKICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDsKICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0OwoKICAgICAgICB2YXIgbWFwID0gdGhpcy5fZmlsbE1hcCgxKTsKCiAgICAgICAgd2lkdGggLT0gKHdpZHRoICUgMiA/IDEgOiAyKTsKICAgICAgICBoZWlnaHQgLT0gKGhlaWdodCAlIDIgPyAxIDogMik7CgogICAgICAgIHZhciBjeCA9IDA7CiAgICAgICAgdmFyIGN5ID0gMDsKICAgICAgICB2YXIgbnggPSAwOwogICAgICAgIHZhciBueSA9IDA7CgogICAgICAgIHZhciBkb25lID0gMDsKICAgICAgICB2YXIgYmxvY2tlZCA9IGZhbHNlOwogICAgICAgIHZhciBkaXJzID0gWwogICAgICAgIFswLCAwXSwKICAgICAgICBbMCwgMF0sCiAgICAgICAgWzAsIDBdLAogICAgICAgIFswLCAwXQogICAgXTsKICAgICAgICBkbyB7CiAgICAgICAgICAgIGN4ID0gMSArIDIgKiBNYXRoLmZsb29yKFJPVC5STkcuZ2V0VW5pZm9ybSgpICogKHdpZHRoIC0gMSkgLyAyKTsKICAgICAgICAgICAgY3kgPSAxICsgMiAqIE1hdGguZmxvb3IoUk9ULlJORy5nZXRVbmlmb3JtKCkgKiAoaGVpZ2h0IC0gMSkgLyAyKTsKCiAgICAgICAgICAgIGlmICghZG9uZSkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgbWFwW2N4XVtjeV0gPSAwOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAoIW1hcFtjeF1bY3ldKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICB0aGlzLl9yYW5kb21pemUoZGlycyk7CiAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IoUk9ULlJORy5nZXRVbmlmb3JtKCkgKiAodGhpcy5fcmVndWxhcml0eSArIDEpKSA9PSAwKQogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmFuZG9taXplKGRpcnMpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBibG9ja2VkID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgIG54ID0gY3ggKyBkaXJzW2ldWzBdICogMjsKICAgICAgICAgICAgICAgICAgICAgICAgbnkgPSBjeSArIGRpcnNbaV1bMV0gKiAyOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNGcmVlKG1hcCwgbngsIG55LCB3aWR0aCwgaGVpZ2h0KSkKICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwW254XVtueV0gPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwW2N4ICsgZGlyc1tpXVswXV1bY3kgKyBkaXJzW2ldWzFdXSA9IDA7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgY3ggPSBueDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5ID0gbnk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja2VkID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKys7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gd2hpbGUgKCFibG9ja2VkKTsKICAgICAgICAgICAgfQogICAgICAgIH0gd2hpbGUgKGRvbmUgKyAxIDwgd2lkdGggKiBoZWlnaHQgLyA0KTsKCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl93aWR0aDsgaSsrKQogICAgICAgIHsKICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9oZWlnaHQ7IGorKykKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgY2FsbGJhY2soaSwgaiwgbWFwW2ldW2pdKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB0aGlzLl9tYXAgPSBudWxsOwogICAgICAgIHJldHVybiB0aGlzOwogICAgfTsKCiAgICBST1QuTWFwLkljZXlNYXplLnByb3RvdHlwZS5fcmFuZG9taXplID0gZnVuY3Rpb24oZGlycykKICAgIHsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykKICAgICAgICB7CiAgICAgICAgICAgIGRpcnNbaV1bMF0gPSAwOwogICAgICAgICAgICBkaXJzW2ldWzFdID0gMDsKICAgICAgICB9CgogICAgICAgIHN3aXRjaCAoTWF0aC5mbG9vcihST1QuUk5HLmdldFVuaWZvcm0oKSAqIDQpKQogICAgICAgIHsKICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgZGlyc1swXVswXSA9IC0xOwogICAgICAgICAgICAgICAgZGlyc1sxXVswXSA9IDE7CiAgICAgICAgICAgICAgICBkaXJzWzJdWzFdID0gLTE7CiAgICAgICAgICAgICAgICBkaXJzWzNdWzFdID0gMTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgICAgICBkaXJzWzNdWzBdID0gLTE7CiAgICAgICAgICAgICAgICBkaXJzWzJdWzBdID0gMTsKICAgICAgICAgICAgICAgIGRpcnNbMV1bMV0gPSAtMTsKICAgICAgICAgICAgICAgIGRpcnNbMF1bMV0gPSAxOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgIGRpcnNbMl1bMF0gPSAtMTsKICAgICAgICAgICAgICAgIGRpcnNbM11bMF0gPSAxOwogICAgICAgICAgICAgICAgZGlyc1swXVsxXSA9IC0xOwogICAgICAgICAgICAgICAgZGlyc1sxXVsxXSA9IDE7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgZGlyc1sxXVswXSA9IC0xOwogICAgICAgICAgICAgICAgZGlyc1swXVswXSA9IDE7CiAgICAgICAgICAgICAgICBkaXJzWzNdWzFdID0gLTE7CiAgICAgICAgICAgICAgICBkaXJzWzJdWzFdID0gMTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgIH07CgogICAgUk9ULk1hcC5JY2V5TWF6ZS5wcm90b3R5cGUuX2lzRnJlZSA9IGZ1bmN0aW9uKG1hcCwgeCwgeSwgd2lkdGgsIGhlaWdodCkKICAgIHsKICAgICAgICBpZiAoeCA8IDEgfHwgeSA8IDEgfHwgeCA+PSB3aWR0aCB8fCB5ID49IGhlaWdodCkKICAgICAgICB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG1hcFt4XVt5XTsKICAgIH07CiAgICAvKioKICAgICAqIEBjbGFzcyBNYXplIGdlbmVyYXRvciAtIEVsbGVyJ3MgYWxnb3JpdGhtCiAgICAgKiBTZWUgaHR0cDovL2hvbWVwYWdlcy5jd2kubmwvfnRyb21wL21hemUuaHRtbCBmb3IgZXhwbGFuYXRpb24KICAgICAqIEBhdWdtZW50cyBST1QuTWFwCiAgICAgKi8KICAgIFJPVC5NYXAuRWxsZXJNYXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkKICAgIHsKICAgICAgICBST1QuTWFwLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCk7CiAgICB9OwogICAgUk9ULk1hcC5FbGxlck1hemUuZXh0ZW5kKFJPVC5NYXApOwoKICAgIFJPVC5NYXAuRWxsZXJNYXplLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykKICAgIHsKICAgICAgICB2YXIgbWFwID0gdGhpcy5fZmlsbE1hcCgxKTsKICAgICAgICB2YXIgdyA9IE1hdGguY2VpbCgodGhpcy5fd2lkdGggLSAyKSAvIDIpOwoKICAgICAgICB2YXIgcmFuZCA9IDkgLyAyNDsKCiAgICAgICAgdmFyIEwgPSBbXTsKICAgICAgICB2YXIgUiA9IFtdOwoKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHc7IGkrKykKICAgICAgICB7CiAgICAgICAgICAgIEwucHVzaChpKTsKICAgICAgICAgICAgUi5wdXNoKGkpOwogICAgICAgIH0KICAgICAgICBMLnB1c2godyAtIDEpOyAvKiBmYWtlIHN0b3AtYmxvY2sgYXQgdGhlIHJpZ2h0IHNpZGUgKi8KCiAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogKyAzIDwgdGhpcy5faGVpZ2h0OyBqICs9IDIpCiAgICAgICAgewogICAgICAgICAgICAvKiBvbmUgcm93ICovCiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdzsgaSsrKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAvKiBjZWxsIGNvb3JkcyAod2lsbCBiZSBhbHdheXMgZW1wdHkpICovCiAgICAgICAgICAgICAgICB2YXIgeCA9IDIgKiBpICsgMTsKICAgICAgICAgICAgICAgIHZhciB5ID0gajsKICAgICAgICAgICAgICAgIG1hcFt4XVt5XSA9IDA7CgogICAgICAgICAgICAgICAgLyogcmlnaHQgY29ubmVjdGlvbiAqLwogICAgICAgICAgICAgICAgaWYgKGkgIT0gTFtpICsgMV0gJiYgUk9ULlJORy5nZXRVbmlmb3JtKCkgPiByYW5kKQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRvTGlzdChpLCBMLCBSKTsKICAgICAgICAgICAgICAgICAgICBtYXBbeCArIDFdW3ldID0gMDsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAvKiBib3R0b20gY29ubmVjdGlvbiAqLwogICAgICAgICAgICAgICAgaWYgKGkgIT0gTFtpXSAmJiBST1QuUk5HLmdldFVuaWZvcm0oKSA+IHJhbmQpCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgLyogcmVtb3ZlIGNvbm5lY3Rpb24gKi8KICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVGcm9tTGlzdChpLCBMLCBSKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAvKiBjcmVhdGUgY29ubmVjdGlvbiAqLwogICAgICAgICAgICAgICAgICAgIG1hcFt4XVt5ICsgMV0gPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICAvKiBsYXN0IHJvdyAqLwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdzsgaSsrKQogICAgICAgIHsKICAgICAgICAgICAgLyogY2VsbCBjb29yZHMgKHdpbGwgYmUgYWx3YXlzIGVtcHR5KSAqLwogICAgICAgICAgICB2YXIgeCA9IDIgKiBpICsgMTsKICAgICAgICAgICAgdmFyIHkgPSBqOwogICAgICAgICAgICBtYXBbeF1beV0gPSAwOwoKICAgICAgICAgICAgLyogcmlnaHQgY29ubmVjdGlvbiAqLwogICAgICAgICAgICBpZiAoaSAhPSBMW2kgKyAxXSAmJiAoaSA9PSBMW2ldIHx8IFJPVC5STkcuZ2V0VW5pZm9ybSgpID4gcmFuZCkpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIC8qIGRpZyByaWdodCBhbHNvIGlmIHRoZSBjZWxsIGlzIHNlcGFyYXRlZCwgc28gaXQgZ2V0cyBjb25uZWN0ZWQgdG8gdGhlIHJlc3Qgb2YgbWF6ZSAqLwogICAgICAgICAgICAgICAgdGhpcy5fYWRkVG9MaXN0KGksIEwsIFIpOwogICAgICAgICAgICAgICAgbWFwW3ggKyAxXVt5XSA9IDA7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUZyb21MaXN0KGksIEwsIFIpOwogICAgICAgIH0KCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl93aWR0aDsgaSsrKQogICAgICAgIHsKICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9oZWlnaHQ7IGorKykKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgY2FsbGJhY2soaSwgaiwgbWFwW2ldW2pdKTsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICB9OwoKICAgIC8qKgogICAgICogUmVtb3ZlICJpIiBmcm9tIGl0cyBsaXN0CiAgICAgKi8KICAgIFJPVC5NYXAuRWxsZXJNYXplLnByb3RvdHlwZS5fcmVtb3ZlRnJvbUxpc3QgPSBmdW5jdGlvbihpLCBMLCBSKQogICAgewogICAgICAgIFJbTFtpXV0gPSBSW2ldOwogICAgICAgIExbUltpXV0gPSBMW2ldOwogICAgICAgIFJbaV0gPSBpOwogICAgICAgIExbaV0gPSBpOwogICAgfTsKCiAgICAvKioKICAgICAqIEpvaW4gbGlzdHMgd2l0aCAiaSIgYW5kICJpKzEiCiAgICAgKi8KICAgIFJPVC5NYXAuRWxsZXJNYXplLnByb3RvdHlwZS5fYWRkVG9MaXN0ID0gZnVuY3Rpb24oaSwgTCwgUikKICAgIHsKICAgICAgICBSW0xbaSArIDFdXSA9IFJbaV07CiAgICAgICAgTFtSW2ldXSA9IExbaSArIDFdOwogICAgICAgIFJbaV0gPSBpICsgMTsKICAgICAgICBMW2kgKyAxXSA9IGk7CiAgICB9OwogICAgLyoqCiAgICAgKiBAY2xhc3MgQ2VsbHVsYXIgYXV0b21hdG9uIG1hcCBnZW5lcmF0b3IKICAgICAqIEBhdWdtZW50cyBST1QuTWFwCiAgICAgKiBAcGFyYW0ge2ludH0gW3dpZHRoPVJPVC5ERUZBVUxUX1dJRFRIXQogICAgICogQHBhcmFtIHtpbnR9IFtoZWlnaHQ9Uk9ULkRFRkFVTFRfSEVJR0hUXQogICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zCiAgICAgKiBAcGFyYW0ge2ludFtdfSBbb3B0aW9ucy5ib3JuXSBMaXN0IG9mIG5laWdoYm9yIGNvdW50cyBmb3IgYSBuZXcgY2VsbCB0byBiZSBib3JuIGluIGVtcHR5IHNwYWNlCiAgICAgKiBAcGFyYW0ge2ludFtdfSBbb3B0aW9ucy5zdXJ2aXZlXSBMaXN0IG9mIG5laWdoYm9yIGNvdW50cyBmb3IgYW4gZXhpc3RpbmcgIGNlbGwgdG8gc3Vydml2ZQogICAgICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLnRvcG9sb2d5XSBUb3BvbG9neSA0IG9yIDYgb3IgOAogICAgICovCiAgICBST1QuTWFwLkNlbGx1bGFyID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgb3B0aW9ucykKICAgIHsKICAgICAgICBST1QuTWFwLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCk7CiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHsKICAgICAgICAgICAgYm9ybjogWzUsIDYsIDcsIDhdLAogICAgICAgICAgICBzdXJ2aXZlOiBbNCwgNSwgNiwgNywgOF0sCiAgICAgICAgICAgIHRvcG9sb2d5OiA4CiAgICAgICAgfTsKICAgICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7CgogICAgICAgIHRoaXMuX2RpcnMgPSBST1QuRElSU1t0aGlzLl9vcHRpb25zLnRvcG9sb2d5XTsKICAgICAgICB0aGlzLl9tYXAgPSB0aGlzLl9maWxsTWFwKDApOwogICAgfTsKICAgIFJPVC5NYXAuQ2VsbHVsYXIuZXh0ZW5kKFJPVC5NYXApOwoKICAgIC8qKgogICAgICogRmlsbCB0aGUgbWFwIHdpdGggcmFuZG9tIHZhbHVlcwogICAgICogQHBhcmFtIHtmbG9hdH0gcHJvYmFiaWxpdHkgUHJvYmFiaWxpdHkgZm9yIGEgY2VsbCB0byBiZWNvbWUgYWxpdmU7IDAgPSBhbGwgZW1wdHksIDEgPSBhbGwgZnVsbAogICAgICovCiAgICBST1QuTWFwLkNlbGx1bGFyLnByb3RvdHlwZS5yYW5kb21pemUgPSBmdW5jdGlvbihwcm9iYWJpbGl0eSkKICAgIHsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3dpZHRoOyBpKyspCiAgICAgICAgewogICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX2hlaWdodDsgaisrKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICB0aGlzLl9tYXBbaV1bal0gPSAoUk9ULlJORy5nZXRVbmlmb3JtKCkgPCBwcm9iYWJpbGl0eSA/IDEgOiAwKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgIH07CgogICAgLyoqCiAgICAgKiBDaGFuZ2Ugb3B0aW9ucy4KICAgICAqIEBzZWUgUk9ULk1hcC5DZWxsdWxhcgogICAgICovCiAgICBST1QuTWFwLkNlbGx1bGFyLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykKICAgIHsKICAgICAgICBmb3IgKHZhciBwIGluIG9wdGlvbnMpCiAgICAgICAgewogICAgICAgICAgICB0aGlzLl9vcHRpb25zW3BdID0gb3B0aW9uc1twXTsKICAgICAgICB9CiAgICB9OwoKICAgIFJPVC5NYXAuQ2VsbHVsYXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHgsIHksIHZhbHVlKQogICAgewogICAgICAgIHRoaXMuX21hcFt4XVt5XSA9IHZhbHVlOwogICAgfTsKCiAgICBST1QuTWFwLkNlbGx1bGFyLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykKICAgIHsKICAgICAgICB2YXIgbmV3TWFwID0gdGhpcy5fZmlsbE1hcCgwKTsKICAgICAgICB2YXIgYm9ybiA9IHRoaXMuX29wdGlvbnMuYm9ybjsKICAgICAgICB2YXIgc3Vydml2ZSA9IHRoaXMuX29wdGlvbnMuc3Vydml2ZTsKCgogICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5faGVpZ2h0OyBqKyspCiAgICAgICAgewogICAgICAgICAgICB2YXIgd2lkdGhTdGVwID0gMTsKICAgICAgICAgICAgdmFyIHdpZHRoU3RhcnQgPSAwOwogICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy50b3BvbG9neSA9PSA2KQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICB3aWR0aFN0ZXAgPSAyOwogICAgICAgICAgICAgICAgd2lkdGhTdGFydCA9IGogJSAyOwogICAgICAgICAgICB9CgogICAgICAgICAgICBmb3IgKHZhciBpID0gd2lkdGhTdGFydDsgaSA8IHRoaXMuX3dpZHRoOyBpICs9IHdpZHRoU3RlcCkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdmFyIGN1ciA9IHRoaXMuX21hcFtpXVtqXTsKICAgICAgICAgICAgICAgIHZhciBuY291bnQgPSB0aGlzLl9nZXROZWlnaGJvcnMoaSwgaik7CgogICAgICAgICAgICAgICAgaWYgKGN1ciAmJiBzdXJ2aXZlLmluZGV4T2YobmNvdW50KSAhPSAtMSkKICAgICAgICAgICAgICAgIHsgLyogc3Vydml2ZSAqLwogICAgICAgICAgICAgICAgICAgIG5ld01hcFtpXVtqXSA9IDE7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBlbHNlIGlmICghY3VyICYmIGJvcm4uaW5kZXhPZihuY291bnQpICE9IC0xKQogICAgICAgICAgICAgICAgeyAvKiBib3JuICovCiAgICAgICAgICAgICAgICAgICAgbmV3TWFwW2ldW2pdID0gMTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgdGhpcy5fbWFwID0gbmV3TWFwOwogICAgICAgIGNhbGxiYWNrICYmIHRoaXMuX3NlcnZpY2VDYWxsYmFjayhjYWxsYmFjayk7CiAgICB9OwoKICAgIFJPVC5NYXAuQ2VsbHVsYXIucHJvdG90eXBlLl9zZXJ2aWNlQ2FsbGJhY2sgPSBmdW5jdGlvbihjYWxsYmFjaykKICAgIHsKICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX2hlaWdodDsgaisrKQogICAgICAgIHsKICAgICAgICAgICAgdmFyIHdpZHRoU3RlcCA9IDE7CiAgICAgICAgICAgIHZhciB3aWR0aFN0YXJ0ID0gMDsKICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMudG9wb2xvZ3kgPT0gNikKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgd2lkdGhTdGVwID0gMjsKICAgICAgICAgICAgICAgIHdpZHRoU3RhcnQgPSBqICUgMjsKICAgICAgICAgICAgfQogICAgICAgICAgICBmb3IgKHZhciBpID0gd2lkdGhTdGFydDsgaSA8IHRoaXMuX3dpZHRoOyBpICs9IHdpZHRoU3RlcCkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgY2FsbGJhY2soaSwgaiwgdGhpcy5fbWFwW2ldW2pdKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH07CgogICAgLyoqCiAgICAgKiBHZXQgbmVpZ2hib3IgY291bnQgYXQgW2ksal0gaW4gdGhpcy5fbWFwCiAgICAgKi8KICAgIFJPVC5NYXAuQ2VsbHVsYXIucHJvdG90eXBlLl9nZXROZWlnaGJvcnMgPSBmdW5jdGlvbihjeCwgY3kpCiAgICB7CiAgICAgICAgdmFyIHJlc3VsdCA9IDA7CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9kaXJzLmxlbmd0aDsgaSsrKQogICAgICAgIHsKICAgICAgICAgICAgdmFyIGRpciA9IHRoaXMuX2RpcnNbaV07CiAgICAgICAgICAgIHZhciB4ID0gY3ggKyBkaXJbMF07CiAgICAgICAgICAgIHZhciB5ID0gY3kgKyBkaXJbMV07CgogICAgICAgICAgICBpZiAoeCA8IDAgfHwgeCA+PSB0aGlzLl93aWR0aCB8fCB5IDwgMCB8fCB5ID49IHRoaXMuX2hlaWdodCkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmVzdWx0ICs9ICh0aGlzLl9tYXBbeF1beV0gPT0gMSA/IDEgOiAwKTsKICAgICAgICB9CgogICAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9OwoKICAgIC8qKgogICAgICogTWFrZSBzdXJlIGV2ZXJ5IG5vbi13YWxsIHNwYWNlIGlzIGFjY2Vzc2libGUuCiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayB0byBjYWxsIHRvIGRpc3BsYXkgbWFwIHdoZW4gZG8KICAgICAqIEBwYXJhbSB7aW50fSB2YWx1ZSB0byBjb25zaWRlciBlbXB0eSBzcGFjZSAtIGRlZmF1bHRzIHRvIDAKICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIHRvIGNhbGwgd2hlbiBhIG5ldyBjb25uZWN0aW9uIGlzIG1hZGUKICAgICAqLwogICAgUk9ULk1hcC5DZWxsdWxhci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB2YWx1ZSwgY29ubmVjdGlvbkNhbGxiYWNrKQogICAgewogICAgICAgIGlmICghdmFsdWUpIHZhbHVlID0gMDsKCiAgICAgICAgdmFyIGFsbEZyZWVTcGFjZSA9IFtdOwogICAgICAgIHZhciBub3RDb25uZWN0ZWQgPSB7fTsKCiAgICAgICAgLy8gZmluZCBhbGwgZnJlZSBzcGFjZQogICAgICAgIHZhciB3aWR0aFN0ZXAgPSAxOwogICAgICAgIHZhciB3aWR0aFN0YXJ0cyA9IFswLCAwXTsKICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy50b3BvbG9neSA9PSA2KQogICAgICAgIHsKICAgICAgICAgICAgd2lkdGhTdGVwID0gMjsKICAgICAgICAgICAgd2lkdGhTdGFydHMgPSBbMCwgMV07CiAgICAgICAgfQogICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgdGhpcy5faGVpZ2h0OyB5KyspCiAgICAgICAgewogICAgICAgICAgICBmb3IgKHZhciB4ID0gd2lkdGhTdGFydHNbeSAlIDJdOyB4IDwgdGhpcy5fd2lkdGg7IHggKz0gd2lkdGhTdGVwKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZnJlZVNwYWNlKHgsIHksIHZhbHVlKSkKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IFt4LCB5XTsKICAgICAgICAgICAgICAgICAgICBub3RDb25uZWN0ZWRbdGhpcy5fcG9pbnRLZXkocCldID0gcDsKICAgICAgICAgICAgICAgICAgICBhbGxGcmVlU3BhY2UucHVzaChbeCwgeV0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHZhciBzdGFydCA9IGFsbEZyZWVTcGFjZVtST1QuUk5HLmdldFVuaWZvcm1JbnQoMCwgYWxsRnJlZVNwYWNlLmxlbmd0aCAtIDEpXTsKCiAgICAgICAgdmFyIGtleSA9IHRoaXMuX3BvaW50S2V5KHN0YXJ0KTsKICAgICAgICB2YXIgY29ubmVjdGVkID0ge307CiAgICAgICAgY29ubmVjdGVkW2tleV0gPSBzdGFydDsKICAgICAgICBkZWxldGUgbm90Q29ubmVjdGVkW2tleV07CgogICAgICAgIC8vIGZpbmQgd2hhdCdzIGNvbm5lY3RlZCB0byB0aGUgc3RhcnRpbmcgcG9pbnQKICAgICAgICB0aGlzLl9maW5kQ29ubmVjdGVkKGNvbm5lY3RlZCwgbm90Q29ubmVjdGVkLCBbc3RhcnRdLCBmYWxzZSwgdmFsdWUpOwoKICAgICAgICB3aGlsZSAoT2JqZWN0LmtleXMobm90Q29ubmVjdGVkKS5sZW5ndGggPiAwKQogICAgICAgIHsKICAgICAgICAgICAgLy8gZmluZCB0d28gcG9pbnRzIGZyb20gbm90Q29ubmVjdGVkIHRvIGNvbm5lY3RlZAogICAgICAgICAgICB2YXIgcCA9IHRoaXMuX2dldEZyb21Ubyhjb25uZWN0ZWQsIG5vdENvbm5lY3RlZCk7CiAgICAgICAgICAgIHZhciBmcm9tID0gcFswXTsgLy8gbm90Q29ubmVjdGVkCiAgICAgICAgICAgIHZhciB0byA9IHBbMV07IC8vIGNvbm5lY3RlZAoKICAgICAgICAgICAgLy8gZmluZCBldmVyeXRoaW5nIGNvbm5lY3RlZCB0byB0aGUgc3RhcnRpbmcgcG9pbnQKICAgICAgICAgICAgdmFyIGxvY2FsID0ge307CiAgICAgICAgICAgIGxvY2FsW3RoaXMuX3BvaW50S2V5KGZyb20pXSA9IGZyb207CiAgICAgICAgICAgIHRoaXMuX2ZpbmRDb25uZWN0ZWQobG9jYWwsIG5vdENvbm5lY3RlZCwgW2Zyb21dLCB0cnVlLCB2YWx1ZSk7CgogICAgICAgICAgICAvLyBjb25uZWN0IHRvIGEgY29ubmVjdGVkIGNlbGwKICAgICAgICAgICAgdmFyIHR1bm5lbEZuID0gKHRoaXMuX29wdGlvbnMudG9wb2xvZ3kgPT0gNiA/IHRoaXMuX3R1bm5lbFRvQ29ubmVjdGVkNiA6IHRoaXMuX3R1bm5lbFRvQ29ubmVjdGVkKTsKICAgICAgICAgICAgdHVubmVsRm4uY2FsbCh0aGlzLCB0bywgZnJvbSwgY29ubmVjdGVkLCBub3RDb25uZWN0ZWQsIHZhbHVlLCBjb25uZWN0aW9uQ2FsbGJhY2spOwoKICAgICAgICAgICAgLy8gbm93IGFsbCBvZiBsb2NhbCBpcyBjb25uZWN0ZWQKICAgICAgICAgICAgZm9yICh2YXIgayBpbiBsb2NhbCkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdmFyIHBwID0gbG9jYWxba107CiAgICAgICAgICAgICAgICB0aGlzLl9tYXBbcHBbMF1dW3BwWzFdXSA9IHZhbHVlOwogICAgICAgICAgICAgICAgY29ubmVjdGVkW2tdID0gcHA7CiAgICAgICAgICAgICAgICBkZWxldGUgbm90Q29ubmVjdGVkW2tdOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBjYWxsYmFjayAmJiB0aGlzLl9zZXJ2aWNlQ2FsbGJhY2soY2FsbGJhY2spOwogICAgfTsKCiAgICAvKioKICAgICAqIEZpbmQgcmFuZG9tIHBvaW50cyB0byBjb25uZWN0LiBTZWFyY2ggZm9yIHRoZSBjbG9zZXN0IHBvaW50IGluIHRoZSBsYXJnZXIgc3BhY2UuCiAgICAgKiBUaGlzIGlzIHRvIG1pbmltaXplIHRoZSBsZW5ndGggb2YgdGhlIHBhc3NhZ2Ugd2hpbGUgbWFpbnRhaW5pbmcgZ29vZCBwZXJmb3JtYW5jZS4KICAgICAqLwogICAgUk9ULk1hcC5DZWxsdWxhci5wcm90b3R5cGUuX2dldEZyb21UbyA9IGZ1bmN0aW9uKGNvbm5lY3RlZCwgbm90Q29ubmVjdGVkKQogICAgewogICAgICAgIHZhciBmcm9tLCB0bywgZDsKICAgICAgICB2YXIgY29ubmVjdGVkS2V5cyA9IE9iamVjdC5rZXlzKGNvbm5lY3RlZCk7CiAgICAgICAgdmFyIG5vdENvbm5lY3RlZEtleXMgPSBPYmplY3Qua2V5cyhub3RDb25uZWN0ZWQpOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKQogICAgICAgIHsKICAgICAgICAgICAgaWYgKGNvbm5lY3RlZEtleXMubGVuZ3RoIDwgbm90Q29ubmVjdGVkS2V5cy5sZW5ndGgpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHZhciBrZXlzID0gY29ubmVjdGVkS2V5czsKICAgICAgICAgICAgICAgIHRvID0gY29ubmVjdGVkW2tleXNbUk9ULlJORy5nZXRVbmlmb3JtSW50KDAsIGtleXMubGVuZ3RoIC0gMSldXTsKICAgICAgICAgICAgICAgIGZyb20gPSB0aGlzLl9nZXRDbG9zZXN0KHRvLCBub3RDb25uZWN0ZWQpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdmFyIGtleXMgPSBub3RDb25uZWN0ZWRLZXlzOwogICAgICAgICAgICAgICAgZnJvbSA9IG5vdENvbm5lY3RlZFtrZXlzW1JPVC5STkcuZ2V0VW5pZm9ybUludCgwLCBrZXlzLmxlbmd0aCAtIDEpXV07CiAgICAgICAgICAgICAgICB0byA9IHRoaXMuX2dldENsb3Nlc3QoZnJvbSwgY29ubmVjdGVkKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBkID0gKGZyb21bMF0gLSB0b1swXSkgKiAoZnJvbVswXSAtIHRvWzBdKSArIChmcm9tWzFdIC0gdG9bMV0pICogKGZyb21bMV0gLSB0b1sxXSk7CiAgICAgICAgICAgIGlmIChkIDwgNjQpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIC8vIGNvbnNvbGUubG9nKCI+Pj4gY29ubmVjdGVkPSIgKyB0byArICIgbm90Q29ubmVjdGVkPSIgKyBmcm9tICsgIiBkaXN0PSIgKyBkKTsKICAgICAgICByZXR1cm4gW2Zyb20sIHRvXTsKICAgIH07CgogICAgUk9ULk1hcC5DZWxsdWxhci5wcm90b3R5cGUuX2dldENsb3Nlc3QgPSBmdW5jdGlvbihwb2ludCwgc3BhY2UpCiAgICB7CiAgICAgICAgdmFyIG1pblBvaW50ID0gbnVsbDsKICAgICAgICB2YXIgbWluRGlzdCA9IG51bGw7CiAgICAgICAgZm9yIChrIGluIHNwYWNlKQogICAgICAgIHsKICAgICAgICAgICAgdmFyIHAgPSBzcGFjZVtrXTsKICAgICAgICAgICAgdmFyIGQgPSAocFswXSAtIHBvaW50WzBdKSAqIChwWzBdIC0gcG9pbnRbMF0pICsgKHBbMV0gLSBwb2ludFsxXSkgKiAocFsxXSAtIHBvaW50WzFdKTsKICAgICAgICAgICAgaWYgKG1pbkRpc3QgPT0gbnVsbCB8fCBkIDwgbWluRGlzdCkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgbWluRGlzdCA9IGQ7CiAgICAgICAgICAgICAgICBtaW5Qb2ludCA9IHA7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIG1pblBvaW50OwogICAgfTsKCiAgICBST1QuTWFwLkNlbGx1bGFyLnByb3RvdHlwZS5fZmluZENvbm5lY3RlZCA9IGZ1bmN0aW9uKGNvbm5lY3RlZCwgbm90Q29ubmVjdGVkLCBzdGFjaywga2VlcE5vdENvbm5lY3RlZCwgdmFsdWUpCiAgICB7CiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApCiAgICAgICAgewogICAgICAgICAgICB2YXIgcCA9IHN0YWNrLnNwbGljZSgwLCAxKVswXTsKICAgICAgICAgICAgdmFyIHRlc3RzOwoKICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMudG9wb2xvZ3kgPT0gNikKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdGVzdHMgPSBbCiAgICAgICAgICAgICAgICBbcFswXSArIDIsIHBbMV1dLAogICAgICAgICAgICAgICAgW3BbMF0gKyAxLCBwWzFdIC0gMV0sCiAgICAgICAgICAgICAgICBbcFswXSAtIDEsIHBbMV0gLSAxXSwKICAgICAgICAgICAgICAgIFtwWzBdIC0gMiwgcFsxXV0sCiAgICAgICAgICAgICAgICBbcFswXSAtIDEsIHBbMV0gKyAxXSwKICAgICAgICAgICAgICAgIFtwWzBdICsgMSwgcFsxXSArIDFdLAogICAgICAgICAgICBdOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdGVzdHMgPSBbCiAgICAgICAgICAgICAgICBbcFswXSArIDEsIHBbMV1dLAogICAgICAgICAgICAgICAgW3BbMF0gLSAxLCBwWzFdXSwKICAgICAgICAgICAgICAgIFtwWzBdLCBwWzFdICsgMV0sCiAgICAgICAgICAgICAgICBbcFswXSwgcFsxXSAtIDFdCiAgICAgICAgICAgIF07CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVzdHMubGVuZ3RoOyBpKyspCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9wb2ludEtleSh0ZXN0c1tpXSk7CiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGVkW2tleV0gPT0gbnVsbCAmJiB0aGlzLl9mcmVlU3BhY2UodGVzdHNbaV1bMF0sIHRlc3RzW2ldWzFdLCB2YWx1ZSkpCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkW2tleV0gPSB0ZXN0c1tpXTsKICAgICAgICAgICAgICAgICAgICBpZiAoIWtlZXBOb3RDb25uZWN0ZWQpCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbm90Q29ubmVjdGVkW2tleV07CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGVzdHNbaV0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfTsKCiAgICBST1QuTWFwLkNlbGx1bGFyLnByb3RvdHlwZS5fdHVubmVsVG9Db25uZWN0ZWQgPSBmdW5jdGlvbih0bywgZnJvbSwgY29ubmVjdGVkLCBub3RDb25uZWN0ZWQsIHZhbHVlLCBjb25uZWN0aW9uQ2FsbGJhY2spCiAgICB7CiAgICAgICAgdmFyIGtleSA9IHRoaXMuX3BvaW50S2V5KGZyb20pOwogICAgICAgIHZhciBhLCBiOwogICAgICAgIGlmIChmcm9tWzBdIDwgdG9bMF0pCiAgICAgICAgewogICAgICAgICAgICBhID0gZnJvbTsKICAgICAgICAgICAgYiA9IHRvOwogICAgICAgIH0KICAgICAgICBlbHNlCiAgICAgICAgewogICAgICAgICAgICBhID0gdG87CiAgICAgICAgICAgIGIgPSBmcm9tOwogICAgICAgIH0KICAgICAgICBmb3IgKHZhciB4eCA9IGFbMF07IHh4IDw9IGJbMF07IHh4KyspCiAgICAgICAgewogICAgICAgICAgICB0aGlzLl9tYXBbeHhdW2FbMV1dID0gdmFsdWU7CiAgICAgICAgICAgIHZhciBwID0gW3h4LCBhWzFdXTsKICAgICAgICAgICAgdmFyIHBrZXkgPSB0aGlzLl9wb2ludEtleShwKTsKICAgICAgICAgICAgY29ubmVjdGVkW3BrZXldID0gcDsKICAgICAgICAgICAgZGVsZXRlIG5vdENvbm5lY3RlZFtwa2V5XTsKICAgICAgICB9CiAgICAgICAgaWYgKGNvbm5lY3Rpb25DYWxsYmFjayAmJiBhWzBdIDwgYlswXSkKICAgICAgICB7CiAgICAgICAgICAgIGNvbm5lY3Rpb25DYWxsYmFjayhhLCBbYlswXSwgYVsxXV0pOwogICAgICAgIH0KCiAgICAgICAgLy8geCBpcyBub3cgZml4ZWQKICAgICAgICB2YXIgeCA9IGJbMF07CgogICAgICAgIGlmIChmcm9tWzFdIDwgdG9bMV0pCiAgICAgICAgewogICAgICAgICAgICBhID0gZnJvbTsKICAgICAgICAgICAgYiA9IHRvOwogICAgICAgIH0KICAgICAgICBlbHNlCiAgICAgICAgewogICAgICAgICAgICBhID0gdG87CiAgICAgICAgICAgIGIgPSBmcm9tOwogICAgICAgIH0KICAgICAgICBmb3IgKHZhciB5eSA9IGFbMV07IHl5IDwgYlsxXTsgeXkrKykKICAgICAgICB7CiAgICAgICAgICAgIHRoaXMuX21hcFt4XVt5eV0gPSB2YWx1ZTsKICAgICAgICAgICAgdmFyIHAgPSBbeCwgeXldOwogICAgICAgICAgICB2YXIgcGtleSA9IHRoaXMuX3BvaW50S2V5KHApOwogICAgICAgICAgICBjb25uZWN0ZWRbcGtleV0gPSBwOwogICAgICAgICAgICBkZWxldGUgbm90Q29ubmVjdGVkW3BrZXldOwogICAgICAgIH0KICAgICAgICBpZiAoY29ubmVjdGlvbkNhbGxiYWNrICYmIGFbMV0gPCBiWzFdKQogICAgICAgIHsKICAgICAgICAgICAgY29ubmVjdGlvbkNhbGxiYWNrKFtiWzBdLCBhWzFdXSwgW2JbMF0sIGJbMV1dKTsKICAgICAgICB9CiAgICB9CgogICAgUk9ULk1hcC5DZWxsdWxhci5wcm90b3R5cGUuX3R1bm5lbFRvQ29ubmVjdGVkNiA9IGZ1bmN0aW9uKHRvLCBmcm9tLCBjb25uZWN0ZWQsIG5vdENvbm5lY3RlZCwgdmFsdWUsIGNvbm5lY3Rpb25DYWxsYmFjaykKICAgIHsKICAgICAgICB2YXIgYSwgYjsKICAgICAgICBpZiAoZnJvbVswXSA8IHRvWzBdKQogICAgICAgIHsKICAgICAgICAgICAgYSA9IGZyb207CiAgICAgICAgICAgIGIgPSB0bzsKICAgICAgICB9CiAgICAgICAgZWxzZQogICAgICAgIHsKICAgICAgICAgICAgYSA9IHRvOwogICAgICAgICAgICBiID0gZnJvbTsKICAgICAgICB9CgogICAgICAgIC8vIHR1bm5lbCBkaWFnb25hbGx5IHVudGlsIGhvcml6b250YWxseSBsZXZlbAogICAgICAgIHZhciB4eCA9IGFbMF07CiAgICAgICAgdmFyIHl5ID0gYVsxXTsKICAgICAgICB3aGlsZSAoISh4eCA9PSBiWzBdICYmIHl5ID09IGJbMV0pKQogICAgICAgIHsKICAgICAgICAgICAgdmFyIHN0ZXBXaWR0aCA9IDI7CiAgICAgICAgICAgIGlmICh5eSA8IGJbMV0pCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHl5Kys7CiAgICAgICAgICAgICAgICBzdGVwV2lkdGggPSAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgaWYgKHl5ID4gYlsxXSkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgeXktLTsKICAgICAgICAgICAgICAgIHN0ZXBXaWR0aCA9IDE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHh4IDwgYlswXSkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgeHggKz0gc3RlcFdpZHRoCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSBpZiAoeHggPiBiWzBdKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICB4eCAtPSBzdGVwV2lkdGgKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIGlmIChiWzFdICUgMikKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgLy8gV29uJ3Qgc3RlcCBvdXRzaWRlIG1hcCBpZiBkZXN0aW5hdGlvbiBvbiBpcyBtYXAncyByaWdodCBlZGdlCiAgICAgICAgICAgICAgICB4eCAtPSBzdGVwV2lkdGg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAvLyBkaXR0byBmb3IgbGVmdCBlZGdlCiAgICAgICAgICAgICAgICB4eCArPSBzdGVwV2lkdGg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5fbWFwW3h4XVt5eV0gPSB2YWx1ZTsKICAgICAgICAgICAgdmFyIHAgPSBbeHgsIHl5XQogICAgICAgICAgICB2YXIgcGtleSA9IHRoaXMuX3BvaW50S2V5KHApOwogICAgICAgICAgICBjb25uZWN0ZWRbcGtleV0gPSBwOwogICAgICAgICAgICBkZWxldGUgbm90Q29ubmVjdGVkW3BrZXldOwogICAgICAgIH0KCiAgICAgICAgaWYgKGNvbm5lY3Rpb25DYWxsYmFjaykKICAgICAgICB7CiAgICAgICAgICAgIGNvbm5lY3Rpb25DYWxsYmFjayhmcm9tLCB0byk7CiAgICAgICAgfQogICAgfQoKICAgIFJPVC5NYXAuQ2VsbHVsYXIucHJvdG90eXBlLl9mcmVlU3BhY2UgPSBmdW5jdGlvbih4LCB5LCB2YWx1ZSkKICAgIHsKICAgICAgICByZXR1cm4geCA+PSAwICYmIHggPCB0aGlzLl93aWR0aCAmJiB5ID49IDAgJiYgeSA8IHRoaXMuX2hlaWdodCAmJiB0aGlzLl9tYXBbeF1beV0gPT0gdmFsdWU7CiAgICB9CgogICAgUk9ULk1hcC5DZWxsdWxhci5wcm90b3R5cGUuX3BvaW50S2V5ID0gZnVuY3Rpb24ocCkKICAgIHsKICAgICAgICByZXR1cm4gcFswXSArICIuIiArIHBbMV07CiAgICB9CiAgICAvKioKICAgICAqIEBjbGFzcyBEdW5nZW9uIG1hcDogaGFzIHJvb21zIGFuZCBjb3JyaWRvcnMKICAgICAqIEBhdWdtZW50cyBST1QuTWFwCiAgICAgKi8KICAgIFJPVC5NYXAuRHVuZ2VvbiA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpCiAgICB7CiAgICAgICAgUk9ULk1hcC5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQpOwogICAgICAgIHRoaXMuX3Jvb21zID0gW107IC8qIGxpc3Qgb2YgYWxsIHJvb21zICovCiAgICAgICAgdGhpcy5fY29ycmlkb3JzID0gW107CiAgICB9OwogICAgUk9ULk1hcC5EdW5nZW9uLmV4dGVuZChST1QuTWFwKTsKCiAgICAvKioKICAgICAqIEdldCBhbGwgZ2VuZXJhdGVkIHJvb21zCiAgICAgKiBAcmV0dXJucyB7Uk9ULk1hcC5GZWF0dXJlLlJvb21bXX0KICAgICAqLwogICAgUk9ULk1hcC5EdW5nZW9uLnByb3RvdHlwZS5nZXRSb29tcyA9IGZ1bmN0aW9uKCkKICAgIHsKICAgICAgICByZXR1cm4gdGhpcy5fcm9vbXM7CiAgICB9OwoKICAgIC8qKgogICAgICogR2V0IGFsbCBnZW5lcmF0ZWQgY29ycmlkb3JzCiAgICAgKiBAcmV0dXJucyB7Uk9ULk1hcC5GZWF0dXJlLkNvcnJpZG9yW119CiAgICAgKi8KICAgIFJPVC5NYXAuRHVuZ2Vvbi5wcm90b3R5cGUuZ2V0Q29ycmlkb3JzID0gZnVuY3Rpb24oKQogICAgewogICAgICAgIHJldHVybiB0aGlzLl9jb3JyaWRvcnM7CiAgICB9OwogICAgLyoqCiAgICAgKiBAY2xhc3MgUmFuZG9tIGR1bmdlb24gZ2VuZXJhdG9yIHVzaW5nIGh1bWFuLWxpa2UgZGlnZ2luZyBwYXR0ZXJucy4KICAgICAqIEhlYXZpbHkgYmFzZWQgb24gTWlrZSBBbmRlcnNvbidzIGlkZWFzIGZyb20gdGhlICJUeXJhbnQiIGFsZ28sIG1lbnRpb25lZCBhdAogICAgICogaHR0cDovL3d3dy5yb2d1ZWJhc2luLnJvZ3VlbGlrZWRldmVsb3BtZW50Lm9yZy9pbmRleC5waHA/dGl0bGU9RHVuZ2Vvbi1CdWlsZGluZ19BbGdvcml0aG0uCiAgICAgKiBAYXVnbWVudHMgUk9ULk1hcC5EdW5nZW9uCiAgICAgKi8KICAgIFJPVC5NYXAuRGlnZ2VyID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgb3B0aW9ucykKICAgIHsKICAgICAgICBST1QuTWFwLkR1bmdlb24uY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0KTsKCiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHsKICAgICAgICAgICAgcm9vbVdpZHRoOiBbMywgOV0sCiAgICAgICAgICAgIC8qIHJvb20gbWluaW11bSBhbmQgbWF4aW11bSB3aWR0aCAqLwogICAgICAgICAgICByb29tSGVpZ2h0OiBbMywgNV0sCiAgICAgICAgICAgIC8qIHJvb20gbWluaW11bSBhbmQgbWF4aW11bSBoZWlnaHQgKi8KICAgICAgICAgICAgY29ycmlkb3JMZW5ndGg6IFszLCAxMF0sCiAgICAgICAgICAgIC8qIGNvcnJpZG9yIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoICovCiAgICAgICAgICAgIGR1Z1BlcmNlbnRhZ2U6IDAuMiwKICAgICAgICAgICAgLyogd2Ugc3RvcCBhZnRlciB0aGlzIHBlcmNlbnRhZ2Ugb2YgbGV2ZWwgYXJlYSBoYXMgYmVlbiBkdWcgb3V0ICovCiAgICAgICAgICAgIHRpbWVMaW1pdDogMTAwMCAvKiB3ZSBzdG9wIGFmdGVyIHRoaXMgbXVjaCB0aW1lIGhhcyBwYXNzZWQgKG1zZWMpICovCiAgICAgICAgfTsKICAgICAgICBmb3IgKHZhciBwIGluIG9wdGlvbnMpCiAgICAgICAgewogICAgICAgICAgICB0aGlzLl9vcHRpb25zW3BdID0gb3B0aW9uc1twXTsKICAgICAgICB9CgogICAgICAgIHRoaXMuX2ZlYXR1cmVzID0gewogICAgICAgICAgICAiUm9vbSI6IDQsCiAgICAgICAgICAgICJDb3JyaWRvciI6IDQKICAgICAgICB9OwogICAgICAgIHRoaXMuX2ZlYXR1cmVBdHRlbXB0cyA9IDIwOyAvKiBob3cgbWFueSB0aW1lcyBkbyB3ZSB0cnkgdG8gY3JlYXRlIGEgZmVhdHVyZSBvbiBhIHN1aXRhYmxlIHdhbGwgKi8KICAgICAgICB0aGlzLl93YWxscyA9IHt9OyAvKiB0aGVzZSBhcmUgYXZhaWxhYmxlIGZvciBkaWdnaW5nICovCgogICAgICAgIHRoaXMuX2RpZ0NhbGxiYWNrID0gdGhpcy5fZGlnQ2FsbGJhY2suYmluZCh0aGlzKTsKICAgICAgICB0aGlzLl9jYW5CZUR1Z0NhbGxiYWNrID0gdGhpcy5fY2FuQmVEdWdDYWxsYmFjay5iaW5kKHRoaXMpOwogICAgICAgIHRoaXMuX2lzV2FsbENhbGxiYWNrID0gdGhpcy5faXNXYWxsQ2FsbGJhY2suYmluZCh0aGlzKTsKICAgICAgICB0aGlzLl9wcmlvcml0eVdhbGxDYWxsYmFjayA9IHRoaXMuX3ByaW9yaXR5V2FsbENhbGxiYWNrLmJpbmQodGhpcyk7CiAgICB9OwogICAgUk9ULk1hcC5EaWdnZXIuZXh0ZW5kKFJPVC5NYXAuRHVuZ2Vvbik7CgogICAgLyoqCiAgICAgKiBDcmVhdGUgYSBtYXAKICAgICAqIEBzZWUgUk9ULk1hcCNjcmVhdGUKICAgICAqLwogICAgUk9ULk1hcC5EaWdnZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKQogICAgewogICAgICAgIHRoaXMuX3Jvb21zID0gW107CiAgICAgICAgdGhpcy5fY29ycmlkb3JzID0gW107CiAgICAgICAgdGhpcy5fbWFwID0gdGhpcy5fZmlsbE1hcCgxKTsKICAgICAgICB0aGlzLl93YWxscyA9IHt9OwogICAgICAgIHRoaXMuX2R1ZyA9IDA7CiAgICAgICAgdmFyIGFyZWEgPSAodGhpcy5fd2lkdGggLSAyKSAqICh0aGlzLl9oZWlnaHQgLSAyKTsKCiAgICAgICAgdGhpcy5fZmlyc3RSb29tKCk7CgogICAgICAgIHZhciB0MSA9IERhdGUubm93KCk7CgogICAgICAgIGRvIHsKICAgICAgICAgICAgdmFyIHQyID0gRGF0ZS5ub3coKTsKICAgICAgICAgICAgaWYgKHQyIC0gdDEgPiB0aGlzLl9vcHRpb25zLnRpbWVMaW1pdCkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8qIGZpbmQgYSBnb29kIHdhbGwgKi8KICAgICAgICAgICAgdmFyIHdhbGwgPSB0aGlzLl9maW5kV2FsbCgpOwogICAgICAgICAgICBpZiAoIXdhbGwpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9IC8qIG5vIG1vcmUgd2FsbHMgKi8KCiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHdhbGwuc3BsaXQoIiwiKTsKICAgICAgICAgICAgdmFyIHggPSBwYXJzZUludChwYXJ0c1swXSk7CiAgICAgICAgICAgIHZhciB5ID0gcGFyc2VJbnQocGFydHNbMV0pOwogICAgICAgICAgICB2YXIgZGlyID0gdGhpcy5fZ2V0RGlnZ2luZ0RpcmVjdGlvbih4LCB5KTsKICAgICAgICAgICAgaWYgKCFkaXIpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9IC8qIHRoaXMgd2FsbCBpcyBub3Qgc3VpdGFibGUgKi8KCiAgICAgICAgICAgIC8vCQljb25zb2xlLmxvZygid2FsbCIsIHgsIHkpOwoKICAgICAgICAgICAgLyogdHJ5IGFkZGluZyBhIGZlYXR1cmUgKi8KICAgICAgICAgICAgdmFyIGZlYXR1cmVBdHRlbXB0cyA9IDA7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgIGZlYXR1cmVBdHRlbXB0cysrOwogICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RyeUZlYXR1cmUoeCwgeSwgZGlyWzBdLCBkaXJbMV0pKQogICAgICAgICAgICAgICAgeyAvKiBmZWF0dXJlIGFkZGVkICovCiAgICAgICAgICAgICAgICAgICAgLy9pZiAodGhpcy5fcm9vbXMubGVuZ3RoICsgdGhpcy5fY29ycmlkb3JzLmxlbmd0aCA9PSAyKSB7IHRoaXMuX3Jvb21zWzBdLmFkZERvb3IoeCwgeSk7IH0gLyogZmlyc3Qgcm9vbSBvZmljaWFsbHkgaGFzIGRvb3JzICovCiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU3Vycm91bmRpbmdXYWxscyh4LCB5KTsKICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVTdXJyb3VuZGluZ1dhbGxzKHggLSBkaXJbMF0sIHkgLSBkaXJbMV0pOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IHdoaWxlIChmZWF0dXJlQXR0ZW1wdHMgPCB0aGlzLl9mZWF0dXJlQXR0ZW1wdHMpOwoKICAgICAgICAgICAgdmFyIHByaW9yaXR5V2FsbHMgPSAwOwogICAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl93YWxscykKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dhbGxzW2lkXSA+IDEpCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHlXYWxscysrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgIH0gd2hpbGUgKHRoaXMuX2R1ZyAvIGFyZWEgPCB0aGlzLl9vcHRpb25zLmR1Z1BlcmNlbnRhZ2UgfHwgcHJpb3JpdHlXYWxscyk7IC8qIGZpeG1lIG51bWJlciBvZiBwcmlvcml0eSB3YWxscyAqLwoKICAgICAgICB0aGlzLl9hZGREb29ycygpOwoKICAgICAgICBpZiAoY2FsbGJhY2spCiAgICAgICAgewogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3dpZHRoOyBpKyspCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5faGVpZ2h0OyBqKyspCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soaSwgaiwgdGhpcy5fbWFwW2ldW2pdKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgdGhpcy5fd2FsbHMgPSB7fTsKICAgICAgICB0aGlzLl9tYXAgPSBudWxsOwoKICAgICAgICByZXR1cm4gdGhpczsKICAgIH07CgogICAgUk9ULk1hcC5EaWdnZXIucHJvdG90eXBlLl9kaWdDYWxsYmFjayA9IGZ1bmN0aW9uKHgsIHksIHZhbHVlKQogICAgewogICAgICAgIGlmICh2YWx1ZSA9PSAwIHx8IHZhbHVlID09IDIpCiAgICAgICAgeyAvKiBlbXB0eSAqLwogICAgICAgICAgICB0aGlzLl9tYXBbeF1beV0gPSAwOwogICAgICAgICAgICB0aGlzLl9kdWcrKzsKICAgICAgICB9CiAgICAgICAgZWxzZQogICAgICAgIHsgLyogd2FsbCAqLwogICAgICAgICAgICB0aGlzLl93YWxsc1t4ICsgIiwiICsgeV0gPSAxOwogICAgICAgIH0KICAgIH07CgogICAgUk9ULk1hcC5EaWdnZXIucHJvdG90eXBlLl9pc1dhbGxDYWxsYmFjayA9IGZ1bmN0aW9uKHgsIHkpCiAgICB7CiAgICAgICAgaWYgKHggPCAwIHx8IHkgPCAwIHx8IHggPj0gdGhpcy5fd2lkdGggfHwgeSA+PSB0aGlzLl9oZWlnaHQpCiAgICAgICAgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIHJldHVybiAodGhpcy5fbWFwW3hdW3ldID09IDEpOwogICAgfTsKCiAgICBST1QuTWFwLkRpZ2dlci5wcm90b3R5cGUuX2NhbkJlRHVnQ2FsbGJhY2sgPSBmdW5jdGlvbih4LCB5KQogICAgewogICAgICAgIGlmICh4IDwgMSB8fCB5IDwgMSB8fCB4ICsgMSA+PSB0aGlzLl93aWR0aCB8fCB5ICsgMSA+PSB0aGlzLl9oZWlnaHQpCiAgICAgICAgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIHJldHVybiAodGhpcy5fbWFwW3hdW3ldID09IDEpOwogICAgfTsKCiAgICBST1QuTWFwLkRpZ2dlci5wcm90b3R5cGUuX3ByaW9yaXR5V2FsbENhbGxiYWNrID0gZnVuY3Rpb24oeCwgeSkKICAgIHsKICAgICAgICB0aGlzLl93YWxsc1t4ICsgIiwiICsgeV0gPSAyOwogICAgfTsKCiAgICBST1QuTWFwLkRpZ2dlci5wcm90b3R5cGUuX2ZpcnN0Um9vbSA9IGZ1bmN0aW9uKCkKICAgIHsKICAgICAgICB2YXIgY3ggPSBNYXRoLmZsb29yKHRoaXMuX3dpZHRoIC8gMik7CiAgICAgICAgdmFyIGN5ID0gTWF0aC5mbG9vcih0aGlzLl9oZWlnaHQgLyAyKTsKICAgICAgICB2YXIgcm9vbSA9IFJPVC5NYXAuRmVhdHVyZS5Sb29tLmNyZWF0ZVJhbmRvbUNlbnRlcihjeCwgY3ksIHRoaXMuX29wdGlvbnMpOwogICAgICAgIHRoaXMuX3Jvb21zLnB1c2gocm9vbSk7CiAgICAgICAgcm9vbS5jcmVhdGUodGhpcy5fZGlnQ2FsbGJhY2spOwogICAgfTsKCiAgICAvKioKICAgICAqIEdldCBhIHN1aXRhYmxlIHdhbGwKICAgICAqLwogICAgUk9ULk1hcC5EaWdnZXIucHJvdG90eXBlLl9maW5kV2FsbCA9IGZ1bmN0aW9uKCkKICAgIHsKICAgICAgICB2YXIgcHJpbzEgPSBbXTsKICAgICAgICB2YXIgcHJpbzIgPSBbXTsKICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl93YWxscykKICAgICAgICB7CiAgICAgICAgICAgIHZhciBwcmlvID0gdGhpcy5fd2FsbHNbaWRdOwogICAgICAgICAgICBpZiAocHJpbyA9PSAyKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBwcmlvMi5wdXNoKGlkKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHByaW8xLnB1c2goaWQpOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICB2YXIgYXJyID0gKHByaW8yLmxlbmd0aCA/IHByaW8yIDogcHJpbzEpOwogICAgICAgIGlmICghYXJyLmxlbmd0aCkKICAgICAgICB7CiAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0gLyogbm8gd2FsbHMgOi8gKi8KCiAgICAgICAgdmFyIGlkID0gYXJyLnNvcnQoKS5yYW5kb20oKTsgLy8gc29ydCB0byBtYWtlIHRoZSBvcmRlciBkZXRlcm1pbmlzdGljCiAgICAgICAgZGVsZXRlIHRoaXMuX3dhbGxzW2lkXTsKCiAgICAgICAgcmV0dXJuIGlkOwogICAgfTsKCiAgICAvKioKICAgICAqIFRyaWVzIGFkZGluZyBhIGZlYXR1cmUKICAgICAqIEByZXR1cm5zIHtib29sfSB3YXMgdGhpcyBhIHN1Y2Nlc3NmdWwgdHJ5PwogICAgICovCiAgICBST1QuTWFwLkRpZ2dlci5wcm90b3R5cGUuX3RyeUZlYXR1cmUgPSBmdW5jdGlvbih4LCB5LCBkeCwgZHkpCiAgICB7CiAgICAgICAgdmFyIGZlYXR1cmUgPSBST1QuUk5HLmdldFdlaWdodGVkVmFsdWUodGhpcy5fZmVhdHVyZXMpOwogICAgICAgIGZlYXR1cmUgPSBST1QuTWFwLkZlYXR1cmVbZmVhdHVyZV0uY3JlYXRlUmFuZG9tQXQoeCwgeSwgZHgsIGR5LCB0aGlzLl9vcHRpb25zKTsKCiAgICAgICAgaWYgKCFmZWF0dXJlLmlzVmFsaWQodGhpcy5faXNXYWxsQ2FsbGJhY2ssIHRoaXMuX2NhbkJlRHVnQ2FsbGJhY2spKQogICAgICAgIHsKICAgICAgICAgICAgLy8JCWNvbnNvbGUubG9nKCJub3QgdmFsaWQiKTsKICAgICAgICAgICAgLy8JCWZlYXR1cmUuZGVidWcoKTsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KCiAgICAgICAgZmVhdHVyZS5jcmVhdGUodGhpcy5fZGlnQ2FsbGJhY2spOwogICAgICAgIC8vCWZlYXR1cmUuZGVidWcoKTsKCiAgICAgICAgaWYgKGZlYXR1cmUgaW5zdGFuY2VvZiBST1QuTWFwLkZlYXR1cmUuUm9vbSkKICAgICAgICB7CiAgICAgICAgICAgIHRoaXMuX3Jvb21zLnB1c2goZmVhdHVyZSk7CiAgICAgICAgfQogICAgICAgIGlmIChmZWF0dXJlIGluc3RhbmNlb2YgUk9ULk1hcC5GZWF0dXJlLkNvcnJpZG9yKQogICAgICAgIHsKICAgICAgICAgICAgZmVhdHVyZS5jcmVhdGVQcmlvcml0eVdhbGxzKHRoaXMuX3ByaW9yaXR5V2FsbENhbGxiYWNrKTsKICAgICAgICAgICAgdGhpcy5fY29ycmlkb3JzLnB1c2goZmVhdHVyZSk7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH07CgogICAgUk9ULk1hcC5EaWdnZXIucHJvdG90eXBlLl9yZW1vdmVTdXJyb3VuZGluZ1dhbGxzID0gZnVuY3Rpb24oY3gsIGN5KQogICAgewogICAgICAgIHZhciBkZWx0YXMgPSBST1QuRElSU1s0XTsKCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWx0YXMubGVuZ3RoOyBpKyspCiAgICAgICAgewogICAgICAgICAgICB2YXIgZGVsdGEgPSBkZWx0YXNbaV07CiAgICAgICAgICAgIHZhciB4ID0gY3ggKyBkZWx0YVswXTsKICAgICAgICAgICAgdmFyIHkgPSBjeSArIGRlbHRhWzFdOwogICAgICAgICAgICBkZWxldGUgdGhpcy5fd2FsbHNbeCArICIsIiArIHldOwogICAgICAgICAgICB2YXIgeCA9IGN4ICsgMiAqIGRlbHRhWzBdOwogICAgICAgICAgICB2YXIgeSA9IGN5ICsgMiAqIGRlbHRhWzFdOwogICAgICAgICAgICBkZWxldGUgdGhpcy5fd2FsbHNbeCArICIsIiArIHldOwogICAgICAgIH0KICAgIH07CgogICAgLyoqCiAgICAgKiBSZXR1cm5zIHZlY3RvciBpbiAiZGlnZ2luZyIgZGlyZWN0aW9uLCBvciBmYWxzZSwgaWYgdGhpcyBkb2VzIG5vdCBleGlzdCAob3IgaXMgbm90IHVuaXF1ZSkKICAgICAqLwogICAgUk9ULk1hcC5EaWdnZXIucHJvdG90eXBlLl9nZXREaWdnaW5nRGlyZWN0aW9uID0gZnVuY3Rpb24oY3gsIGN5KQogICAgewogICAgICAgIGlmIChjeCA8PSAwIHx8IGN5IDw9IDAgfHwgY3ggPj0gdGhpcy5fd2lkdGggLSAxIHx8IGN5ID49IHRoaXMuX2hlaWdodCAtIDEpCiAgICAgICAgewogICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICB9CgogICAgICAgIHZhciByZXN1bHQgPSBudWxsOwogICAgICAgIHZhciBkZWx0YXMgPSBST1QuRElSU1s0XTsKCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWx0YXMubGVuZ3RoOyBpKyspCiAgICAgICAgewogICAgICAgICAgICB2YXIgZGVsdGEgPSBkZWx0YXNbaV07CiAgICAgICAgICAgIHZhciB4ID0gY3ggKyBkZWx0YVswXTsKICAgICAgICAgICAgdmFyIHkgPSBjeSArIGRlbHRhWzFdOwoKICAgICAgICAgICAgaWYgKCF0aGlzLl9tYXBbeF1beV0pCiAgICAgICAgICAgIHsgLyogdGhlcmUgYWxyZWFkeSBpcyBhbm90aGVyIGVtcHR5IG5laWdoYm9yISAqLwogICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlbHRhOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICAvKiBubyBlbXB0eSBuZWlnaGJvciAqLwogICAgICAgIGlmICghcmVzdWx0KQogICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gWy1yZXN1bHRbMF0sIC1yZXN1bHRbMV1dOwogICAgfTsKCiAgICAvKioKICAgICAqIEZpbmQgZW1wdHkgc3BhY2VzIHN1cnJvdW5kaW5nIHJvb21zLCBhbmQgYXBwbHkgZG9vcnMuCiAgICAgKi8KICAgIFJPVC5NYXAuRGlnZ2VyLnByb3RvdHlwZS5fYWRkRG9vcnMgPSBmdW5jdGlvbigpCiAgICB7CiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9tYXA7CiAgICAgICAgdmFyIGlzV2FsbENhbGxiYWNrID0gZnVuY3Rpb24oeCwgeSkKICAgICAgICB7CiAgICAgICAgICAgIHJldHVybiAoZGF0YVt4XVt5XSA9PSAxKTsKICAgICAgICB9OwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vbXMubGVuZ3RoOyBpKyspCiAgICAgICAgewogICAgICAgICAgICB2YXIgcm9vbSA9IHRoaXMuX3Jvb21zW2ldOwogICAgICAgICAgICByb29tLmNsZWFyRG9vcnMoKTsKICAgICAgICAgICAgcm9vbS5hZGREb29ycyhpc1dhbGxDYWxsYmFjayk7CiAgICAgICAgfQogICAgfTsKICAgIC8qKgogICAgICogQGNsYXNzIER1bmdlb24gZ2VuZXJhdG9yIHdoaWNoIHRyaWVzIHRvIGZpbGwgdGhlIHNwYWNlIGV2ZW5seS4gR2VuZXJhdGVzIGluZGVwZW5kZW50IHJvb21zIGFuZCB0cmllcyB0byBjb25uZWN0IHRoZW0uCiAgICAgKiBAYXVnbWVudHMgUk9ULk1hcC5EdW5nZW9uCiAgICAgKi8KICAgIFJPVC5NYXAuVW5pZm9ybSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpCiAgICB7CiAgICAgICAgUk9ULk1hcC5EdW5nZW9uLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCk7CgogICAgICAgIHRoaXMuX29wdGlvbnMgPSB7CiAgICAgICAgICAgIHJvb21XaWR0aDogWzMsIDldLAogICAgICAgICAgICAvKiByb29tIG1pbmltdW0gYW5kIG1heGltdW0gd2lkdGggKi8KICAgICAgICAgICAgcm9vbUhlaWdodDogWzMsIDVdLAogICAgICAgICAgICAvKiByb29tIG1pbmltdW0gYW5kIG1heGltdW0gaGVpZ2h0ICovCiAgICAgICAgICAgIHJvb21EdWdQZXJjZW50YWdlOiAwLjEsCiAgICAgICAgICAgIC8qIHdlIHN0b3AgYWZ0ZXIgdGhpcyBwZXJjZW50YWdlIG9mIGxldmVsIGFyZWEgaGFzIGJlZW4gZHVnIG91dCBieSByb29tcyAqLwogICAgICAgICAgICB0aW1lTGltaXQ6IDEwMDAgLyogd2Ugc3RvcCBhZnRlciB0aGlzIG11Y2ggdGltZSBoYXMgcGFzc2VkIChtc2VjKSAqLwogICAgICAgIH07CiAgICAgICAgZm9yICh2YXIgcCBpbiBvcHRpb25zKQogICAgICAgIHsKICAgICAgICAgICAgdGhpcy5fb3B0aW9uc1twXSA9IG9wdGlvbnNbcF07CiAgICAgICAgfQoKICAgICAgICB0aGlzLl9yb29tQXR0ZW1wdHMgPSAyMDsgLyogbmV3IHJvb20gaXMgY3JlYXRlZCBOLXRpbWVzIHVudGlsIGlzIGNvbnNpZGVyZWQgYXMgaW1wb3NzaWJsZSB0byBnZW5lcmF0ZSAqLwogICAgICAgIHRoaXMuX2NvcnJpZG9yQXR0ZW1wdHMgPSAyMDsgLyogY29ycmlkb3JzIGFyZSB0cmllZCBOLXRpbWVzIHVudGlsIHRoZSBsZXZlbCBpcyBjb25zaWRlcmVkIGFzIGltcG9zc2libGUgdG8gY29ubmVjdCAqLwoKICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBbXTsgLyogbGlzdCBvZiBhbHJlYWR5IGNvbm5lY3RlZCByb29tcyAqLwogICAgICAgIHRoaXMuX3VuY29ubmVjdGVkID0gW107IC8qIGxpc3Qgb2YgcmVtYWluaW5nIHVuY29ubmVjdGVkIHJvb21zICovCgogICAgICAgIHRoaXMuX2RpZ0NhbGxiYWNrID0gdGhpcy5fZGlnQ2FsbGJhY2suYmluZCh0aGlzKTsKICAgICAgICB0aGlzLl9jYW5CZUR1Z0NhbGxiYWNrID0gdGhpcy5fY2FuQmVEdWdDYWxsYmFjay5iaW5kKHRoaXMpOwogICAgICAgIHRoaXMuX2lzV2FsbENhbGxiYWNrID0gdGhpcy5faXNXYWxsQ2FsbGJhY2suYmluZCh0aGlzKTsKICAgIH07CiAgICBST1QuTWFwLlVuaWZvcm0uZXh0ZW5kKFJPVC5NYXAuRHVuZ2Vvbik7CgogICAgLyoqCiAgICAgKiBDcmVhdGUgYSBtYXAuIElmIHRoZSB0aW1lIGxpbWl0IGhhcyBiZWVuIGhpdCwgcmV0dXJucyBudWxsLgogICAgICogQHNlZSBST1QuTWFwI2NyZWF0ZQogICAgICovCiAgICBST1QuTWFwLlVuaWZvcm0ucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKQogICAgewogICAgICAgIHZhciB0MSA9IERhdGUubm93KCk7CiAgICAgICAgd2hpbGUgKDEpCiAgICAgICAgewogICAgICAgICAgICB2YXIgdDIgPSBEYXRlLm5vdygpOwogICAgICAgICAgICBpZiAodDIgLSB0MSA+IHRoaXMuX29wdGlvbnMudGltZUxpbWl0KQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgfSAvKiB0aW1lIGxpbWl0ISAqLwoKICAgICAgICAgICAgdGhpcy5fbWFwID0gdGhpcy5fZmlsbE1hcCgxKTsKICAgICAgICAgICAgdGhpcy5fZHVnID0gMDsKICAgICAgICAgICAgdGhpcy5fcm9vbXMgPSBbXTsKICAgICAgICAgICAgdGhpcy5fdW5jb25uZWN0ZWQgPSBbXTsKICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVSb29tcygpOwogICAgICAgICAgICBpZiAodGhpcy5fcm9vbXMubGVuZ3RoIDwgMikKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMuX2dlbmVyYXRlQ29ycmlkb3JzKCkpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAoY2FsbGJhY2spCiAgICAgICAgewogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3dpZHRoOyBpKyspCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5faGVpZ2h0OyBqKyspCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soaSwgaiwgdGhpcy5fbWFwW2ldW2pdKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICB9OwoKICAgIC8qKgogICAgICogR2VuZXJhdGVzIGEgc3VpdGFibGUgYW1vdW50IG9mIHJvb21zCiAgICAgKi8KICAgIFJPVC5NYXAuVW5pZm9ybS5wcm90b3R5cGUuX2dlbmVyYXRlUm9vbXMgPSBmdW5jdGlvbigpCiAgICB7CiAgICAgICAgdmFyIHcgPSB0aGlzLl93aWR0aCAtIDI7CiAgICAgICAgdmFyIGggPSB0aGlzLl9oZWlnaHQgLSAyOwoKICAgICAgICBkbyB7CiAgICAgICAgICAgIHZhciByb29tID0gdGhpcy5fZ2VuZXJhdGVSb29tKCk7CiAgICAgICAgICAgIGlmICh0aGlzLl9kdWcgLyAodyAqIGgpID4gdGhpcy5fb3B0aW9ucy5yb29tRHVnUGVyY2VudGFnZSkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0gLyogYWNoaWV2ZWQgcmVxdWVzdGVkIGFtb3VudCBvZiBmcmVlIHNwYWNlICovCiAgICAgICAgfSB3aGlsZSAocm9vbSk7CgogICAgICAgIC8qIGVpdGhlciBlbm91Z2ggcm9vbXMsIG9yIG5vdCBhYmxlIHRvIGdlbmVyYXRlIG1vcmUgb2YgdGhlbSA6KSAqLwogICAgfTsKCiAgICAvKioKICAgICAqIFRyeSB0byBnZW5lcmF0ZSBvbmUgcm9vbQogICAgICovCiAgICBST1QuTWFwLlVuaWZvcm0ucHJvdG90eXBlLl9nZW5lcmF0ZVJvb20gPSBmdW5jdGlvbigpCiAgICB7CiAgICAgICAgdmFyIGNvdW50ID0gMDsKICAgICAgICB3aGlsZSAoY291bnQgPCB0aGlzLl9yb29tQXR0ZW1wdHMpCiAgICAgICAgewogICAgICAgICAgICBjb3VudCsrOwoKICAgICAgICAgICAgdmFyIHJvb20gPSBST1QuTWFwLkZlYXR1cmUuUm9vbS5jcmVhdGVSYW5kb20odGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgdGhpcy5fb3B0aW9ucyk7CiAgICAgICAgICAgIGlmICghcm9vbS5pc1ZhbGlkKHRoaXMuX2lzV2FsbENhbGxiYWNrLCB0aGlzLl9jYW5CZUR1Z0NhbGxiYWNrKSkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHJvb20uY3JlYXRlKHRoaXMuX2RpZ0NhbGxiYWNrKTsKICAgICAgICAgICAgdGhpcy5fcm9vbXMucHVzaChyb29tKTsKICAgICAgICAgICAgcmV0dXJuIHJvb207CiAgICAgICAgfQoKICAgICAgICAvKiBubyByb29tIHdhcyBnZW5lcmF0ZWQgaW4gYSBnaXZlbiBudW1iZXIgb2YgYXR0ZW1wdHMgKi8KICAgICAgICByZXR1cm4gbnVsbDsKICAgIH07CgogICAgLyoqCiAgICAgKiBHZW5lcmF0ZXMgY29ubmVjdG9ycyBiZXdlZW4gcm9vbXMKICAgICAqIEByZXR1cm5zIHtib29sfSBzdWNjZXNzIFdhcyB0aGlzIGF0dGVtcHQgc3VjY2Vzc2Z1bGw/CiAgICAgKi8KICAgIFJPVC5NYXAuVW5pZm9ybS5wcm90b3R5cGUuX2dlbmVyYXRlQ29ycmlkb3JzID0gZnVuY3Rpb24oKQogICAgewogICAgICAgIHZhciBjbnQgPSAwOwogICAgICAgIHdoaWxlIChjbnQgPCB0aGlzLl9jb3JyaWRvckF0dGVtcHRzKQogICAgICAgIHsKICAgICAgICAgICAgY250Kys7CiAgICAgICAgICAgIHRoaXMuX2NvcnJpZG9ycyA9IFtdOwoKICAgICAgICAgICAgLyogZGlnIHJvb21zIGludG8gYSBjbGVhciBtYXAgKi8KICAgICAgICAgICAgdGhpcy5fbWFwID0gdGhpcy5fZmlsbE1hcCgxKTsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yb29tcy5sZW5ndGg7IGkrKykKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdmFyIHJvb20gPSB0aGlzLl9yb29tc1tpXTsKICAgICAgICAgICAgICAgIHJvb20uY2xlYXJEb29ycygpOwogICAgICAgICAgICAgICAgcm9vbS5jcmVhdGUodGhpcy5fZGlnQ2FsbGJhY2spOwogICAgICAgICAgICB9CgogICAgICAgICAgICB0aGlzLl91bmNvbm5lY3RlZCA9IHRoaXMuX3Jvb21zLnNsaWNlKCkucmFuZG9taXplKCk7CiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IFtdOwogICAgICAgICAgICBpZiAodGhpcy5fdW5jb25uZWN0ZWQubGVuZ3RoKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0ZWQucHVzaCh0aGlzLl91bmNvbm5lY3RlZC5wb3AoKSk7CiAgICAgICAgICAgIH0gLyogZmlyc3Qgb25lIGlzIGFsd2F5cyBjb25uZWN0ZWQgKi8KCiAgICAgICAgICAgIHdoaWxlICgxKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAvKiAxLiBwaWNrIHJhbmRvbSBjb25uZWN0ZWQgcm9vbSAqLwogICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RlZCA9IHRoaXMuX2Nvbm5lY3RlZC5yYW5kb20oKTsKCiAgICAgICAgICAgICAgICAvKiAyLiBmaW5kIGNsb3Nlc3QgdW5jb25uZWN0ZWQgKi8KICAgICAgICAgICAgICAgIHZhciByb29tMSA9IHRoaXMuX2Nsb3Nlc3RSb29tKHRoaXMuX3VuY29ubmVjdGVkLCBjb25uZWN0ZWQpOwoKICAgICAgICAgICAgICAgIC8qIDMuIGNvbm5lY3QgaXQgdG8gY2xvc2VzdCBjb25uZWN0ZWQgKi8KICAgICAgICAgICAgICAgIHZhciByb29tMiA9IHRoaXMuX2Nsb3Nlc3RSb29tKHRoaXMuX2Nvbm5lY3RlZCwgcm9vbTEpOwoKICAgICAgICAgICAgICAgIHZhciBvayA9IHRoaXMuX2Nvbm5lY3RSb29tcyhyb29tMSwgcm9vbTIpOwogICAgICAgICAgICAgICAgaWYgKCFvaykKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0gLyogc3RvcCBjb25uZWN0aW5nLCByZS1zaHVmZmxlICovCgogICAgICAgICAgICAgICAgaWYgKCF0aGlzLl91bmNvbm5lY3RlZC5sZW5ndGgpCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgICAgICB9IC8qIGRvbmU7IG5vIHJvb21zIHJlbWFpbiAqLwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBmYWxzZTsKICAgIH07CgogICAgLyoqCiAgICAgKiBGb3IgYSBnaXZlbiByb29tLCBmaW5kIHRoZSBjbG9zZXN0IG9uZSBmcm9tIHRoZSBsaXN0CiAgICAgKi8KICAgIFJPVC5NYXAuVW5pZm9ybS5wcm90b3R5cGUuX2Nsb3Nlc3RSb29tID0gZnVuY3Rpb24ocm9vbXMsIHJvb20pCiAgICB7CiAgICAgICAgdmFyIGRpc3QgPSBJbmZpbml0eTsKICAgICAgICB2YXIgY2VudGVyID0gcm9vbS5nZXRDZW50ZXIoKTsKICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDsKCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb29tcy5sZW5ndGg7IGkrKykKICAgICAgICB7CiAgICAgICAgICAgIHZhciByID0gcm9vbXNbaV07CiAgICAgICAgICAgIHZhciBjID0gci5nZXRDZW50ZXIoKTsKICAgICAgICAgICAgdmFyIGR4ID0gY1swXSAtIGNlbnRlclswXTsKICAgICAgICAgICAgdmFyIGR5ID0gY1sxXSAtIGNlbnRlclsxXTsKICAgICAgICAgICAgdmFyIGQgPSBkeCAqIGR4ICsgZHkgKiBkeTsKCiAgICAgICAgICAgIGlmIChkIDwgZGlzdCkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgZGlzdCA9IGQ7CiAgICAgICAgICAgICAgICByZXN1bHQgPSByOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgfTsKCiAgICBST1QuTWFwLlVuaWZvcm0ucHJvdG90eXBlLl9jb25uZWN0Um9vbXMgPSBmdW5jdGlvbihyb29tMSwgcm9vbTIpCiAgICB7CiAgICAgICAgLyoKCQlyb29tMS5kZWJ1ZygpOwoJCXJvb20yLmRlYnVnKCk7CgkqLwoKICAgICAgICB2YXIgY2VudGVyMSA9IHJvb20xLmdldENlbnRlcigpOwogICAgICAgIHZhciBjZW50ZXIyID0gcm9vbTIuZ2V0Q2VudGVyKCk7CgogICAgICAgIHZhciBkaWZmWCA9IGNlbnRlcjJbMF0gLSBjZW50ZXIxWzBdOwogICAgICAgIHZhciBkaWZmWSA9IGNlbnRlcjJbMV0gLSBjZW50ZXIxWzFdOwoKICAgICAgICBpZiAoTWF0aC5hYnMoZGlmZlgpIDwgTWF0aC5hYnMoZGlmZlkpKQogICAgICAgIHsgLyogZmlyc3QgdHJ5IGNvbm5lY3Rpbmcgbm9ydGgtc291dGggd2FsbHMgKi8KICAgICAgICAgICAgdmFyIGRpckluZGV4MSA9IChkaWZmWSA+IDAgPyAyIDogMCk7CiAgICAgICAgICAgIHZhciBkaXJJbmRleDIgPSAoZGlySW5kZXgxICsgMikgJSA0OwogICAgICAgICAgICB2YXIgbWluID0gcm9vbTIuZ2V0TGVmdCgpOwogICAgICAgICAgICB2YXIgbWF4ID0gcm9vbTIuZ2V0UmlnaHQoKTsKICAgICAgICAgICAgdmFyIGluZGV4ID0gMDsKICAgICAgICB9CiAgICAgICAgZWxzZQogICAgICAgIHsgLyogZmlyc3QgdHJ5IGNvbm5lY3RpbmcgZWFzdC13ZXN0IHdhbGxzICovCiAgICAgICAgICAgIHZhciBkaXJJbmRleDEgPSAoZGlmZlggPiAwID8gMSA6IDMpOwogICAgICAgICAgICB2YXIgZGlySW5kZXgyID0gKGRpckluZGV4MSArIDIpICUgNDsKICAgICAgICAgICAgdmFyIG1pbiA9IHJvb20yLmdldFRvcCgpOwogICAgICAgICAgICB2YXIgbWF4ID0gcm9vbTIuZ2V0Qm90dG9tKCk7CiAgICAgICAgICAgIHZhciBpbmRleCA9IDE7CiAgICAgICAgfQoKICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9wbGFjZUluV2FsbChyb29tMSwgZGlySW5kZXgxKTsgLyogY29ycmlkb3Igd2lsbCBzdGFydCBoZXJlICovCiAgICAgICAgaWYgKCFzdGFydCkKICAgICAgICB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CgogICAgICAgIGlmIChzdGFydFtpbmRleF0gPj0gbWluICYmIHN0YXJ0W2luZGV4XSA8PSBtYXgpCiAgICAgICAgeyAvKiBwb3NzaWJsZSB0byBjb25uZWN0IHdpdGggc3RyYWlnaHQgbGluZSAoSS1saWtlKSAqLwogICAgICAgICAgICB2YXIgZW5kID0gc3RhcnQuc2xpY2UoKTsKICAgICAgICAgICAgdmFyIHZhbHVlID0gbnVsbDsKICAgICAgICAgICAgc3dpdGNoIChkaXJJbmRleDIpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJvb20yLmdldFRvcCgpIC0gMTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJvb20yLmdldFJpZ2h0KCkgKyAxOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcm9vbTIuZ2V0Qm90dG9tKCkgKyAxOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcm9vbTIuZ2V0TGVmdCgpIC0gMTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbmRbKGluZGV4ICsgMSkgJSAyXSA9IHZhbHVlOwogICAgICAgICAgICB0aGlzLl9kaWdMaW5lKFtzdGFydCwgZW5kXSk7CgogICAgICAgIH0KICAgICAgICBlbHNlIGlmIChzdGFydFtpbmRleF0gPCBtaW4gLSAxIHx8IHN0YXJ0W2luZGV4XSA+IG1heCArIDEpCiAgICAgICAgeyAvKiBuZWVkIHRvIHN3aXRjaCB0YXJnZXQgd2FsbCAoTC1saWtlKSAqLwoKICAgICAgICAgICAgdmFyIGRpZmYgPSBzdGFydFtpbmRleF0gLSBjZW50ZXIyW2luZGV4XTsKICAgICAgICAgICAgc3dpdGNoIChkaXJJbmRleDIpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICAgICAgICB2YXIgcm90YXRpb24gPSAoZGlmZiA8IDAgPyAzIDogMSk7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gKGRpZmYgPCAwID8gMSA6IDMpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGRpckluZGV4MiA9IChkaXJJbmRleDIgKyByb3RhdGlvbikgJSA0OwoKICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuX3BsYWNlSW5XYWxsKHJvb20yLCBkaXJJbmRleDIpOwogICAgICAgICAgICBpZiAoIWVuZCkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICB9CgogICAgICAgICAgICB2YXIgbWlkID0gWzAsIDBdOwogICAgICAgICAgICBtaWRbaW5kZXhdID0gc3RhcnRbaW5kZXhdOwogICAgICAgICAgICB2YXIgaW5kZXgyID0gKGluZGV4ICsgMSkgJSAyOwogICAgICAgICAgICBtaWRbaW5kZXgyXSA9IGVuZFtpbmRleDJdOwogICAgICAgICAgICB0aGlzLl9kaWdMaW5lKFtzdGFydCwgbWlkLCBlbmRdKTsKCiAgICAgICAgfQogICAgICAgIGVsc2UKICAgICAgICB7IC8qIHVzZSBjdXJyZW50IHdhbGwgcGFpciwgYnV0IGFkanVzdCB0aGUgbGluZSBpbiB0aGUgbWlkZGxlIChTLWxpa2UpICovCgogICAgICAgICAgICB2YXIgaW5kZXgyID0gKGluZGV4ICsgMSkgJSAyOwogICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5fcGxhY2VJbldhbGwocm9vbTIsIGRpckluZGV4Mik7CiAgICAgICAgICAgIGlmICghZW5kKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIG1pZCA9IE1hdGgucm91bmQoKGVuZFtpbmRleDJdICsgc3RhcnRbaW5kZXgyXSkgLyAyKTsKCiAgICAgICAgICAgIHZhciBtaWQxID0gWzAsIDBdOwogICAgICAgICAgICB2YXIgbWlkMiA9IFswLCAwXTsKICAgICAgICAgICAgbWlkMVtpbmRleF0gPSBzdGFydFtpbmRleF07CiAgICAgICAgICAgIG1pZDFbaW5kZXgyXSA9IG1pZDsKICAgICAgICAgICAgbWlkMltpbmRleF0gPSBlbmRbaW5kZXhdOwogICAgICAgICAgICBtaWQyW2luZGV4Ml0gPSBtaWQ7CiAgICAgICAgICAgIHRoaXMuX2RpZ0xpbmUoW3N0YXJ0LCBtaWQxLCBtaWQyLCBlbmRdKTsKICAgICAgICB9CgogICAgICAgIHJvb20xLmFkZERvb3Ioc3RhcnRbMF0sIHN0YXJ0WzFdKTsKICAgICAgICByb29tMi5hZGREb29yKGVuZFswXSwgZW5kWzFdKTsKCiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fdW5jb25uZWN0ZWQuaW5kZXhPZihyb29tMSk7CiAgICAgICAgaWYgKGluZGV4ICE9IC0xKQogICAgICAgIHsKICAgICAgICAgICAgdGhpcy5fdW5jb25uZWN0ZWQuc3BsaWNlKGluZGV4LCAxKTsKICAgICAgICAgICAgdGhpcy5fY29ubmVjdGVkLnB1c2gocm9vbTEpOwogICAgICAgIH0KCiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fdW5jb25uZWN0ZWQuaW5kZXhPZihyb29tMik7CiAgICAgICAgaWYgKGluZGV4ICE9IC0xKQogICAgICAgIHsKICAgICAgICAgICAgdGhpcy5fdW5jb25uZWN0ZWQuc3BsaWNlKGluZGV4LCAxKTsKICAgICAgICAgICAgdGhpcy5fY29ubmVjdGVkLnB1c2gocm9vbTIpOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIHRydWU7CiAgICB9OwoKICAgIFJPVC5NYXAuVW5pZm9ybS5wcm90b3R5cGUuX3BsYWNlSW5XYWxsID0gZnVuY3Rpb24ocm9vbSwgZGlySW5kZXgpCiAgICB7CiAgICAgICAgdmFyIHN0YXJ0ID0gWzAsIDBdOwogICAgICAgIHZhciBkaXIgPSBbMCwgMF07CiAgICAgICAgdmFyIGxlbmd0aCA9IDA7CgogICAgICAgIHN3aXRjaCAoZGlySW5kZXgpCiAgICAgICAgewogICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICBkaXIgPSBbMSwgMF07CiAgICAgICAgICAgICAgICBzdGFydCA9IFtyb29tLmdldExlZnQoKSwgcm9vbS5nZXRUb3AoKSAtIDFdOwogICAgICAgICAgICAgICAgbGVuZ3RoID0gcm9vbS5nZXRSaWdodCgpIC0gcm9vbS5nZXRMZWZ0KCkgKyAxOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICAgIGRpciA9IFswLCAxXTsKICAgICAgICAgICAgICAgIHN0YXJ0ID0gW3Jvb20uZ2V0UmlnaHQoKSArIDEsIHJvb20uZ2V0VG9wKCldOwogICAgICAgICAgICAgICAgbGVuZ3RoID0gcm9vbS5nZXRCb3R0b20oKSAtIHJvb20uZ2V0VG9wKCkgKyAxOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgIGRpciA9IFsxLCAwXTsKICAgICAgICAgICAgICAgIHN0YXJ0ID0gW3Jvb20uZ2V0TGVmdCgpLCByb29tLmdldEJvdHRvbSgpICsgMV07CiAgICAgICAgICAgICAgICBsZW5ndGggPSByb29tLmdldFJpZ2h0KCkgLSByb29tLmdldExlZnQoKSArIDE7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgZGlyID0gWzAsIDFdOwogICAgICAgICAgICAgICAgc3RhcnQgPSBbcm9vbS5nZXRMZWZ0KCkgLSAxLCByb29tLmdldFRvcCgpXTsKICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJvb20uZ2V0Qm90dG9tKCkgLSByb29tLmdldFRvcCgpICsgMTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KCiAgICAgICAgdmFyIGF2YWlsID0gW107CiAgICAgICAgdmFyIGxhc3RCYWRJbmRleCA9IC0yOwoKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKQogICAgICAgIHsKICAgICAgICAgICAgdmFyIHggPSBzdGFydFswXSArIGkgKiBkaXJbMF07CiAgICAgICAgICAgIHZhciB5ID0gc3RhcnRbMV0gKyBpICogZGlyWzFdOwogICAgICAgICAgICBhdmFpbC5wdXNoKG51bGwpOwoKICAgICAgICAgICAgdmFyIGlzV2FsbCA9ICh0aGlzLl9tYXBbeF1beV0gPT0gMSk7CiAgICAgICAgICAgIGlmIChpc1dhbGwpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGlmIChsYXN0QmFkSW5kZXggIT0gaSAtIDEpCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgYXZhaWxbaV0gPSBbeCwgeV07CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBsYXN0QmFkSW5kZXggPSBpOwogICAgICAgICAgICAgICAgaWYgKGkpCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgYXZhaWxbaSAtIDFdID0gbnVsbDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgZm9yICh2YXIgaSA9IGF2YWlsLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKQogICAgICAgIHsKICAgICAgICAgICAgaWYgKCFhdmFpbFtpXSkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgYXZhaWwuc3BsaWNlKGksIDEpOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiAoYXZhaWwubGVuZ3RoID8gYXZhaWwucmFuZG9tKCkgOiBudWxsKTsKICAgIH07CgogICAgLyoqCiAgICAgKiBEaWcgYSBwb2x5bGluZS4KICAgICAqLwogICAgUk9ULk1hcC5Vbmlmb3JtLnByb3RvdHlwZS5fZGlnTGluZSA9IGZ1bmN0aW9uKHBvaW50cykKICAgIHsKICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykKICAgICAgICB7CiAgICAgICAgICAgIHZhciBzdGFydCA9IHBvaW50c1tpIC0gMV07CiAgICAgICAgICAgIHZhciBlbmQgPSBwb2ludHNbaV07CiAgICAgICAgICAgIHZhciBjb3JyaWRvciA9IG5ldyBST1QuTWFwLkZlYXR1cmUuQ29ycmlkb3Ioc3RhcnRbMF0sIHN0YXJ0WzFdLCBlbmRbMF0sIGVuZFsxXSk7CiAgICAgICAgICAgIGNvcnJpZG9yLmNyZWF0ZSh0aGlzLl9kaWdDYWxsYmFjayk7CiAgICAgICAgICAgIHRoaXMuX2NvcnJpZG9ycy5wdXNoKGNvcnJpZG9yKTsKICAgICAgICB9CiAgICB9OwoKICAgIFJPVC5NYXAuVW5pZm9ybS5wcm90b3R5cGUuX2RpZ0NhbGxiYWNrID0gZnVuY3Rpb24oeCwgeSwgdmFsdWUpCiAgICB7CiAgICAgICAgdGhpcy5fbWFwW3hdW3ldID0gdmFsdWU7CiAgICAgICAgaWYgKHZhbHVlID09IDApCiAgICAgICAgewogICAgICAgICAgICB0aGlzLl9kdWcrKzsKICAgICAgICB9CiAgICB9OwoKICAgIFJPVC5NYXAuVW5pZm9ybS5wcm90b3R5cGUuX2lzV2FsbENhbGxiYWNrID0gZnVuY3Rpb24oeCwgeSkKICAgIHsKICAgICAgICBpZiAoeCA8IDAgfHwgeSA8IDAgfHwgeCA+PSB0aGlzLl93aWR0aCB8fCB5ID49IHRoaXMuX2hlaWdodCkKICAgICAgICB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuICh0aGlzLl9tYXBbeF1beV0gPT0gMSk7CiAgICB9OwoKICAgIFJPVC5NYXAuVW5pZm9ybS5wcm90b3R5cGUuX2NhbkJlRHVnQ2FsbGJhY2sgPSBmdW5jdGlvbih4LCB5KQogICAgewogICAgICAgIGlmICh4IDwgMSB8fCB5IDwgMSB8fCB4ICsgMSA+PSB0aGlzLl93aWR0aCB8fCB5ICsgMSA+PSB0aGlzLl9oZWlnaHQpCiAgICAgICAgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIHJldHVybiAodGhpcy5fbWFwW3hdW3ldID09IDEpOwogICAgfTsKCiAgICAvKioKICAgICAqIEBhdXRob3IgaHlha3VnZWkKICAgICAqIEBjbGFzcyBEdW5nZW9uIGdlbmVyYXRvciB3aGljaCB1c2VzIHRoZSAib3JnaW5hbCIgUm9ndWUgZHVuZ2VvbiBnZW5lcmF0aW9uIGFsZ29yaXRobS4gU2VlIGh0dHA6Ly9rdW9pLmNvbS9+a2FtaWthemUvR2FtZURlc2lnbi9hcnQwN19yb2d1ZV9kdW5nZW9uLnBocAogICAgICogQGF1Z21lbnRzIFJPVC5NYXAKICAgICAqIEBwYXJhbSB7aW50fSBbd2lkdGg9Uk9ULkRFRkFVTFRfV0lEVEhdCiAgICAgKiBAcGFyYW0ge2ludH0gW2hlaWdodD1ST1QuREVGQVVMVF9IRUlHSFRdCiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMKICAgICAqIEBwYXJhbSB7aW50W119IFtvcHRpb25zLmNlbGxXaWR0aD0zXSBOdW1iZXIgb2YgY2VsbHMgdG8gY3JlYXRlIG9uIHRoZSBob3Jpem9udGFsIChudW1iZXIgb2Ygcm9vbXMgaG9yaXpvbnRhbGx5KQogICAgICogQHBhcmFtIHtpbnRbXX0gW29wdGlvbnMuY2VsbEhlaWdodD0zXSBOdW1iZXIgb2YgY2VsbHMgdG8gY3JlYXRlIG9uIHRoZSB2ZXJ0aWNhbCAobnVtYmVyIG9mIHJvb21zIHZlcnRpY2FsbHkpCiAgICAgKiBAcGFyYW0ge2ludH0gW29wdGlvbnMucm9vbVdpZHRoXSBSb29tIG1pbiBhbmQgbWF4IHdpZHRoIC0gbm9ybWFsbHkgc2V0IGF1dG8tbWFnaWNhbGx5IHZpYSB0aGUgY29uc3RydWN0b3IuCiAgICAgKiBAcGFyYW0ge2ludH0gW29wdGlvbnMucm9vbUhlaWdodF0gUm9vbSBtaW4gYW5kIG1heCBoZWlnaHQgLSBub3JtYWxseSBzZXQgYXV0by1tYWdpY2FsbHkgdmlhIHRoZSBjb25zdHJ1Y3Rvci4KICAgICAqLwogICAgUk9ULk1hcC5Sb2d1ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpCiAgICB7CiAgICAgICAgUk9ULk1hcC5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQpOwoKICAgICAgICB0aGlzLl9vcHRpb25zID0gewogICAgICAgICAgICBjZWxsV2lkdGg6IDMsIC8vIE5PVEUgdG8gc2VsZiwgdGhlc2UgY291bGQgcHJvYmFibHkgd29yayB0aGUgc2FtZSBhcyB0aGUgcm9vbVdpZHRoL3Jvb20gSGVpZ2h0IHZhbHVlcwogICAgICAgICAgICBjZWxsSGVpZ2h0OiAzIC8vICAgICBpZS4gYXMgYW4gYXJyYXkgd2l0aCBtaW4tbWF4IHZhbHVlcyBmb3IgZWFjaCBkaXJlY3Rpb24uLi4uCiAgICAgICAgfTsKCiAgICAgICAgZm9yICh2YXIgcCBpbiBvcHRpb25zKQogICAgICAgIHsKICAgICAgICAgICAgdGhpcy5fb3B0aW9uc1twXSA9IG9wdGlvbnNbcF07CiAgICAgICAgfQoKICAgICAgICAvKgoJU2V0IHRoZSByb29tIHNpemVzIGFjY29yZGluZyB0byB0aGUgb3Zlci1hbGwgd2lkdGggb2YgdGhlIG1hcCwKCWFuZCB0aGUgY2VsbCBzaXplcy4KCSovCiAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmhhc093blByb3BlcnR5KCJyb29tV2lkdGgiKSkKICAgICAgICB7CiAgICAgICAgICAgIHRoaXMuX29wdGlvbnNbInJvb21XaWR0aCJdID0gdGhpcy5fY2FsY3VsYXRlUm9vbVNpemUodGhpcy5fd2lkdGgsIHRoaXMuX29wdGlvbnNbImNlbGxXaWR0aCJdKTsKICAgICAgICB9CiAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmhhc093blByb3BlcnR5KCJyb29tSGVpZ2h0IikpCiAgICAgICAgewogICAgICAgICAgICB0aGlzLl9vcHRpb25zWyJyb29tSGVpZ2h0Il0gPSB0aGlzLl9jYWxjdWxhdGVSb29tU2l6ZSh0aGlzLl9oZWlnaHQsIHRoaXMuX29wdGlvbnNbImNlbGxIZWlnaHQiXSk7CiAgICAgICAgfQoKICAgIH07CgogICAgUk9ULk1hcC5Sb2d1ZS5leHRlbmQoUk9ULk1hcCk7CgogICAgLyoqCiAgICAgKiBAc2VlIFJPVC5NYXAjY3JlYXRlCiAgICAgKi8KICAgIFJPVC5NYXAuUm9ndWUucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKQogICAgewogICAgICAgIHRoaXMubWFwID0gdGhpcy5fZmlsbE1hcCgxKTsKICAgICAgICB0aGlzLnJvb21zID0gW107CiAgICAgICAgdGhpcy5jb25uZWN0ZWRDZWxscyA9IFtdOwoKICAgICAgICB0aGlzLl9pbml0Um9vbXMoKTsKICAgICAgICB0aGlzLl9jb25uZWN0Um9vbXMoKTsKICAgICAgICB0aGlzLl9jb25uZWN0VW5jb25uZWN0ZWRSb29tcygpOwogICAgICAgIHRoaXMuX2NyZWF0ZVJhbmRvbVJvb21Db25uZWN0aW9ucygpOwogICAgICAgIHRoaXMuX2NyZWF0ZVJvb21zKCk7CiAgICAgICAgdGhpcy5fY3JlYXRlQ29ycmlkb3JzKCk7CgogICAgICAgIGlmIChjYWxsYmFjaykKICAgICAgICB7CiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fd2lkdGg7IGkrKykKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9oZWlnaHQ7IGorKykKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhpLCBqLCB0aGlzLm1hcFtpXVtqXSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIHJldHVybiB0aGlzOwogICAgfTsKCiAgICBST1QuTWFwLlJvZ3VlLnByb3RvdHlwZS5fY2FsY3VsYXRlUm9vbVNpemUgPSBmdW5jdGlvbihzaXplLCBjZWxsKQogICAgewogICAgICAgIHZhciBtYXggPSBNYXRoLmZsb29yKChzaXplIC8gY2VsbCkgKiAwLjgpOwogICAgICAgIHZhciBtaW4gPSBNYXRoLmZsb29yKChzaXplIC8gY2VsbCkgKiAwLjI1KTsKICAgICAgICBpZiAobWluIDwgMikKICAgICAgICB7CiAgICAgICAgICAgIG1pbiA9IDI7CiAgICAgICAgfQogICAgICAgIGlmIChtYXggPCAyKQogICAgICAgIHsKICAgICAgICAgICAgbWF4ID0gMjsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIFttaW4sIG1heF07CiAgICB9OwoKICAgIFJPVC5NYXAuUm9ndWUucHJvdG90eXBlLl9pbml0Um9vbXMgPSBmdW5jdGlvbigpCiAgICB7CiAgICAgICAgLy8gY3JlYXRlIHJvb21zIGFycmF5LiBUaGlzIGlzIHRoZSAiZ3JpZCIgbGlzdCBmcm9tIHRoZSBhbGdvLgogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fb3B0aW9ucy5jZWxsV2lkdGg7IGkrKykKICAgICAgICB7CiAgICAgICAgICAgIHRoaXMucm9vbXMucHVzaChbXSk7CiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fb3B0aW9ucy5jZWxsSGVpZ2h0OyBqKyspCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHRoaXMucm9vbXNbaV0ucHVzaCgKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAieCI6IDAsCiAgICAgICAgICAgICAgICAgICAgInkiOiAwLAogICAgICAgICAgICAgICAgICAgICJ3aWR0aCI6IDAsCiAgICAgICAgICAgICAgICAgICAgImhlaWdodCI6IDAsCiAgICAgICAgICAgICAgICAgICAgImNvbm5lY3Rpb25zIjogW10sCiAgICAgICAgICAgICAgICAgICAgImNlbGx4IjogaSwKICAgICAgICAgICAgICAgICAgICAiY2VsbHkiOiBqCiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH07CgogICAgUk9ULk1hcC5Sb2d1ZS5wcm90b3R5cGUuX2Nvbm5lY3RSb29tcyA9IGZ1bmN0aW9uKCkKICAgIHsKICAgICAgICAvL3BpY2sgcmFuZG9tIHN0YXJ0aW5nIGdyaWQKICAgICAgICB2YXIgY2d4ID0gUk9ULlJORy5nZXRVbmlmb3JtSW50KDAsIHRoaXMuX29wdGlvbnMuY2VsbFdpZHRoIC0gMSk7CiAgICAgICAgdmFyIGNneSA9IFJPVC5STkcuZ2V0VW5pZm9ybUludCgwLCB0aGlzLl9vcHRpb25zLmNlbGxIZWlnaHQgLSAxKTsKCiAgICAgICAgdmFyIGlkeDsKICAgICAgICB2YXIgbmNneDsKICAgICAgICB2YXIgbmNneTsKCiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7CiAgICAgICAgdmFyIHJvb207CiAgICAgICAgdmFyIG90aGVyUm9vbTsKCiAgICAgICAgLy8gZmluZCAgdW5jb25uZWN0ZWQgbmVpZ2hib3VyIGNlbGxzCiAgICAgICAgZG8gewoKICAgICAgICAgICAgLy92YXIgZGlyVG9DaGVjayA9IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3XTsKICAgICAgICAgICAgdmFyIGRpclRvQ2hlY2sgPSBbMCwgMiwgNCwgNl07CiAgICAgICAgICAgIGRpclRvQ2hlY2sgPSBkaXJUb0NoZWNrLnJhbmRvbWl6ZSgpOwoKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgZm91bmQgPSBmYWxzZTsKICAgICAgICAgICAgICAgIGlkeCA9IGRpclRvQ2hlY2sucG9wKCk7CgogICAgICAgICAgICAgICAgbmNneCA9IGNneCArIFJPVC5ESVJTWzhdW2lkeF1bMF07CiAgICAgICAgICAgICAgICBuY2d5ID0gY2d5ICsgUk9ULkRJUlNbOF1baWR4XVsxXTsKCiAgICAgICAgICAgICAgICBpZiAobmNneCA8IDAgfHwgbmNneCA+PSB0aGlzLl9vcHRpb25zLmNlbGxXaWR0aCkKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChuY2d5IDwgMCB8fCBuY2d5ID49IHRoaXMuX29wdGlvbnMuY2VsbEhlaWdodCkKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICByb29tID0gdGhpcy5yb29tc1tjZ3hdW2NneV07CgogICAgICAgICAgICAgICAgaWYgKHJvb21bImNvbm5lY3Rpb25zIl0ubGVuZ3RoID4gMCkKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAvLyBhcyBsb25nIGFzIHRoaXMgcm9vbSBkb2Vzbid0IGFscmVhZHkgY29vbmVjdCB0byBtZSwgd2UgYXJlIG9rIHdpdGggaXQuCiAgICAgICAgICAgICAgICAgICAgaWYgKHJvb21bImNvbm5lY3Rpb25zIl1bMF1bMF0gPT0gbmNneCAmJiByb29tWyJjb25uZWN0aW9ucyJdWzBdWzFdID09IG5jZ3kpCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgb3RoZXJSb29tID0gdGhpcy5yb29tc1tuY2d4XVtuY2d5XTsKCiAgICAgICAgICAgICAgICBpZiAob3RoZXJSb29tWyJjb25uZWN0aW9ucyJdLmxlbmd0aCA9PSAwKQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIG90aGVyUm9vbVsiY29ubmVjdGlvbnMiXS5wdXNoKFtjZ3gsIGNneV0pOwoKICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RlZENlbGxzLnB1c2goW25jZ3gsIG5jZ3ldKTsKICAgICAgICAgICAgICAgICAgICBjZ3ggPSBuY2d4OwogICAgICAgICAgICAgICAgICAgIGNneSA9IG5jZ3k7CiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgfSB3aGlsZSAoZGlyVG9DaGVjay5sZW5ndGggPiAwICYmIGZvdW5kID09IGZhbHNlKTsKCiAgICAgICAgfSB3aGlsZSAoZGlyVG9DaGVjay5sZW5ndGggPiAwKTsKCiAgICB9OwoKICAgIFJPVC5NYXAuUm9ndWUucHJvdG90eXBlLl9jb25uZWN0VW5jb25uZWN0ZWRSb29tcyA9IGZ1bmN0aW9uKCkKICAgIHsKICAgICAgICAvL1doaWxlIHRoZXJlIGFyZSB1bmNvbm5lY3RlZCByb29tcywgdHJ5IHRvIGNvbm5lY3QgdGhlbSB0byBhIHJhbmRvbSBjb25uZWN0ZWQgbmVpZ2hib3IKICAgICAgICAvLyhpZiBhIHJvb20gaGFzIG5vIGNvbm5lY3RlZCBuZWlnaGJvcnMgeWV0LCBqdXN0IGtlZXAgY3ljbGluZywgeW91J2xsIGZpbGwgb3V0IHRvIGl0IGV2ZW50dWFsbHkpLgogICAgICAgIHZhciBjdyA9IHRoaXMuX29wdGlvbnMuY2VsbFdpZHRoOwogICAgICAgIHZhciBjaCA9IHRoaXMuX29wdGlvbnMuY2VsbEhlaWdodDsKCiAgICAgICAgdGhpcy5jb25uZWN0ZWRDZWxscyA9IHRoaXMuY29ubmVjdGVkQ2VsbHMucmFuZG9taXplKCk7CiAgICAgICAgdmFyIHJvb207CiAgICAgICAgdmFyIG90aGVyUm9vbTsKICAgICAgICB2YXIgdmFsaWRSb29tOwoKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX29wdGlvbnMuY2VsbFdpZHRoOyBpKyspCiAgICAgICAgewogICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX29wdGlvbnMuY2VsbEhlaWdodDsgaisrKQogICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgcm9vbSA9IHRoaXMucm9vbXNbaV1bal07CgogICAgICAgICAgICAgICAgaWYgKHJvb21bImNvbm5lY3Rpb25zIl0ubGVuZ3RoID09IDApCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbnMgPSBbMCwgMiwgNCwgNl07CiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9ucyA9IGRpcmVjdGlvbnMucmFuZG9taXplKCk7CgogICAgICAgICAgICAgICAgICAgIHZhbGlkUm9vbSA9IGZhbHNlOwoKICAgICAgICAgICAgICAgICAgICBkbyB7CgogICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlySWR4ID0gZGlyZWN0aW9ucy5wb3AoKTsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0kgPSBpICsgUk9ULkRJUlNbOF1bZGlySWR4XVswXTsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0ogPSBqICsgUk9ULkRJUlNbOF1bZGlySWR4XVsxXTsKCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdJIDwgMCB8fCBuZXdJID49IGN3IHx8IG5ld0ogPCAwIHx8IG5ld0ogPj0gY2gpCiAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICBvdGhlclJvb20gPSB0aGlzLnJvb21zW25ld0ldW25ld0pdOwoKICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRSb29tID0gdHJ1ZTsKCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlclJvb21bImNvbm5lY3Rpb25zIl0ubGVuZ3RoID09IDApCiAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG90aGVyUm9vbVsiY29ubmVjdGlvbnMiXS5sZW5ndGg7IGsrKykKICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyUm9vbVsiY29ubmVjdGlvbnMiXVtrXVswXSA9PSBpICYmIG90aGVyUm9vbVsiY29ubmVjdGlvbnMiXVtrXVsxXSA9PSBqKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkUm9vbSA9IGZhbHNlOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRSb29tKQogICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChkaXJlY3Rpb25zLmxlbmd0aCk7CgogICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZFJvb20pCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICByb29tWyJjb25uZWN0aW9ucyJdLnB1c2goW290aGVyUm9vbVsiY2VsbHgiXSwgb3RoZXJSb29tWyJjZWxseSJdXSk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCItLSBVbmFibGUgdG8gY29ubmVjdCByb29tLiIpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH07CgogICAgUk9ULk1hcC5Sb2d1ZS5wcm90b3R5cGUuX2NyZWF0ZVJhbmRvbVJvb21Db25uZWN0aW9ucyA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25zKQogICAgewogICAgICAgIC8vIEVtcHR5IGZvciBub3cuCiAgICB9OwoKCiAgICBST1QuTWFwLlJvZ3VlLnByb3RvdHlwZS5fY3JlYXRlUm9vbXMgPSBmdW5jdGlvbigpCiAgICB7CiAgICAgICAgLy8gQ3JlYXRlIFJvb21zCgogICAgICAgIHZhciB3ID0gdGhpcy5fd2lkdGg7CiAgICAgICAgdmFyIGggPSB0aGlzLl9oZWlnaHQ7CgogICAgICAgIHZhciBjdyA9IHRoaXMuX29wdGlvbnMuY2VsbFdpZHRoOwogICAgICAgIHZhciBjaCA9IHRoaXMuX29wdGlvbnMuY2VsbEhlaWdodDsKCiAgICAgICAgdmFyIGN3cCA9IE1hdGguZmxvb3IodGhpcy5fd2lkdGggLyBjdyk7CiAgICAgICAgdmFyIGNocCA9IE1hdGguZmxvb3IodGhpcy5faGVpZ2h0IC8gY2gpOwoKICAgICAgICB2YXIgcm9vbXc7CiAgICAgICAgdmFyIHJvb21oOwogICAgICAgIHZhciByb29tV2lkdGggPSB0aGlzLl9vcHRpb25zWyJyb29tV2lkdGgiXTsKICAgICAgICB2YXIgcm9vbUhlaWdodCA9IHRoaXMuX29wdGlvbnNbInJvb21IZWlnaHQiXTsKICAgICAgICB2YXIgc3g7CiAgICAgICAgdmFyIHN5OwogICAgICAgIHZhciBvdGhlclJvb207CgogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3c7IGkrKykKICAgICAgICB7CiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2g7IGorKykKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgc3ggPSBjd3AgKiBpOwogICAgICAgICAgICAgICAgc3kgPSBjaHAgKiBqOwoKICAgICAgICAgICAgICAgIGlmIChzeCA9PSAwKQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIHN4ID0gMTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzeSA9PSAwKQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIHN5ID0gMTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICByb29tdyA9IFJPVC5STkcuZ2V0VW5pZm9ybUludChyb29tV2lkdGhbMF0sIHJvb21XaWR0aFsxXSk7CiAgICAgICAgICAgICAgICByb29taCA9IFJPVC5STkcuZ2V0VW5pZm9ybUludChyb29tSGVpZ2h0WzBdLCByb29tSGVpZ2h0WzFdKTsKCiAgICAgICAgICAgICAgICBpZiAoaiA+IDApCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgb3RoZXJSb29tID0gdGhpcy5yb29tc1tpXVtqIC0gMV07CiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN5IC0gKG90aGVyUm9vbVsieSJdICsgb3RoZXJSb29tWyJoZWlnaHQiXSkgPCAzKQogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgc3krKzsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgaWYgKGkgPiAwKQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIG90aGVyUm9vbSA9IHRoaXMucm9vbXNbaSAtIDFdW2pdOwogICAgICAgICAgICAgICAgICAgIHdoaWxlIChzeCAtIChvdGhlclJvb21bIngiXSArIG90aGVyUm9vbVsid2lkdGgiXSkgPCAzKQogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgc3grKzsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgdmFyIHN4T2Zmc2V0ID0gTWF0aC5yb3VuZChST1QuUk5HLmdldFVuaWZvcm1JbnQoMCwgY3dwIC0gcm9vbXcpIC8gMik7CiAgICAgICAgICAgICAgICB2YXIgc3lPZmZzZXQgPSBNYXRoLnJvdW5kKFJPVC5STkcuZ2V0VW5pZm9ybUludCgwLCBjaHAgLSByb29taCkgLyAyKTsKCiAgICAgICAgICAgICAgICB3aGlsZSAoc3ggKyBzeE9mZnNldCArIHJvb213ID49IHcpCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHN4T2Zmc2V0KQogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgc3hPZmZzZXQtLTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgcm9vbXctLTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgd2hpbGUgKHN5ICsgc3lPZmZzZXQgKyByb29taCA+PSBoKQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIGlmIChzeU9mZnNldCkKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgIHN5T2Zmc2V0LS07CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJvb21oLS07CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHN4ID0gc3ggKyBzeE9mZnNldDsKICAgICAgICAgICAgICAgIHN5ID0gc3kgKyBzeU9mZnNldDsKCiAgICAgICAgICAgICAgICB0aGlzLnJvb21zW2ldW2pdWyJ4Il0gPSBzeDsKICAgICAgICAgICAgICAgIHRoaXMucm9vbXNbaV1bal1bInkiXSA9IHN5OwogICAgICAgICAgICAgICAgdGhpcy5yb29tc1tpXVtqXVsid2lkdGgiXSA9IHJvb213OwogICAgICAgICAgICAgICAgdGhpcy5yb29tc1tpXVtqXVsiaGVpZ2h0Il0gPSByb29taDsKCiAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IHN4OyBpaSA8IHN4ICsgcm9vbXc7IGlpKyspCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgamogPSBzeTsgamogPCBzeSArIHJvb21oOyBqaisrKQogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBbaWldW2pqXSA9IDA7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfTsKCiAgICBST1QuTWFwLlJvZ3VlLnByb3RvdHlwZS5fZ2V0V2FsbFBvc2l0aW9uID0gZnVuY3Rpb24oYVJvb20sIGFEaXJlY3Rpb24pCiAgICB7CiAgICAgICAgdmFyIHJ4OwogICAgICAgIHZhciByeTsKICAgICAgICB2YXIgZG9vcjsKCiAgICAgICAgaWYgKGFEaXJlY3Rpb24gPT0gMSB8fCBhRGlyZWN0aW9uID09IDMpCiAgICAgICAgewogICAgICAgICAgICByeCA9IFJPVC5STkcuZ2V0VW5pZm9ybUludChhUm9vbVsieCJdICsgMSwgYVJvb21bIngiXSArIGFSb29tWyJ3aWR0aCJdIC0gMik7CiAgICAgICAgICAgIGlmIChhRGlyZWN0aW9uID09IDEpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHJ5ID0gYVJvb21bInkiXSAtIDI7CiAgICAgICAgICAgICAgICBkb29yID0gcnkgKyAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgcnkgPSBhUm9vbVsieSJdICsgYVJvb21bImhlaWdodCJdICsgMTsKICAgICAgICAgICAgICAgIGRvb3IgPSByeSAtIDE7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHRoaXMubWFwW3J4XVtkb29yXSA9IDA7IC8vIGknbSBub3Qgc2V0dGluZyBhIHNwZWNpZmljICdkb29yJyB0aWxlIHZhbHVlIHJpZ2h0IG5vdywganVzdCBlbXB0eSBzcGFjZS4KCiAgICAgICAgfQogICAgICAgIGVsc2UgaWYgKGFEaXJlY3Rpb24gPT0gMiB8fCBhRGlyZWN0aW9uID09IDQpCiAgICAgICAgewogICAgICAgICAgICByeSA9IFJPVC5STkcuZ2V0VW5pZm9ybUludChhUm9vbVsieSJdICsgMSwgYVJvb21bInkiXSArIGFSb29tWyJoZWlnaHQiXSAtIDIpOwogICAgICAgICAgICBpZiAoYURpcmVjdGlvbiA9PSAyKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICByeCA9IGFSb29tWyJ4Il0gKyBhUm9vbVsid2lkdGgiXSArIDE7CiAgICAgICAgICAgICAgICBkb29yID0gcnggLSAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgcnggPSBhUm9vbVsieCJdIC0gMjsKICAgICAgICAgICAgICAgIGRvb3IgPSByeCArIDE7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHRoaXMubWFwW2Rvb3JdW3J5XSA9IDA7IC8vIGknbSBub3Qgc2V0dGluZyBhIHNwZWNpZmljICdkb29yJyB0aWxlIHZhbHVlIHJpZ2h0IG5vdywganVzdCBlbXB0eSBzcGFjZS4KCiAgICAgICAgfQogICAgICAgIHJldHVybiBbcngsIHJ5XTsKICAgIH07CgogICAgLyoqKgogICAgICogQHBhcmFtIHN0YXJ0UG9zaXRpb24gYSAyIGVsZW1lbnQgYXJyYXkKICAgICAqIEBwYXJhbSBlbmRQb3NpdGlvbiBhIDIgZWxlbWVudCBhcnJheQogICAgICovCiAgICBST1QuTWFwLlJvZ3VlLnByb3RvdHlwZS5fZHJhd0NvcnJpZG9yID0gZnVuY3Rpb24oc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pCiAgICB7CiAgICAgICAgdmFyIHhPZmZzZXQgPSBlbmRQb3NpdGlvblswXSAtIHN0YXJ0UG9zaXRpb25bMF07CiAgICAgICAgdmFyIHlPZmZzZXQgPSBlbmRQb3NpdGlvblsxXSAtIHN0YXJ0UG9zaXRpb25bMV07CgogICAgICAgIHZhciB4cG9zID0gc3RhcnRQb3NpdGlvblswXTsKICAgICAgICB2YXIgeXBvcyA9IHN0YXJ0UG9zaXRpb25bMV07CgogICAgICAgIHZhciB0ZW1wRGlzdDsKICAgICAgICB2YXIgeERpcjsKICAgICAgICB2YXIgeURpcjsKCiAgICAgICAgdmFyIG1vdmU7IC8vIDIgZWxlbWVudCBhcnJheSwgZWxlbWVudCAwIGlzIHRoZSBkaXJlY3Rpb24sIGVsZW1lbnQgMSBpcyB0aGUgdG90YWwgdmFsdWUgdG8gbW92ZS4KICAgICAgICB2YXIgbW92ZXMgPSBbXTsgLy8gYSBsaXN0IG9mIDIgZWxlbWVudCBhcnJheXMKCiAgICAgICAgdmFyIHhBYnMgPSBNYXRoLmFicyh4T2Zmc2V0KTsKICAgICAgICB2YXIgeUFicyA9IE1hdGguYWJzKHlPZmZzZXQpOwoKICAgICAgICB2YXIgcGVyY2VudCA9IFJPVC5STkcuZ2V0VW5pZm9ybSgpOyAvLyB1c2VkIHRvIHNwbGl0IHRoZSBtb3ZlIGF0IGRpZmZlcmVudCBwbGFjZXMgYWxvbmcgdGhlIGxvbmcgYXhpcwogICAgICAgIHZhciBmaXJzdEhhbGYgPSBwZXJjZW50OwogICAgICAgIHZhciBzZWNvbmRIYWxmID0gMSAtIHBlcmNlbnQ7CgogICAgICAgIHhEaXIgPSB4T2Zmc2V0ID4gMCA/IDIgOiA2OwogICAgICAgIHlEaXIgPSB5T2Zmc2V0ID4gMCA/IDQgOiAwOwoKICAgICAgICBpZiAoeEFicyA8IHlBYnMpCiAgICAgICAgewogICAgICAgICAgICAvLyBtb3ZlIGZpcnN0SGFsZiBvZiB0aGUgeSBvZmZzZXQKICAgICAgICAgICAgdGVtcERpc3QgPSBNYXRoLmNlaWwoeUFicyAqIGZpcnN0SGFsZik7CiAgICAgICAgICAgIG1vdmVzLnB1c2goW3lEaXIsIHRlbXBEaXN0XSk7CiAgICAgICAgICAgIC8vIG1vdmUgYWxsIHRoZSB4IG9mZnNldAogICAgICAgICAgICBtb3Zlcy5wdXNoKFt4RGlyLCB4QWJzXSk7CiAgICAgICAgICAgIC8vIG1vdmUgc2VuZEhhbGYgb2YgdGhlICB5IG9mZnNldAogICAgICAgICAgICB0ZW1wRGlzdCA9IE1hdGguZmxvb3IoeUFicyAqIHNlY29uZEhhbGYpOwogICAgICAgICAgICBtb3Zlcy5wdXNoKFt5RGlyLCB0ZW1wRGlzdF0pOwogICAgICAgIH0KICAgICAgICBlbHNlCiAgICAgICAgewogICAgICAgICAgICAvLyAgbW92ZSBmaXJzdEhhbGYgb2YgdGhlIHggb2Zmc2V0CiAgICAgICAgICAgIHRlbXBEaXN0ID0gTWF0aC5jZWlsKHhBYnMgKiBmaXJzdEhhbGYpOwogICAgICAgICAgICBtb3Zlcy5wdXNoKFt4RGlyLCB0ZW1wRGlzdF0pOwogICAgICAgICAgICAvLyBtb3ZlIGFsbCB0aGUgeSBvZmZzZXQKICAgICAgICAgICAgbW92ZXMucHVzaChbeURpciwgeUFic10pOwogICAgICAgICAgICAvLyBtb3ZlIHNlY29uZEhhbGYgb2YgdGhlIHggb2Zmc2V0LgogICAgICAgICAgICB0ZW1wRGlzdCA9IE1hdGguZmxvb3IoeEFicyAqIHNlY29uZEhhbGYpOwogICAgICAgICAgICBtb3Zlcy5wdXNoKFt4RGlyLCB0ZW1wRGlzdF0pOwogICAgICAgIH0KCiAgICAgICAgdGhpcy5tYXBbeHBvc11beXBvc10gPSAwOwoKICAgICAgICB3aGlsZSAobW92ZXMubGVuZ3RoID4gMCkKICAgICAgICB7CiAgICAgICAgICAgIG1vdmUgPSBtb3Zlcy5wb3AoKTsKICAgICAgICAgICAgd2hpbGUgKG1vdmVbMV0gPiAwKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICB4cG9zICs9IFJPVC5ESVJTWzhdW21vdmVbMF1dWzBdOwogICAgICAgICAgICAgICAgeXBvcyArPSBST1QuRElSU1s4XVttb3ZlWzBdXVsxXTsKICAgICAgICAgICAgICAgIHRoaXMubWFwW3hwb3NdW3lwb3NdID0gMDsKICAgICAgICAgICAgICAgIG1vdmVbMV0gPSBtb3ZlWzFdIC0gMTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH07CgogICAgUk9ULk1hcC5Sb2d1ZS5wcm90b3R5cGUuX2NyZWF0ZUNvcnJpZG9ycyA9IGZ1bmN0aW9uKCkKICAgIHsKICAgICAgICAvLyBEcmF3IENvcnJpZG9ycyBiZXR3ZWVuIGNvbm5lY3RlZCByb29tcwoKICAgICAgICB2YXIgY3cgPSB0aGlzLl9vcHRpb25zLmNlbGxXaWR0aDsKICAgICAgICB2YXIgY2ggPSB0aGlzLl9vcHRpb25zLmNlbGxIZWlnaHQ7CiAgICAgICAgdmFyIHJvb207CiAgICAgICAgdmFyIGNvbm5lY3Rpb247CiAgICAgICAgdmFyIG90aGVyUm9vbTsKICAgICAgICB2YXIgd2FsbDsKICAgICAgICB2YXIgb3RoZXJXYWxsOwoKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN3OyBpKyspCiAgICAgICAgewogICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoOyBqKyspCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHJvb20gPSB0aGlzLnJvb21zW2ldW2pdOwoKICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcm9vbVsiY29ubmVjdGlvbnMiXS5sZW5ndGg7IGsrKykKICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbiA9IHJvb21bImNvbm5lY3Rpb25zIl1ba107CgogICAgICAgICAgICAgICAgICAgIG90aGVyUm9vbSA9IHRoaXMucm9vbXNbY29ubmVjdGlvblswXV1bY29ubmVjdGlvblsxXV07CgogICAgICAgICAgICAgICAgICAgIC8vIGZpZ3VyZSBvdXQgd2hhdCB3YWxsIG91ciBjb3JyaWRvciB3aWxsIHN0YXJ0IG9uZS4KICAgICAgICAgICAgICAgICAgICAvLyBmaWd1cmUgb3V0IHdoYXQgd2FsbCBvdXIgY29ycmlkb3Igd2lsbCBlbmQgb24uCiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyUm9vbVsiY2VsbHgiXSA+IHJvb21bImNlbGx4Il0pCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICB3YWxsID0gMjsKICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJXYWxsID0gNDsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3RoZXJSb29tWyJjZWxseCJdIDwgcm9vbVsiY2VsbHgiXSkKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgIHdhbGwgPSA0OwogICAgICAgICAgICAgICAgICAgICAgICBvdGhlcldhbGwgPSAyOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvdGhlclJvb21bImNlbGx5Il0gPiByb29tWyJjZWxseSJdKQogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgd2FsbCA9IDM7CiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyV2FsbCA9IDE7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG90aGVyUm9vbVsiY2VsbHkiXSA8IHJvb21bImNlbGx5Il0pCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICB3YWxsID0gMTsKICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJXYWxsID0gMzsKICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdDb3JyaWRvcih0aGlzLl9nZXRXYWxsUG9zaXRpb24ocm9vbSwgd2FsbCksIHRoaXMuX2dldFdhbGxQb3NpdGlvbihvdGhlclJvb20sIG90aGVyV2FsbCkpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfTsKICAgIC8qKgogICAgICogQGNsYXNzIER1bmdlb24gZmVhdHVyZTsgaGFzIG93biAuY3JlYXRlKCkgbWV0aG9kCiAgICAgKi8KICAgIFJPVC5NYXAuRmVhdHVyZSA9IGZ1bmN0aW9uKCkKICAgIHt9OwogICAgUk9ULk1hcC5GZWF0dXJlLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24oY2FuQmVEdWdDYWxsYmFjaykKICAgIHt9OwogICAgUk9ULk1hcC5GZWF0dXJlLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihkaWdDYWxsYmFjaykKICAgIHt9OwogICAgUk9ULk1hcC5GZWF0dXJlLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uKCkKICAgIHt9OwogICAgUk9ULk1hcC5GZWF0dXJlLmNyZWF0ZVJhbmRvbUF0ID0gZnVuY3Rpb24oeCwgeSwgZHgsIGR5LCBvcHRpb25zKQogICAge307CgogICAgLyoqCiAgICAgKiBAY2xhc3MgUm9vbQogICAgICogQGF1Z21lbnRzIFJPVC5NYXAuRmVhdHVyZQogICAgICogQHBhcmFtIHtpbnR9IHgxCiAgICAgKiBAcGFyYW0ge2ludH0geTEKICAgICAqIEBwYXJhbSB7aW50fSB4MgogICAgICogQHBhcmFtIHtpbnR9IHkyCiAgICAgKiBAcGFyYW0ge2ludH0gW2Rvb3JYXQogICAgICogQHBhcmFtIHtpbnR9IFtkb29yWV0KICAgICAqLwogICAgUk9ULk1hcC5GZWF0dXJlLlJvb20gPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgZG9vclgsIGRvb3JZKQogICAgewogICAgICAgIHRoaXMuX3gxID0geDE7CiAgICAgICAgdGhpcy5feTEgPSB5MTsKICAgICAgICB0aGlzLl94MiA9IHgyOwogICAgICAgIHRoaXMuX3kyID0geTI7CiAgICAgICAgdGhpcy5fZG9vcnMgPSB7fTsKICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDQpCiAgICAgICAgewogICAgICAgICAgICB0aGlzLmFkZERvb3IoZG9vclgsIGRvb3JZKTsKICAgICAgICB9CiAgICB9OwogICAgUk9ULk1hcC5GZWF0dXJlLlJvb20uZXh0ZW5kKFJPVC5NYXAuRmVhdHVyZSk7CgogICAgLyoqCiAgICAgKiBSb29tIG9mIHJhbmRvbSBzaXplLCB3aXRoIGEgZ2l2ZW4gZG9vcnMgYW5kIGRpcmVjdGlvbgogICAgICovCiAgICBST1QuTWFwLkZlYXR1cmUuUm9vbS5jcmVhdGVSYW5kb21BdCA9IGZ1bmN0aW9uKHgsIHksIGR4LCBkeSwgb3B0aW9ucykKICAgIHsKICAgICAgICB2YXIgbWluID0gb3B0aW9ucy5yb29tV2lkdGhbMF07CiAgICAgICAgdmFyIG1heCA9IG9wdGlvbnMucm9vbVdpZHRoWzFdOwogICAgICAgIHZhciB3aWR0aCA9IFJPVC5STkcuZ2V0VW5pZm9ybUludChtaW4sIG1heCk7CgogICAgICAgIHZhciBtaW4gPSBvcHRpb25zLnJvb21IZWlnaHRbMF07CiAgICAgICAgdmFyIG1heCA9IG9wdGlvbnMucm9vbUhlaWdodFsxXTsKICAgICAgICB2YXIgaGVpZ2h0ID0gUk9ULlJORy5nZXRVbmlmb3JtSW50KG1pbiwgbWF4KTsKCiAgICAgICAgaWYgKGR4ID09IDEpCiAgICAgICAgeyAvKiB0byB0aGUgcmlnaHQgKi8KICAgICAgICAgICAgdmFyIHkyID0geSAtIE1hdGguZmxvb3IoUk9ULlJORy5nZXRVbmlmb3JtKCkgKiBoZWlnaHQpOwogICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMoeCArIDEsIHkyLCB4ICsgd2lkdGgsIHkyICsgaGVpZ2h0IC0gMSwgeCwgeSk7CiAgICAgICAgfQoKICAgICAgICBpZiAoZHggPT0gLTEpCiAgICAgICAgeyAvKiB0byB0aGUgbGVmdCAqLwogICAgICAgICAgICB2YXIgeTIgPSB5IC0gTWF0aC5mbG9vcihST1QuUk5HLmdldFVuaWZvcm0oKSAqIGhlaWdodCk7CiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcyh4IC0gd2lkdGgsIHkyLCB4IC0gMSwgeTIgKyBoZWlnaHQgLSAxLCB4LCB5KTsKICAgICAgICB9CgogICAgICAgIGlmIChkeSA9PSAxKQogICAgICAgIHsgLyogdG8gdGhlIGJvdHRvbSAqLwogICAgICAgICAgICB2YXIgeDIgPSB4IC0gTWF0aC5mbG9vcihST1QuUk5HLmdldFVuaWZvcm0oKSAqIHdpZHRoKTsKICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHgyLCB5ICsgMSwgeDIgKyB3aWR0aCAtIDEsIHkgKyBoZWlnaHQsIHgsIHkpOwogICAgICAgIH0KCiAgICAgICAgaWYgKGR5ID09IC0xKQogICAgICAgIHsgLyogdG8gdGhlIHRvcCAqLwogICAgICAgICAgICB2YXIgeDIgPSB4IC0gTWF0aC5mbG9vcihST1QuUk5HLmdldFVuaWZvcm0oKSAqIHdpZHRoKTsKICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHgyLCB5IC0gaGVpZ2h0LCB4MiArIHdpZHRoIC0gMSwgeSAtIDEsIHgsIHkpOwogICAgICAgIH0KCiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJkeCBvciBkeSBtdXN0IGJlIDEgb3IgLTEiKTsKICAgIH07CgogICAgLyoqCiAgICAgKiBSb29tIG9mIHJhbmRvbSBzaXplLCBwb3NpdGlvbmVkIGFyb3VuZCBjZW50ZXIgY29vcmRzCiAgICAgKi8KICAgIFJPVC5NYXAuRmVhdHVyZS5Sb29tLmNyZWF0ZVJhbmRvbUNlbnRlciA9IGZ1bmN0aW9uKGN4LCBjeSwgb3B0aW9ucykKICAgIHsKICAgICAgICB2YXIgbWluID0gb3B0aW9ucy5yb29tV2lkdGhbMF07CiAgICAgICAgdmFyIG1heCA9IG9wdGlvbnMucm9vbVdpZHRoWzFdOwogICAgICAgIHZhciB3aWR0aCA9IFJPVC5STkcuZ2V0VW5pZm9ybUludChtaW4sIG1heCk7CgogICAgICAgIHZhciBtaW4gPSBvcHRpb25zLnJvb21IZWlnaHRbMF07CiAgICAgICAgdmFyIG1heCA9IG9wdGlvbnMucm9vbUhlaWdodFsxXTsKICAgICAgICB2YXIgaGVpZ2h0ID0gUk9ULlJORy5nZXRVbmlmb3JtSW50KG1pbiwgbWF4KTsKCiAgICAgICAgdmFyIHgxID0gY3ggLSBNYXRoLmZsb29yKFJPVC5STkcuZ2V0VW5pZm9ybSgpICogd2lkdGgpOwogICAgICAgIHZhciB5MSA9IGN5IC0gTWF0aC5mbG9vcihST1QuUk5HLmdldFVuaWZvcm0oKSAqIGhlaWdodCk7CiAgICAgICAgdmFyIHgyID0geDEgKyB3aWR0aCAtIDE7CiAgICAgICAgdmFyIHkyID0geTEgKyBoZWlnaHQgLSAxOwoKICAgICAgICByZXR1cm4gbmV3IHRoaXMoeDEsIHkxLCB4MiwgeTIpOwogICAgfTsKCiAgICAvKioKICAgICAqIFJvb20gb2YgcmFuZG9tIHNpemUgd2l0aGluIGEgZ2l2ZW4gZGltZW5zaW9ucwogICAgICovCiAgICBST1QuTWFwLkZlYXR1cmUuUm9vbS5jcmVhdGVSYW5kb20gPSBmdW5jdGlvbihhdmFpbFdpZHRoLCBhdmFpbEhlaWdodCwgb3B0aW9ucykKICAgIHsKICAgICAgICB2YXIgbWluID0gb3B0aW9ucy5yb29tV2lkdGhbMF07CiAgICAgICAgdmFyIG1heCA9IG9wdGlvbnMucm9vbVdpZHRoWzFdOwogICAgICAgIHZhciB3aWR0aCA9IFJPVC5STkcuZ2V0VW5pZm9ybUludChtaW4sIG1heCk7CgogICAgICAgIHZhciBtaW4gPSBvcHRpb25zLnJvb21IZWlnaHRbMF07CiAgICAgICAgdmFyIG1heCA9IG9wdGlvbnMucm9vbUhlaWdodFsxXTsKICAgICAgICB2YXIgaGVpZ2h0ID0gUk9ULlJORy5nZXRVbmlmb3JtSW50KG1pbiwgbWF4KTsKCiAgICAgICAgdmFyIGxlZnQgPSBhdmFpbFdpZHRoIC0gd2lkdGggLSAxOwogICAgICAgIHZhciB0b3AgPSBhdmFpbEhlaWdodCAtIGhlaWdodCAtIDE7CgogICAgICAgIHZhciB4MSA9IDEgKyBNYXRoLmZsb29yKFJPVC5STkcuZ2V0VW5pZm9ybSgpICogbGVmdCk7CiAgICAgICAgdmFyIHkxID0gMSArIE1hdGguZmxvb3IoUk9ULlJORy5nZXRVbmlmb3JtKCkgKiB0b3ApOwogICAgICAgIHZhciB4MiA9IHgxICsgd2lkdGggLSAxOwogICAgICAgIHZhciB5MiA9IHkxICsgaGVpZ2h0IC0gMTsKCiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHgxLCB5MSwgeDIsIHkyKTsKICAgIH07CgogICAgUk9ULk1hcC5GZWF0dXJlLlJvb20ucHJvdG90eXBlLmFkZERvb3IgPSBmdW5jdGlvbih4LCB5KQogICAgewogICAgICAgIHRoaXMuX2Rvb3JzW3ggKyAiLCIgKyB5XSA9IDE7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICB9OwoKICAgIC8qKgogICAgICogQHBhcmFtIHtmdW5jdGlvbn0KICAgICAqLwogICAgUk9ULk1hcC5GZWF0dXJlLlJvb20ucHJvdG90eXBlLmdldERvb3JzID0gZnVuY3Rpb24oY2FsbGJhY2spCiAgICB7CiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2Rvb3JzKQogICAgICAgIHsKICAgICAgICAgICAgdmFyIHBhcnRzID0ga2V5LnNwbGl0KCIsIik7CiAgICAgICAgICAgIGNhbGxiYWNrKHBhcnNlSW50KHBhcnRzWzBdKSwgcGFyc2VJbnQocGFydHNbMV0pKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICB9OwoKICAgIFJPVC5NYXAuRmVhdHVyZS5Sb29tLnByb3RvdHlwZS5jbGVhckRvb3JzID0gZnVuY3Rpb24oKQogICAgewogICAgICAgIHRoaXMuX2Rvb3JzID0ge307CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICB9OwoKICAgIFJPVC5NYXAuRmVhdHVyZS5Sb29tLnByb3RvdHlwZS5hZGREb29ycyA9IGZ1bmN0aW9uKGlzV2FsbENhbGxiYWNrKQogICAgewogICAgICAgIHZhciBsZWZ0ID0gdGhpcy5feDEgLSAxOwogICAgICAgIHZhciByaWdodCA9IHRoaXMuX3gyICsgMTsKICAgICAgICB2YXIgdG9wID0gdGhpcy5feTEgLSAxOwogICAgICAgIHZhciBib3R0b20gPSB0aGlzLl95MiArIDE7CgogICAgICAgIGZvciAodmFyIHggPSBsZWZ0OyB4IDw9IHJpZ2h0OyB4KyspCiAgICAgICAgewogICAgICAgICAgICBmb3IgKHZhciB5ID0gdG9wOyB5IDw9IGJvdHRvbTsgeSsrKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBpZiAoeCAhPSBsZWZ0ICYmIHggIT0gcmlnaHQgJiYgeSAhPSB0b3AgJiYgeSAhPSBib3R0b20pCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoaXNXYWxsQ2FsbGJhY2soeCwgeSkpCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgdGhpcy5hZGREb29yKHgsIHkpOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gdGhpczsKICAgIH07CgogICAgUk9ULk1hcC5GZWF0dXJlLlJvb20ucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24oKQogICAgewogICAgICAgIGNvbnNvbGUubG9nKCJyb29tIiwgdGhpcy5feDEsIHRoaXMuX3kxLCB0aGlzLl94MiwgdGhpcy5feTIpOwogICAgfTsKCiAgICBST1QuTWFwLkZlYXR1cmUuUm9vbS5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uKGlzV2FsbENhbGxiYWNrLCBjYW5CZUR1Z0NhbGxiYWNrKQogICAgewogICAgICAgIHZhciBsZWZ0ID0gdGhpcy5feDEgLSAxOwogICAgICAgIHZhciByaWdodCA9IHRoaXMuX3gyICsgMTsKICAgICAgICB2YXIgdG9wID0gdGhpcy5feTEgLSAxOwogICAgICAgIHZhciBib3R0b20gPSB0aGlzLl95MiArIDE7CgogICAgICAgIGZvciAodmFyIHggPSBsZWZ0OyB4IDw9IHJpZ2h0OyB4KyspCiAgICAgICAgewogICAgICAgICAgICBmb3IgKHZhciB5ID0gdG9wOyB5IDw9IGJvdHRvbTsgeSsrKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBpZiAoeCA9PSBsZWZ0IHx8IHggPT0gcmlnaHQgfHwgeSA9PSB0b3AgfHwgeSA9PSBib3R0b20pCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1dhbGxDYWxsYmFjayh4LCB5KSkKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5CZUR1Z0NhbGxiYWNrKHgsIHkpKQogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIHRydWU7CiAgICB9OwoKICAgIC8qKgogICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZGlnQ2FsbGJhY2sgRGlnIGNhbGxiYWNrIHdpdGggYSBzaWduYXR1cmUgKHgsIHksIHZhbHVlKS4gVmFsdWVzOiAwID0gZW1wdHksIDEgPSB3YWxsLCAyID0gZG9vci4gTXVsdGlwbGUgZG9vcnMgYXJlIGFsbG93ZWQuCiAgICAgKi8KICAgIFJPVC5NYXAuRmVhdHVyZS5Sb29tLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihkaWdDYWxsYmFjaykKICAgIHsKICAgICAgICB2YXIgbGVmdCA9IHRoaXMuX3gxIC0gMTsKICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLl94MiArIDE7CiAgICAgICAgdmFyIHRvcCA9IHRoaXMuX3kxIC0gMTsKICAgICAgICB2YXIgYm90dG9tID0gdGhpcy5feTIgKyAxOwoKICAgICAgICB2YXIgdmFsdWUgPSAwOwogICAgICAgIGZvciAodmFyIHggPSBsZWZ0OyB4IDw9IHJpZ2h0OyB4KyspCiAgICAgICAgewogICAgICAgICAgICBmb3IgKHZhciB5ID0gdG9wOyB5IDw9IGJvdHRvbTsgeSsrKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBpZiAoeCArICIsIiArIHkgaW4gdGhpcy5fZG9vcnMpCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAyOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZWxzZSBpZiAoeCA9PSBsZWZ0IHx8IHggPT0gcmlnaHQgfHwgeSA9PSB0b3AgfHwgeSA9PSBib3R0b20pCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAxOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIHZhbHVlID0gMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGRpZ0NhbGxiYWNrKHgsIHksIHZhbHVlKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH07CgogICAgUk9ULk1hcC5GZWF0dXJlLlJvb20ucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uKCkKICAgIHsKICAgICAgICByZXR1cm4gW01hdGgucm91bmQoKHRoaXMuX3gxICsgdGhpcy5feDIpIC8gMiksIE1hdGgucm91bmQoKHRoaXMuX3kxICsgdGhpcy5feTIpIC8gMildOwogICAgfTsKCiAgICBST1QuTWFwLkZlYXR1cmUuUm9vbS5wcm90b3R5cGUuZ2V0TGVmdCA9IGZ1bmN0aW9uKCkKICAgIHsKICAgICAgICByZXR1cm4gdGhpcy5feDE7CiAgICB9OwoKICAgIFJPVC5NYXAuRmVhdHVyZS5Sb29tLnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uKCkKICAgIHsKICAgICAgICByZXR1cm4gdGhpcy5feDI7CiAgICB9OwoKICAgIFJPVC5NYXAuRmVhdHVyZS5Sb29tLnByb3RvdHlwZS5nZXRUb3AgPSBmdW5jdGlvbigpCiAgICB7CiAgICAgICAgcmV0dXJuIHRoaXMuX3kxOwogICAgfTsKCiAgICBST1QuTWFwLkZlYXR1cmUuUm9vbS5wcm90b3R5cGUuZ2V0Qm90dG9tID0gZnVuY3Rpb24oKQogICAgewogICAgICAgIHJldHVybiB0aGlzLl95MjsKICAgIH07CgogICAgLyoqCiAgICAgKiBAY2xhc3MgQ29ycmlkb3IKICAgICAqIEBhdWdtZW50cyBST1QuTWFwLkZlYXR1cmUKICAgICAqIEBwYXJhbSB7aW50fSBzdGFydFgKICAgICAqIEBwYXJhbSB7aW50fSBzdGFydFkKICAgICAqIEBwYXJhbSB7aW50fSBlbmRYCiAgICAgKiBAcGFyYW0ge2ludH0gZW5kWQogICAgICovCiAgICBST1QuTWFwLkZlYXR1cmUuQ29ycmlkb3IgPSBmdW5jdGlvbihzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSkKICAgIHsKICAgICAgICB0aGlzLl9zdGFydFggPSBzdGFydFg7CiAgICAgICAgdGhpcy5fc3RhcnRZID0gc3RhcnRZOwogICAgICAgIHRoaXMuX2VuZFggPSBlbmRYOwogICAgICAgIHRoaXMuX2VuZFkgPSBlbmRZOwogICAgICAgIHRoaXMuX2VuZHNXaXRoQVdhbGwgPSB0cnVlOwogICAgfTsKICAgIFJPVC5NYXAuRmVhdHVyZS5Db3JyaWRvci5leHRlbmQoUk9ULk1hcC5GZWF0dXJlKTsKCiAgICBST1QuTWFwLkZlYXR1cmUuQ29ycmlkb3IuY3JlYXRlUmFuZG9tQXQgPSBmdW5jdGlvbih4LCB5LCBkeCwgZHksIG9wdGlvbnMpCiAgICB7CiAgICAgICAgdmFyIG1pbiA9IG9wdGlvbnMuY29ycmlkb3JMZW5ndGhbMF07CiAgICAgICAgdmFyIG1heCA9IG9wdGlvbnMuY29ycmlkb3JMZW5ndGhbMV07CiAgICAgICAgdmFyIGxlbmd0aCA9IFJPVC5STkcuZ2V0VW5pZm9ybUludChtaW4sIG1heCk7CgogICAgICAgIHJldHVybiBuZXcgdGhpcyh4LCB5LCB4ICsgZHggKiBsZW5ndGgsIHkgKyBkeSAqIGxlbmd0aCk7CiAgICB9OwoKICAgIFJPVC5NYXAuRmVhdHVyZS5Db3JyaWRvci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbigpCiAgICB7CiAgICAgICAgY29uc29sZS5sb2coImNvcnJpZG9yIiwgdGhpcy5fc3RhcnRYLCB0aGlzLl9zdGFydFksIHRoaXMuX2VuZFgsIHRoaXMuX2VuZFkpOwogICAgfTsKCiAgICBST1QuTWFwLkZlYXR1cmUuQ29ycmlkb3IucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbihpc1dhbGxDYWxsYmFjaywgY2FuQmVEdWdDYWxsYmFjaykKICAgIHsKICAgICAgICB2YXIgc3ggPSB0aGlzLl9zdGFydFg7CiAgICAgICAgdmFyIHN5ID0gdGhpcy5fc3RhcnRZOwogICAgICAgIHZhciBkeCA9IHRoaXMuX2VuZFggLSBzeDsKICAgICAgICB2YXIgZHkgPSB0aGlzLl9lbmRZIC0gc3k7CiAgICAgICAgdmFyIGxlbmd0aCA9IDEgKyBNYXRoLm1heChNYXRoLmFicyhkeCksIE1hdGguYWJzKGR5KSk7CgogICAgICAgIGlmIChkeCkKICAgICAgICB7CiAgICAgICAgICAgIGR4ID0gZHggLyBNYXRoLmFicyhkeCk7CiAgICAgICAgfQogICAgICAgIGlmIChkeSkKICAgICAgICB7CiAgICAgICAgICAgIGR5ID0gZHkgLyBNYXRoLmFicyhkeSk7CiAgICAgICAgfQogICAgICAgIHZhciBueCA9IGR5OwogICAgICAgIHZhciBueSA9IC1keDsKCiAgICAgICAgdmFyIG9rID0gdHJ1ZTsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKQogICAgICAgIHsKICAgICAgICAgICAgdmFyIHggPSBzeCArIGkgKiBkeDsKICAgICAgICAgICAgdmFyIHkgPSBzeSArIGkgKiBkeTsKCiAgICAgICAgICAgIGlmICghY2FuQmVEdWdDYWxsYmFjayh4LCB5KSkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgb2sgPSBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoIWlzV2FsbENhbGxiYWNrKHggKyBueCwgeSArIG55KSkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgb2sgPSBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoIWlzV2FsbENhbGxiYWNrKHggLSBueCwgeSAtIG55KSkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgb2sgPSBmYWxzZTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKCFvaykKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgbGVuZ3RoID0gaTsKICAgICAgICAgICAgICAgIHRoaXMuX2VuZFggPSB4IC0gZHg7CiAgICAgICAgICAgICAgICB0aGlzLl9lbmRZID0geSAtIGR5OwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8qKgogICAgICAgICAqIElmIHRoZSBsZW5ndGggZGVnZW5lcmF0ZWQsIHRoaXMgY29ycmlkb3IgbWlnaHQgYmUgaW52YWxpZAogICAgICAgICAqLwoKICAgICAgICAvKiBub3Qgc3VwcG9ydGVkICovCiAgICAgICAgaWYgKGxlbmd0aCA9PSAwKQogICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KCiAgICAgICAgLyogbGVuZ3RoIDEgYWxsb3dlZCBvbmx5IGlmIHRoZSBuZXh0IHNwYWNlIGlzIGVtcHR5ICovCiAgICAgICAgaWYgKGxlbmd0aCA9PSAxICYmIGlzV2FsbENhbGxiYWNrKHRoaXMuX2VuZFggKyBkeCwgdGhpcy5fZW5kWSArIGR5KSkKICAgICAgICB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CgogICAgICAgIC8qKgogICAgICAgICAqIFdlIGRvIG5vdCB3YW50IHRoZSBjb3JyaWRvciB0byBjcmFzaCBpbnRvIGEgY29ybmVyIG9mIGEgcm9vbTsKICAgICAgICAgKiBpZiBhbnkgb2YgdGhlIGVuZGluZyBjb3JuZXJzIGlzIGVtcHR5LCB0aGUgTisxdGggY2VsbCBvZiB0aGlzIGNvcnJpZG9yIG11c3QgYmUgZW1wdHkgdG9vLgogICAgICAgICAqCiAgICAgICAgICogU2l0dWF0aW9uOgogICAgICAgICAqICMjIyMjIyMxCiAgICAgICAgICogLi4uLi4uLj8KICAgICAgICAgKiAjIyMjIyMjMgogICAgICAgICAqCiAgICAgICAgICogVGhlIGNvcnJpZG9yIHdhcyBkdWcgZnJvbSBsZWZ0IHRvIHJpZ2h0LgogICAgICAgICAqIDEsIDIgLSBwcm9ibGVtYXRpYyBjb3JuZXJzLCA/ID0gTisxdGggY2VsbCAobm90IGR1ZykKICAgICAgICAgKi8KICAgICAgICB2YXIgZmlyc3RDb3JuZXJCYWQgPSAhaXNXYWxsQ2FsbGJhY2sodGhpcy5fZW5kWCArIGR4ICsgbngsIHRoaXMuX2VuZFkgKyBkeSArIG55KTsKICAgICAgICB2YXIgc2Vjb25kQ29ybmVyQmFkID0gIWlzV2FsbENhbGxiYWNrKHRoaXMuX2VuZFggKyBkeCAtIG54LCB0aGlzLl9lbmRZICsgZHkgLSBueSk7CiAgICAgICAgdGhpcy5fZW5kc1dpdGhBV2FsbCA9IGlzV2FsbENhbGxiYWNrKHRoaXMuX2VuZFggKyBkeCwgdGhpcy5fZW5kWSArIGR5KTsKICAgICAgICBpZiAoKGZpcnN0Q29ybmVyQmFkIHx8IHNlY29uZENvcm5lckJhZCkgJiYgdGhpcy5fZW5kc1dpdGhBV2FsbCkKICAgICAgICB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CgogICAgICAgIHJldHVybiB0cnVlOwogICAgfTsKCiAgICAvKioKICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGRpZ0NhbGxiYWNrIERpZyBjYWxsYmFjayB3aXRoIGEgc2lnbmF0dXJlICh4LCB5LCB2YWx1ZSkuIFZhbHVlczogMCA9IGVtcHR5LgogICAgICovCiAgICBST1QuTWFwLkZlYXR1cmUuQ29ycmlkb3IucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGRpZ0NhbGxiYWNrKQogICAgewogICAgICAgIHZhciBzeCA9IHRoaXMuX3N0YXJ0WDsKICAgICAgICB2YXIgc3kgPSB0aGlzLl9zdGFydFk7CiAgICAgICAgdmFyIGR4ID0gdGhpcy5fZW5kWCAtIHN4OwogICAgICAgIHZhciBkeSA9IHRoaXMuX2VuZFkgLSBzeTsKICAgICAgICB2YXIgbGVuZ3RoID0gMSArIE1hdGgubWF4KE1hdGguYWJzKGR4KSwgTWF0aC5hYnMoZHkpKTsKCiAgICAgICAgaWYgKGR4KQogICAgICAgIHsKICAgICAgICAgICAgZHggPSBkeCAvIE1hdGguYWJzKGR4KTsKICAgICAgICB9CiAgICAgICAgaWYgKGR5KQogICAgICAgIHsKICAgICAgICAgICAgZHkgPSBkeSAvIE1hdGguYWJzKGR5KTsKICAgICAgICB9CiAgICAgICAgdmFyIG54ID0gZHk7CiAgICAgICAgdmFyIG55ID0gLWR4OwoKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKQogICAgICAgIHsKICAgICAgICAgICAgdmFyIHggPSBzeCArIGkgKiBkeDsKICAgICAgICAgICAgdmFyIHkgPSBzeSArIGkgKiBkeTsKICAgICAgICAgICAgZGlnQ2FsbGJhY2soeCwgeSwgMCk7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH07CgogICAgUk9ULk1hcC5GZWF0dXJlLkNvcnJpZG9yLnByb3RvdHlwZS5jcmVhdGVQcmlvcml0eVdhbGxzID0gZnVuY3Rpb24ocHJpb3JpdHlXYWxsQ2FsbGJhY2spCiAgICB7CiAgICAgICAgaWYgKCF0aGlzLl9lbmRzV2l0aEFXYWxsKQogICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgdmFyIHN4ID0gdGhpcy5fc3RhcnRYOwogICAgICAgIHZhciBzeSA9IHRoaXMuX3N0YXJ0WTsKCiAgICAgICAgdmFyIGR4ID0gdGhpcy5fZW5kWCAtIHN4OwogICAgICAgIHZhciBkeSA9IHRoaXMuX2VuZFkgLSBzeTsKICAgICAgICBpZiAoZHgpCiAgICAgICAgewogICAgICAgICAgICBkeCA9IGR4IC8gTWF0aC5hYnMoZHgpOwogICAgICAgIH0KICAgICAgICBpZiAoZHkpCiAgICAgICAgewogICAgICAgICAgICBkeSA9IGR5IC8gTWF0aC5hYnMoZHkpOwogICAgICAgIH0KICAgICAgICB2YXIgbnggPSBkeTsKICAgICAgICB2YXIgbnkgPSAtZHg7CgogICAgICAgIHByaW9yaXR5V2FsbENhbGxiYWNrKHRoaXMuX2VuZFggKyBkeCwgdGhpcy5fZW5kWSArIGR5KTsKICAgICAgICBwcmlvcml0eVdhbGxDYWxsYmFjayh0aGlzLl9lbmRYICsgbngsIHRoaXMuX2VuZFkgKyBueSk7CiAgICAgICAgcHJpb3JpdHlXYWxsQ2FsbGJhY2sodGhpcy5fZW5kWCAtIG54LCB0aGlzLl9lbmRZIC0gbnkpOwogICAgfTsKICAgIC8qKgogICAgICogQGNsYXNzIEJhc2Ugbm9pc2UgZ2VuZXJhdG9yCiAgICAgKi8KICAgIFJPVC5Ob2lzZSA9IGZ1bmN0aW9uKCkKICAgIHt9OwoKICAgIFJPVC5Ob2lzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oeCwgeSkKICAgIHt9OwogICAgLyoqCiAgICAgKiBBIHNpbXBsZSAyZCBpbXBsZW1lbnRhdGlvbiBvZiBzaW1wbGV4IG5vaXNlIGJ5IE9uZHJlaiBaYXJhCiAgICAgKgogICAgICogQmFzZWQgb24gYSBzcGVlZC1pbXByb3ZlZCBzaW1wbGV4IG5vaXNlIGFsZ29yaXRobSBmb3IgMkQsIDNEIGFuZCA0RCBpbiBKYXZhLgogICAgICogV2hpY2ggaXMgYmFzZWQgb24gZXhhbXBsZSBjb2RlIGJ5IFN0ZWZhbiBHdXN0YXZzb24gKHN0ZWd1QGl0bi5saXUuc2UpLgogICAgICogV2l0aCBPcHRpbWlzYXRpb25zIGJ5IFBldGVyIEVhc3RtYW4gKHBlYXN0bWFuQGRyaXp6bGUuc3RhbmZvcmQuZWR1KS4KICAgICAqIEJldHRlciByYW5rIG9yZGVyaW5nIG1ldGhvZCBieSBTdGVmYW4gR3VzdGF2c29uIGluIDIwMTIuCiAgICAgKi8KCiAgICAvKioKICAgICAqIEBjbGFzcyAyRCBzaW1wbGV4IG5vaXNlIGdlbmVyYXRvcgogICAgICogQHBhcmFtIHtpbnR9IFtncmFkaWVudHM9MjU2XSBSYW5kb20gZ3JhZGllbnRzCiAgICAgKi8KICAgIFJPVC5Ob2lzZS5TaW1wbGV4ID0gZnVuY3Rpb24oZ3JhZGllbnRzKQogICAgewogICAgICAgIFJPVC5Ob2lzZS5jYWxsKHRoaXMpOwoKICAgICAgICB0aGlzLl9GMiA9IDAuNSAqIChNYXRoLnNxcnQoMykgLSAxKTsKICAgICAgICB0aGlzLl9HMiA9ICgzIC0gTWF0aC5zcXJ0KDMpKSAvIDY7CgogICAgICAgIHRoaXMuX2dyYWRpZW50cyA9IFsKICAgICAgICBbMCwgLTFdLAogICAgICAgIFsxLCAtMV0sCiAgICAgICAgWzEsIDBdLAogICAgICAgIFsxLCAxXSwKICAgICAgICBbMCwgMV0sCiAgICAgICAgWy0xLCAxXSwKICAgICAgICBbLTEsIDBdLAogICAgICAgIFstMSwgLTFdCiAgICBdOwoKICAgICAgICB2YXIgcGVybXV0YXRpb25zID0gW107CiAgICAgICAgdmFyIGNvdW50ID0gZ3JhZGllbnRzIHx8IDI1NjsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspCiAgICAgICAgewogICAgICAgICAgICBwZXJtdXRhdGlvbnMucHVzaChpKTsKICAgICAgICB9CiAgICAgICAgcGVybXV0YXRpb25zID0gcGVybXV0YXRpb25zLnJhbmRvbWl6ZSgpOwoKICAgICAgICB0aGlzLl9wZXJtcyA9IFtdOwogICAgICAgIHRoaXMuX2luZGV4ZXMgPSBbXTsKCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyICogY291bnQ7IGkrKykKICAgICAgICB7CiAgICAgICAgICAgIHRoaXMuX3Blcm1zLnB1c2gocGVybXV0YXRpb25zW2kgJSBjb3VudF0pOwogICAgICAgICAgICB0aGlzLl9pbmRleGVzLnB1c2godGhpcy5fcGVybXNbaV0gJSB0aGlzLl9ncmFkaWVudHMubGVuZ3RoKTsKICAgICAgICB9CgogICAgfTsKICAgIFJPVC5Ob2lzZS5TaW1wbGV4LmV4dGVuZChST1QuTm9pc2UpOwoKICAgIFJPVC5Ob2lzZS5TaW1wbGV4LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbih4aW4sIHlpbikKICAgIHsKICAgICAgICB2YXIgcGVybXMgPSB0aGlzLl9wZXJtczsKICAgICAgICB2YXIgaW5kZXhlcyA9IHRoaXMuX2luZGV4ZXM7CiAgICAgICAgdmFyIGNvdW50ID0gcGVybXMubGVuZ3RoIC8gMjsKICAgICAgICB2YXIgRzIgPSB0aGlzLl9HMjsKCiAgICAgICAgdmFyIG4wID0gMCwKICAgICAgICAgICAgbjEgPSAwLAogICAgICAgICAgICBuMiA9IDAsCiAgICAgICAgICAgIGdpOyAvLyBOb2lzZSBjb250cmlidXRpb25zIGZyb20gdGhlIHRocmVlIGNvcm5lcnMKCiAgICAgICAgLy8gU2tldyB0aGUgaW5wdXQgc3BhY2UgdG8gZGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggY2VsbCB3ZSdyZSBpbgogICAgICAgIHZhciBzID0gKHhpbiArIHlpbikgKiB0aGlzLl9GMjsgLy8gSGFpcnkgZmFjdG9yIGZvciAyRAogICAgICAgIHZhciBpID0gTWF0aC5mbG9vcih4aW4gKyBzKTsKICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoeWluICsgcyk7CiAgICAgICAgdmFyIHQgPSAoaSArIGopICogRzI7CiAgICAgICAgdmFyIFgwID0gaSAtIHQ7IC8vIFVuc2tldyB0aGUgY2VsbCBvcmlnaW4gYmFjayB0byAoeCx5KSBzcGFjZQogICAgICAgIHZhciBZMCA9IGogLSB0OwogICAgICAgIHZhciB4MCA9IHhpbiAtIFgwOyAvLyBUaGUgeCx5IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpbgogICAgICAgIHZhciB5MCA9IHlpbiAtIFkwOwoKICAgICAgICAvLyBGb3IgdGhlIDJEIGNhc2UsIHRoZSBzaW1wbGV4IHNoYXBlIGlzIGFuIGVxdWlsYXRlcmFsIHRyaWFuZ2xlLgogICAgICAgIC8vIERldGVybWluZSB3aGljaCBzaW1wbGV4IHdlIGFyZSBpbi4KICAgICAgICB2YXIgaTEsIGoxOyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgKG1pZGRsZSkgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaikgY29vcmRzCiAgICAgICAgaWYgKHgwID4geTApCiAgICAgICAgewogICAgICAgICAgICBpMSA9IDE7CiAgICAgICAgICAgIGoxID0gMDsKICAgICAgICB9CiAgICAgICAgZWxzZQogICAgICAgIHsgLy8gbG93ZXIgdHJpYW5nbGUsIFhZIG9yZGVyOiAoMCwwKS0+KDEsMCktPigxLDEpCiAgICAgICAgICAgIGkxID0gMDsKICAgICAgICAgICAgajEgPSAxOwogICAgICAgIH0gLy8gdXBwZXIgdHJpYW5nbGUsIFlYIG9yZGVyOiAoMCwwKS0+KDAsMSktPigxLDEpCgogICAgICAgIC8vIEEgc3RlcCBvZiAoMSwwKSBpbiAoaSxqKSBtZWFucyBhIHN0ZXAgb2YgKDEtYywtYykgaW4gKHgseSksIGFuZAogICAgICAgIC8vIGEgc3RlcCBvZiAoMCwxKSBpbiAoaSxqKSBtZWFucyBhIHN0ZXAgb2YgKC1jLDEtYykgaW4gKHgseSksIHdoZXJlCiAgICAgICAgLy8gYyA9ICgzLXNxcnQoMykpLzYKICAgICAgICB2YXIgeDEgPSB4MCAtIGkxICsgRzI7IC8vIE9mZnNldHMgZm9yIG1pZGRsZSBjb3JuZXIgaW4gKHgseSkgdW5za2V3ZWQgY29vcmRzCiAgICAgICAgdmFyIHkxID0geTAgLSBqMSArIEcyOwogICAgICAgIHZhciB4MiA9IHgwIC0gMSArIDIgKiBHMjsgLy8gT2Zmc2V0cyBmb3IgbGFzdCBjb3JuZXIgaW4gKHgseSkgdW5za2V3ZWQgY29vcmRzCiAgICAgICAgdmFyIHkyID0geTAgLSAxICsgMiAqIEcyOwoKICAgICAgICAvLyBXb3JrIG91dCB0aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIHRocmVlIHNpbXBsZXggY29ybmVycwogICAgICAgIHZhciBpaSA9IGkubW9kKGNvdW50KTsKICAgICAgICB2YXIgamogPSBqLm1vZChjb3VudCk7CgogICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgY29udHJpYnV0aW9uIGZyb20gdGhlIHRocmVlIGNvcm5lcnMKICAgICAgICB2YXIgdDAgPSAwLjUgLSB4MCAqIHgwIC0geTAgKiB5MDsKICAgICAgICBpZiAodDAgPj0gMCkKICAgICAgICB7CiAgICAgICAgICAgIHQwICo9IHQwOwogICAgICAgICAgICBnaSA9IGluZGV4ZXNbaWkgKyBwZXJtc1tqal1dOwogICAgICAgICAgICB2YXIgZ3JhZCA9IHRoaXMuX2dyYWRpZW50c1tnaV07CiAgICAgICAgICAgIG4wID0gdDAgKiB0MCAqIChncmFkWzBdICogeDAgKyBncmFkWzFdICogeTApOwogICAgICAgIH0KCiAgICAgICAgdmFyIHQxID0gMC41IC0geDEgKiB4MSAtIHkxICogeTE7CiAgICAgICAgaWYgKHQxID49IDApCiAgICAgICAgewogICAgICAgICAgICB0MSAqPSB0MTsKICAgICAgICAgICAgZ2kgPSBpbmRleGVzW2lpICsgaTEgKyBwZXJtc1tqaiArIGoxXV07CiAgICAgICAgICAgIHZhciBncmFkID0gdGhpcy5fZ3JhZGllbnRzW2dpXTsKICAgICAgICAgICAgbjEgPSB0MSAqIHQxICogKGdyYWRbMF0gKiB4MSArIGdyYWRbMV0gKiB5MSk7CiAgICAgICAgfQoKICAgICAgICB2YXIgdDIgPSAwLjUgLSB4MiAqIHgyIC0geTIgKiB5MjsKICAgICAgICBpZiAodDIgPj0gMCkKICAgICAgICB7CiAgICAgICAgICAgIHQyICo9IHQyOwogICAgICAgICAgICBnaSA9IGluZGV4ZXNbaWkgKyAxICsgcGVybXNbamogKyAxXV07CiAgICAgICAgICAgIHZhciBncmFkID0gdGhpcy5fZ3JhZGllbnRzW2dpXTsKICAgICAgICAgICAgbjIgPSB0MiAqIHQyICogKGdyYWRbMF0gKiB4MiArIGdyYWRbMV0gKiB5Mik7CiAgICAgICAgfQoKICAgICAgICAvLyBBZGQgY29udHJpYnV0aW9ucyBmcm9tIGVhY2ggY29ybmVyIHRvIGdldCB0aGUgZmluYWwgbm9pc2UgdmFsdWUuCiAgICAgICAgLy8gVGhlIHJlc3VsdCBpcyBzY2FsZWQgdG8gcmV0dXJuIHZhbHVlcyBpbiB0aGUgaW50ZXJ2YWwgWy0xLDFdLgogICAgICAgIHJldHVybiA3MCAqIChuMCArIG4xICsgbjIpOwogICAgfQogICAgLyoqCiAgICAgKiBAY2xhc3MgQWJzdHJhY3QgRk9WIGFsZ29yaXRobQogICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlnaHRQYXNzZXNDYWxsYmFjayBEb2VzIHRoZSBsaWdodCBwYXNzIHRocm91Z2ggeCx5PwogICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXQogICAgICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLnRvcG9sb2d5PThdIDQvNi84CiAgICAgKi8KICAgIFJPVC5GT1YgPSBmdW5jdGlvbihsaWdodFBhc3Nlc0NhbGxiYWNrLCBvcHRpb25zKQogICAgewogICAgICAgIHRoaXMuX2xpZ2h0UGFzc2VzID0gbGlnaHRQYXNzZXNDYWxsYmFjazsKICAgICAgICB0aGlzLl9vcHRpb25zID0gewogICAgICAgICAgICB0b3BvbG9neTogOAogICAgICAgIH07CiAgICAgICAgZm9yICh2YXIgcCBpbiBvcHRpb25zKQogICAgICAgIHsKICAgICAgICAgICAgdGhpcy5fb3B0aW9uc1twXSA9IG9wdGlvbnNbcF07CiAgICAgICAgfQogICAgfTsKCiAgICAvKioKICAgICAqIENvbXB1dGUgdmlzaWJpbGl0eSBmb3IgYSAzNjAtZGVncmVlIGNpcmNsZQogICAgICogQHBhcmFtIHtpbnR9IHgKICAgICAqIEBwYXJhbSB7aW50fSB5CiAgICAgKiBAcGFyYW0ge2ludH0gUiBNYXhpbXVtIHZpc2liaWxpdHkgcmFkaXVzCiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjawogICAgICovCiAgICBST1QuRk9WLnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24oeCwgeSwgUiwgY2FsbGJhY2spCiAgICB7fTsKCiAgICAvKioKICAgICAqIFJldHVybiBhbGwgbmVpZ2hib3JzIGluIGEgY29uY2VudHJpYyByaW5nCiAgICAgKiBAcGFyYW0ge2ludH0gY3ggY2VudGVyLXgKICAgICAqIEBwYXJhbSB7aW50fSBjeSBjZW50ZXIteQogICAgICogQHBhcmFtIHtpbnR9IHIgcmFuZ2UKICAgICAqLwogICAgUk9ULkZPVi5wcm90b3R5cGUuX2dldENpcmNsZSA9IGZ1bmN0aW9uKGN4LCBjeSwgcikKICAgIHsKICAgICAgICB2YXIgcmVzdWx0ID0gW107CiAgICAgICAgdmFyIGRpcnMsIGNvdW50RmFjdG9yLCBzdGFydE9mZnNldDsKCiAgICAgICAgc3dpdGNoICh0aGlzLl9vcHRpb25zLnRvcG9sb2d5KQogICAgICAgIHsKICAgICAgICAgICAgY2FzZSA0OgogICAgICAgICAgICAgICAgY291bnRGYWN0b3IgPSAxOwogICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSBbMCwgMV07CiAgICAgICAgICAgICAgICBkaXJzID0gWwogICAgICAgICAgICAgICAgUk9ULkRJUlNbOF1bN10sCiAgICAgICAgICAgICAgICBST1QuRElSU1s4XVsxXSwKICAgICAgICAgICAgICAgIFJPVC5ESVJTWzhdWzNdLAogICAgICAgICAgICAgICAgUk9ULkRJUlNbOF1bNV0KICAgICAgICAgICAgXTsKICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgY2FzZSA2OgogICAgICAgICAgICAgICAgZGlycyA9IFJPVC5ESVJTWzZdOwogICAgICAgICAgICAgICAgY291bnRGYWN0b3IgPSAxOwogICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSBbLTEsIDFdOwogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDg6CiAgICAgICAgICAgICAgICBkaXJzID0gUk9ULkRJUlNbNF07CiAgICAgICAgICAgICAgICBjb3VudEZhY3RvciA9IDI7CiAgICAgICAgICAgICAgICBzdGFydE9mZnNldCA9IFstMSwgMV07CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICB9CgogICAgICAgIC8qIHN0YXJ0aW5nIG5laWdoYm9yICovCiAgICAgICAgdmFyIHggPSBjeCArIHN0YXJ0T2Zmc2V0WzBdICogcjsKICAgICAgICB2YXIgeSA9IGN5ICsgc3RhcnRPZmZzZXRbMV0gKiByOwoKICAgICAgICAvKiBjaXJjbGUgKi8KICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspCiAgICAgICAgewogICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHIgKiBjb3VudEZhY3RvcjsgaisrKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbeCwgeV0pOwogICAgICAgICAgICAgICAgeCArPSBkaXJzW2ldWzBdOwogICAgICAgICAgICAgICAgeSArPSBkaXJzW2ldWzFdOwoKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH07CiAgICAvKioKICAgICAqIEBjbGFzcyBEaXNjcmV0ZSBzaGFkb3djYXN0aW5nIGFsZ29yaXRobS4gT2Jzb2xldGVkIGJ5IFByZWNpc2Ugc2hhZG93Y2FzdGluZy4KICAgICAqIEBhdWdtZW50cyBST1QuRk9WCiAgICAgKi8KICAgIFJPVC5GT1YuRGlzY3JldGVTaGFkb3djYXN0aW5nID0gZnVuY3Rpb24obGlnaHRQYXNzZXNDYWxsYmFjaywgb3B0aW9ucykKICAgIHsKICAgICAgICBST1QuRk9WLmNhbGwodGhpcywgbGlnaHRQYXNzZXNDYWxsYmFjaywgb3B0aW9ucyk7CiAgICB9OwogICAgUk9ULkZPVi5EaXNjcmV0ZVNoYWRvd2Nhc3RpbmcuZXh0ZW5kKFJPVC5GT1YpOwoKICAgIC8qKgogICAgICogQHNlZSBST1QuRk9WI2NvbXB1dGUKICAgICAqLwogICAgUk9ULkZPVi5EaXNjcmV0ZVNoYWRvd2Nhc3RpbmcucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbih4LCB5LCBSLCBjYWxsYmFjaykKICAgIHsKICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5fY29vcmRzOwogICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7CgogICAgICAgIC8qIHRoaXMgcGxhY2UgaXMgYWx3YXlzIHZpc2libGUgKi8KICAgICAgICBjYWxsYmFjayh4LCB5LCAwLCAxKTsKCiAgICAgICAgLyogc3RhbmRpbmcgaW4gYSBkYXJrIHBsYWNlLiBGSVhNRSBpcyB0aGlzIGEgZ29vZCBpZGVhPyAgKi8KICAgICAgICBpZiAoIXRoaXMuX2xpZ2h0UGFzc2VzKHgsIHkpKQogICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgLyogc3RhcnQgYW5kIGVuZCBhbmdsZXMgKi8KICAgICAgICB2YXIgREFUQSA9IFtdOwoKICAgICAgICB2YXIgQSwgQiwgY3gsIGN5LCBibG9ja3M7CgogICAgICAgIC8qIGFuYWx5emUgc3Vycm91bmRpbmcgY2VsbHMgaW4gY29uY2VudHJpYyByaW5ncywgc3RhcnRpbmcgZnJvbSB0aGUgY2VudGVyICovCiAgICAgICAgZm9yICh2YXIgciA9IDE7IHIgPD0gUjsgcisrKQogICAgICAgIHsKICAgICAgICAgICAgdmFyIG5laWdoYm9ycyA9IHRoaXMuX2dldENpcmNsZSh4LCB5LCByKTsKICAgICAgICAgICAgdmFyIGFuZ2xlID0gMzYwIC8gbmVpZ2hib3JzLmxlbmd0aDsKCiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBjeCA9IG5laWdoYm9yc1tpXVswXTsKICAgICAgICAgICAgICAgIGN5ID0gbmVpZ2hib3JzW2ldWzFdOwogICAgICAgICAgICAgICAgQSA9IGFuZ2xlICogKGkgLSAwLjUpOwogICAgICAgICAgICAgICAgQiA9IEEgKyBhbmdsZTsKCiAgICAgICAgICAgICAgICBibG9ja3MgPSAhdGhpcy5fbGlnaHRQYXNzZXMoY3gsIGN5KTsKICAgICAgICAgICAgICAgIGlmICh0aGlzLl92aXNpYmxlQ29vcmRzKE1hdGguZmxvb3IoQSksIE1hdGguY2VpbChCKSwgYmxvY2tzLCBEQVRBKSkKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhjeCwgY3ksIHIsIDEpOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGlmIChEQVRBLmxlbmd0aCA9PSAyICYmIERBVEFbMF0gPT0gMCAmJiBEQVRBWzFdID09IDM2MCkKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgICB9IC8qIGN1dG9mZj8gKi8KCiAgICAgICAgICAgIH0gLyogZm9yIGFsbCBjZWxscyBpbiB0aGlzIHJpbmcgKi8KICAgICAgICB9IC8qIGZvciBhbGwgcmluZ3MgKi8KICAgIH07CgogICAgLyoqCiAgICAgKiBAcGFyYW0ge2ludH0gQSBzdGFydCBhbmdsZQogICAgICogQHBhcmFtIHtpbnR9IEIgZW5kIGFuZ2xlCiAgICAgKiBAcGFyYW0ge2Jvb2x9IGJsb2NrcyBEb2VzIGN1cnJlbnQgY2VsbCBibG9jayB2aXNpYmlsaXR5PwogICAgICogQHBhcmFtIHtpbnRbXVtdfSBEQVRBIHNoYWRvd2VkIGFuZ2xlIHBhaXJzCiAgICAgKi8KICAgIFJPVC5GT1YuRGlzY3JldGVTaGFkb3djYXN0aW5nLnByb3RvdHlwZS5fdmlzaWJsZUNvb3JkcyA9IGZ1bmN0aW9uKEEsIEIsIGJsb2NrcywgREFUQSkKICAgIHsKICAgICAgICBpZiAoQSA8IDApCiAgICAgICAgewogICAgICAgICAgICB2YXIgdjEgPSB0aGlzLl92aXNpYmxlQ29vcmRzKDAsIEIsIGJsb2NrcywgREFUQSk7CiAgICAgICAgICAgIHZhciB2MiA9IHRoaXMuX3Zpc2libGVDb29yZHMoMzYwICsgQSwgMzYwLCBibG9ja3MsIERBVEEpOwogICAgICAgICAgICByZXR1cm4gdjEgfHwgdjI7CiAgICAgICAgfQoKICAgICAgICB2YXIgaW5kZXggPSAwOwogICAgICAgIHdoaWxlIChpbmRleCA8IERBVEEubGVuZ3RoICYmIERBVEFbaW5kZXhdIDwgQSkKICAgICAgICB7CiAgICAgICAgICAgIGluZGV4Kys7CiAgICAgICAgfQoKICAgICAgICBpZiAoaW5kZXggPT0gREFUQS5sZW5ndGgpCiAgICAgICAgeyAvKiBjb21wbGV0ZWx5IG5ldyBzaGFkb3cgKi8KICAgICAgICAgICAgaWYgKGJsb2NrcykKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgREFUQS5wdXNoKEEsIEIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KCiAgICAgICAgdmFyIGNvdW50ID0gMDsKCiAgICAgICAgaWYgKGluZGV4ICUgMikKICAgICAgICB7IC8qIHRoaXMgc2hhZG93IHN0YXJ0cyBpbiBhbiBleGlzdGluZyBzaGFkb3csIG9yIHdpdGhpbiBpdHMgZW5kaW5nIGJvdW5kYXJ5ICovCiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IERBVEEubGVuZ3RoICYmIERBVEFbaW5kZXhdIDwgQikKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgaW5kZXgrKzsKICAgICAgICAgICAgICAgIGNvdW50Kys7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmIChjb3VudCA9PSAwKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmIChibG9ja3MpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGlmIChjb3VudCAlIDIpCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgREFUQS5zcGxpY2UoaW5kZXggLSBjb3VudCwgY291bnQsIEIpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIERBVEEuc3BsaWNlKGluZGV4IC0gY291bnQsIGNvdW50KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgcmV0dXJuIHRydWU7CgogICAgICAgIH0KICAgICAgICBlbHNlCiAgICAgICAgeyAvKiB0aGlzIHNoYWRvdyBzdGFydHMgb3V0c2lkZSBhbiBleGlzdGluZyBzaGFkb3csIG9yIHdpdGhpbiBhIHN0YXJ0aW5nIGJvdW5kYXJ5ICovCiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IERBVEEubGVuZ3RoICYmIERBVEFbaW5kZXhdIDwgQikKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgaW5kZXgrKzsKICAgICAgICAgICAgICAgIGNvdW50Kys7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8qIHZpc2libGUgd2hlbiBvdXRzaWRlIGFuIGV4aXN0aW5nIHNoYWRvdywgb3Igd2hlbiBvdmVybGFwcGluZyAqLwogICAgICAgICAgICBpZiAoQSA9PSBEQVRBW2luZGV4IC0gY291bnRdICYmIGNvdW50ID09IDEpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKGJsb2NrcykKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgaWYgKGNvdW50ICUgMikKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBEQVRBLnNwbGljZShpbmRleCAtIGNvdW50LCBjb3VudCwgQSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgREFUQS5zcGxpY2UoaW5kZXggLSBjb3VudCwgY291bnQsIEEsIEIpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9CiAgICB9OwogICAgLyoqCiAgICAgKiBAY2xhc3MgUHJlY2lzZSBzaGFkb3djYXN0aW5nIGFsZ29yaXRobQogICAgICogQGF1Z21lbnRzIFJPVC5GT1YKICAgICAqLwogICAgUk9ULkZPVi5QcmVjaXNlU2hhZG93Y2FzdGluZyA9IGZ1bmN0aW9uKGxpZ2h0UGFzc2VzQ2FsbGJhY2ssIG9wdGlvbnMpCiAgICB7CiAgICAgICAgUk9ULkZPVi5jYWxsKHRoaXMsIGxpZ2h0UGFzc2VzQ2FsbGJhY2ssIG9wdGlvbnMpOwogICAgfTsKICAgIFJPVC5GT1YuUHJlY2lzZVNoYWRvd2Nhc3RpbmcuZXh0ZW5kKFJPVC5GT1YpOwoKICAgIC8qKgogICAgICogQHNlZSBST1QuRk9WI2NvbXB1dGUKICAgICAqLwogICAgUk9ULkZPVi5QcmVjaXNlU2hhZG93Y2FzdGluZy5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uKHgsIHksIFIsIGNhbGxiYWNrKQogICAgewogICAgICAgIC8qIHRoaXMgcGxhY2UgaXMgYWx3YXlzIHZpc2libGUgKi8KICAgICAgICBjYWxsYmFjayh4LCB5LCAwLCAxKTsKCiAgICAgICAgLyogc3RhbmRpbmcgaW4gYSBkYXJrIHBsYWNlLiBGSVhNRSBpcyB0aGlzIGEgZ29vZCBpZGVhPyAgKi8KICAgICAgICBpZiAoIXRoaXMuX2xpZ2h0UGFzc2VzKHgsIHkpKQogICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgLyogbGlzdCBvZiBhbGwgc2hhZG93cyAqLwogICAgICAgIHZhciBTSEFET1dTID0gW107CgogICAgICAgIHZhciBjeCwgY3ksIGJsb2NrcywgQTEsIEEyLCB2aXNpYmlsaXR5OwoKICAgICAgICAvKiBhbmFseXplIHN1cnJvdW5kaW5nIGNlbGxzIGluIGNvbmNlbnRyaWMgcmluZ3MsIHN0YXJ0aW5nIGZyb20gdGhlIGNlbnRlciAqLwogICAgICAgIGZvciAodmFyIHIgPSAxOyByIDw9IFI7IHIrKykKICAgICAgICB7CiAgICAgICAgICAgIHZhciBuZWlnaGJvcnMgPSB0aGlzLl9nZXRDaXJjbGUoeCwgeSwgcik7CiAgICAgICAgICAgIHZhciBuZWlnaGJvckNvdW50ID0gbmVpZ2hib3JzLmxlbmd0aDsKCiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JDb3VudDsgaSsrKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBjeCA9IG5laWdoYm9yc1tpXVswXTsKICAgICAgICAgICAgICAgIGN5ID0gbmVpZ2hib3JzW2ldWzFdOwogICAgICAgICAgICAgICAgLyogc2hpZnQgaGFsZi1hbi1hbmdsZSBiYWNrd2FyZHMgdG8gbWFpbnRhaW4gY29uc2lzdGVuY3kgb2YgMC10aCBjZWxscyAqLwogICAgICAgICAgICAgICAgQTEgPSBbaSA/IDIgKiBpIC0gMSA6IDIgKiBuZWlnaGJvckNvdW50IC0gMSwgMiAqIG5laWdoYm9yQ291bnRdOwogICAgICAgICAgICAgICAgQTIgPSBbMiAqIGkgKyAxLCAyICogbmVpZ2hib3JDb3VudF07CgogICAgICAgICAgICAgICAgYmxvY2tzID0gIXRoaXMuX2xpZ2h0UGFzc2VzKGN4LCBjeSk7CiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5ID0gdGhpcy5fY2hlY2tWaXNpYmlsaXR5KEExLCBBMiwgYmxvY2tzLCBTSEFET1dTKTsKICAgICAgICAgICAgICAgIGlmICh2aXNpYmlsaXR5KQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGN4LCBjeSwgciwgdmlzaWJpbGl0eSk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgaWYgKFNIQURPV1MubGVuZ3RoID09IDIgJiYgU0hBRE9XU1swXVswXSA9PSAwICYmIFNIQURPV1NbMV1bMF0gPT0gU0hBRE9XU1sxXVsxXSkKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgICB9IC8qIGN1dG9mZj8gKi8KCiAgICAgICAgICAgIH0gLyogZm9yIGFsbCBjZWxscyBpbiB0aGlzIHJpbmcgKi8KICAgICAgICB9IC8qIGZvciBhbGwgcmluZ3MgKi8KICAgIH07CgogICAgLyoqCiAgICAgKiBAcGFyYW0ge2ludFsyXX0gQTEgYXJjIHN0YXJ0CiAgICAgKiBAcGFyYW0ge2ludFsyXX0gQTIgYXJjIGVuZAogICAgICogQHBhcmFtIHtib29sfSBibG9ja3MgRG9lcyBjdXJyZW50IGFyYyBibG9jayB2aXNpYmlsaXR5PwogICAgICogQHBhcmFtIHtpbnRbXVtdfSBTSEFET1dTIGxpc3Qgb2YgYWN0aXZlIHNoYWRvd3MKICAgICAqLwogICAgUk9ULkZPVi5QcmVjaXNlU2hhZG93Y2FzdGluZy5wcm90b3R5cGUuX2NoZWNrVmlzaWJpbGl0eSA9IGZ1bmN0aW9uKEExLCBBMiwgYmxvY2tzLCBTSEFET1dTKQogICAgewogICAgICAgIGlmIChBMVswXSA+IEEyWzBdKQogICAgICAgIHsgLyogc3BsaXQgaW50byB0d28gc3ViLWFyY3MgKi8KICAgICAgICAgICAgdmFyIHYxID0gdGhpcy5fY2hlY2tWaXNpYmlsaXR5KEExLCBbQTFbMV0sIEExWzFdXSwgYmxvY2tzLCBTSEFET1dTKTsKICAgICAgICAgICAgdmFyIHYyID0gdGhpcy5fY2hlY2tWaXNpYmlsaXR5KFswLCAxXSwgQTIsIGJsb2NrcywgU0hBRE9XUyk7CiAgICAgICAgICAgIHJldHVybiAodjEgKyB2MikgLyAyOwogICAgICAgIH0KCiAgICAgICAgLyogaW5kZXgxOiBmaXJzdCBzaGFkb3cgPj0gQTEgKi8KICAgICAgICB2YXIgaW5kZXgxID0gMCwKICAgICAgICAgICAgZWRnZTEgPSBmYWxzZTsKICAgICAgICB3aGlsZSAoaW5kZXgxIDwgU0hBRE9XUy5sZW5ndGgpCiAgICAgICAgewogICAgICAgICAgICB2YXIgb2xkID0gU0hBRE9XU1tpbmRleDFdOwogICAgICAgICAgICB2YXIgZGlmZiA9IG9sZFswXSAqIEExWzFdIC0gQTFbMF0gKiBvbGRbMV07CiAgICAgICAgICAgIGlmIChkaWZmID49IDApCiAgICAgICAgICAgIHsgLyogb2xkID49IEExICovCiAgICAgICAgICAgICAgICBpZiAoZGlmZiA9PSAwICYmICEoaW5kZXgxICUgMikpCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgZWRnZTEgPSB0cnVlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaW5kZXgxKys7CiAgICAgICAgfQoKICAgICAgICAvKiBpbmRleDI6IGxhc3Qgc2hhZG93IDw9IEEyICovCiAgICAgICAgdmFyIGluZGV4MiA9IFNIQURPV1MubGVuZ3RoLAogICAgICAgICAgICBlZGdlMiA9IGZhbHNlOwogICAgICAgIHdoaWxlIChpbmRleDItLSkKICAgICAgICB7CiAgICAgICAgICAgIHZhciBvbGQgPSBTSEFET1dTW2luZGV4Ml07CiAgICAgICAgICAgIHZhciBkaWZmID0gQTJbMF0gKiBvbGRbMV0gLSBvbGRbMF0gKiBBMlsxXTsKICAgICAgICAgICAgaWYgKGRpZmYgPj0gMCkKICAgICAgICAgICAgeyAvKiBvbGQgPD0gQTIgKi8KICAgICAgICAgICAgICAgIGlmIChkaWZmID09IDAgJiYgKGluZGV4MiAlIDIpKQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIGVkZ2UyID0gdHJ1ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICB2YXIgdmlzaWJsZSA9IHRydWU7CiAgICAgICAgaWYgKGluZGV4MSA9PSBpbmRleDIgJiYgKGVkZ2UxIHx8IGVkZ2UyKSkKICAgICAgICB7IC8qIHN1YnNldCBvZiBleGlzdGluZyBzaGFkb3csIG9uZSBvZiB0aGUgZWRnZXMgbWF0Y2ggKi8KICAgICAgICAgICAgdmlzaWJsZSA9IGZhbHNlOwogICAgICAgIH0KICAgICAgICBlbHNlIGlmIChlZGdlMSAmJiBlZGdlMiAmJiBpbmRleDEgKyAxID09IGluZGV4MiAmJiAoaW5kZXgyICUgMikpCiAgICAgICAgeyAvKiBjb21wbGV0ZWx5IGVxdWl2YWxlbnQgd2l0aCBleGlzdGluZyBzaGFkb3cgKi8KICAgICAgICAgICAgdmlzaWJsZSA9IGZhbHNlOwogICAgICAgIH0KICAgICAgICBlbHNlIGlmIChpbmRleDEgPiBpbmRleDIgJiYgKGluZGV4MSAlIDIpKQogICAgICAgIHsgLyogc3Vic2V0IG9mIGV4aXN0aW5nIHNoYWRvdywgbm90IHRvdWNoaW5nICovCiAgICAgICAgICAgIHZpc2libGUgPSBmYWxzZTsKICAgICAgICB9CgogICAgICAgIGlmICghdmlzaWJsZSkKICAgICAgICB7CiAgICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0gLyogZmFzdCBjYXNlOiBub3QgdmlzaWJsZSAqLwoKICAgICAgICB2YXIgdmlzaWJsZUxlbmd0aCwgUDsKCiAgICAgICAgLyogY29tcHV0ZSB0aGUgbGVuZ3RoIG9mIHZpc2libGUgYXJjLCBhZGp1c3QgbGlzdCBvZiBzaGFkb3dzIChpZiBibG9ja2luZykgKi8KICAgICAgICB2YXIgcmVtb3ZlID0gaW5kZXgyIC0gaW5kZXgxICsgMTsKICAgICAgICBpZiAocmVtb3ZlICUgMikKICAgICAgICB7CiAgICAgICAgICAgIGlmIChpbmRleDEgJSAyKQogICAgICAgICAgICB7IC8qIGZpcnN0IGVkZ2Ugd2l0aGluIGV4aXN0aW5nIHNoYWRvdywgc2Vjb25kIG91dHNpZGUgKi8KICAgICAgICAgICAgICAgIHZhciBQID0gU0hBRE9XU1tpbmRleDFdOwogICAgICAgICAgICAgICAgdmlzaWJsZUxlbmd0aCA9IChBMlswXSAqIFBbMV0gLSBQWzBdICogQTJbMV0pIC8gKFBbMV0gKiBBMlsxXSk7CiAgICAgICAgICAgICAgICBpZiAoYmxvY2tzKQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIFNIQURPV1Muc3BsaWNlKGluZGV4MSwgcmVtb3ZlLCBBMik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZQogICAgICAgICAgICB7IC8qIHNlY29uZCBlZGdlIHdpdGhpbiBleGlzdGluZyBzaGFkb3csIGZpcnN0IG91dHNpZGUgKi8KICAgICAgICAgICAgICAgIHZhciBQID0gU0hBRE9XU1tpbmRleDJdOwogICAgICAgICAgICAgICAgdmlzaWJsZUxlbmd0aCA9IChQWzBdICogQTFbMV0gLSBBMVswXSAqIFBbMV0pIC8gKEExWzFdICogUFsxXSk7CiAgICAgICAgICAgICAgICBpZiAoYmxvY2tzKQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIFNIQURPV1Muc3BsaWNlKGluZGV4MSwgcmVtb3ZlLCBBMSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZWxzZQogICAgICAgIHsKICAgICAgICAgICAgaWYgKGluZGV4MSAlIDIpCiAgICAgICAgICAgIHsgLyogYm90aCBlZGdlcyB3aXRoaW4gZXhpc3Rpbmcgc2hhZG93cyAqLwogICAgICAgICAgICAgICAgdmFyIFAxID0gU0hBRE9XU1tpbmRleDFdOwogICAgICAgICAgICAgICAgdmFyIFAyID0gU0hBRE9XU1tpbmRleDJdOwogICAgICAgICAgICAgICAgdmlzaWJsZUxlbmd0aCA9IChQMlswXSAqIFAxWzFdIC0gUDFbMF0gKiBQMlsxXSkgLyAoUDFbMV0gKiBQMlsxXSk7CiAgICAgICAgICAgICAgICBpZiAoYmxvY2tzKQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIFNIQURPV1Muc3BsaWNlKGluZGV4MSwgcmVtb3ZlKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgIHsgLyogYm90aCBlZGdlcyBvdXRzaWRlIGV4aXN0aW5nIHNoYWRvd3MgKi8KICAgICAgICAgICAgICAgIGlmIChibG9ja3MpCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgU0hBRE9XUy5zcGxpY2UoaW5kZXgxLCByZW1vdmUsIEExLCBBMik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4gMTsgLyogd2hvbGUgYXJjIHZpc2libGUhICovCiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIHZhciBhcmNMZW5ndGggPSAoQTJbMF0gKiBBMVsxXSAtIEExWzBdICogQTJbMV0pIC8gKEExWzFdICogQTJbMV0pOwoKICAgICAgICByZXR1cm4gdmlzaWJsZUxlbmd0aCAvIGFyY0xlbmd0aDsKICAgIH07CiAgICAvKioKICAgICAqIEBjbGFzcyBSZWN1cnNpdmUgc2hhZG93Y2FzdGluZyBhbGdvcml0aG0KICAgICAqIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIDQvOCB0b3BvbG9naWVzLCBub3QgaGV4YWdvbmFsLgogICAgICogQmFzZWQgb24gUGV0ZXIgSGFya2lucycgaW1wbGVtZW50YXRpb24gb2YgQmo/cm4gQmVyZ3N0cj9tJ3MgYWxnb3JpdGhtIGRlc2NyaWJlZCBoZXJlOiBodHRwOi8vd3d3LnJvZ3VlYmFzaW4uY29tL2luZGV4LnBocD90aXRsZT1GT1ZfdXNpbmdfcmVjdXJzaXZlX3NoYWRvd2Nhc3RpbmcKICAgICAqIEBhdWdtZW50cyBST1QuRk9WCiAgICAgKi8KICAgIFJPVC5GT1YuUmVjdXJzaXZlU2hhZG93Y2FzdGluZyA9IGZ1bmN0aW9uKGxpZ2h0UGFzc2VzQ2FsbGJhY2ssIG9wdGlvbnMpCiAgICB7CiAgICAgICAgUk9ULkZPVi5jYWxsKHRoaXMsIGxpZ2h0UGFzc2VzQ2FsbGJhY2ssIG9wdGlvbnMpOwogICAgfTsKICAgIFJPVC5GT1YuUmVjdXJzaXZlU2hhZG93Y2FzdGluZy5leHRlbmQoUk9ULkZPVik7CgogICAgLyoqIE9jdGFudHMgdXNlZCBmb3IgdHJhbnNsYXRpbmcgcmVjdXJzaXZlIHNoYWRvd2Nhc3Rpbmcgb2Zmc2V0cyAqLwogICAgUk9ULkZPVi5SZWN1cnNpdmVTaGFkb3djYXN0aW5nLk9DVEFOVFMgPSBbCiAgICBbLTEsIDAsIDAsIDFdLAogICAgWzAsIC0xLCAxLCAwXSwKICAgIFswLCAtMSwgLTEsIDBdLAogICAgWy0xLCAwLCAwLCAtMV0sCiAgICBbMSwgMCwgMCwgLTFdLAogICAgWzAsIDEsIC0xLCAwXSwKICAgIFswLCAxLCAxLCAwXSwKICAgIFsxLCAwLCAwLCAxXQpdOwoKICAgIC8qKgogICAgICogQ29tcHV0ZSB2aXNpYmlsaXR5IGZvciBhIDM2MC1kZWdyZWUgY2lyY2xlCiAgICAgKiBAcGFyYW0ge2ludH0geAogICAgICogQHBhcmFtIHtpbnR9IHkKICAgICAqIEBwYXJhbSB7aW50fSBSIE1heGltdW0gdmlzaWJpbGl0eSByYWRpdXMKICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrCiAgICAgKi8KICAgIFJPVC5GT1YuUmVjdXJzaXZlU2hhZG93Y2FzdGluZy5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uKHgsIHksIFIsIGNhbGxiYWNrKQogICAgewogICAgICAgIC8vWW91IGNhbiBhbHdheXMgc2VlIHlvdXIgb3duIHRpbGUKICAgICAgICBjYWxsYmFjayh4LCB5LCAwLCAxKTsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFJPVC5GT1YuUmVjdXJzaXZlU2hhZG93Y2FzdGluZy5PQ1RBTlRTLmxlbmd0aDsgaSsrKQogICAgICAgIHsKICAgICAgICAgICAgdGhpcy5fcmVuZGVyT2N0YW50KHgsIHksIFJPVC5GT1YuUmVjdXJzaXZlU2hhZG93Y2FzdGluZy5PQ1RBTlRTW2ldLCBSLCBjYWxsYmFjayk7CiAgICAgICAgfQogICAgfTsKCiAgICAvKioKICAgICAqIENvbXB1dGUgdmlzaWJpbGl0eSBmb3IgYSAxODAtZGVncmVlIGFyYwogICAgICogQHBhcmFtIHtpbnR9IHgKICAgICAqIEBwYXJhbSB7aW50fSB5CiAgICAgKiBAcGFyYW0ge2ludH0gUiBNYXhpbXVtIHZpc2liaWxpdHkgcmFkaXVzCiAgICAgKiBAcGFyYW0ge2ludH0gZGlyIERpcmVjdGlvbiB0byBsb29rIGluIChleHByZXNzZWQgaW4gYSBST1QuRElSUyB2YWx1ZSk7CiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjawogICAgICovCiAgICBST1QuRk9WLlJlY3Vyc2l2ZVNoYWRvd2Nhc3RpbmcucHJvdG90eXBlLmNvbXB1dGUxODAgPSBmdW5jdGlvbih4LCB5LCBSLCBkaXIsIGNhbGxiYWNrKQogICAgewogICAgICAgIC8vWW91IGNhbiBhbHdheXMgc2VlIHlvdXIgb3duIHRpbGUKICAgICAgICBjYWxsYmFjayh4LCB5LCAwLCAxKTsKICAgICAgICB2YXIgcHJldmlvdXNPY3RhbnQgPSAoZGlyIC0gMSArIDgpICUgODsgLy9OZWVkIHRvIHJldHJpZXZlIHRoZSBwcmV2aW91cyBvY3RhbnQgdG8gcmVuZGVyIGEgZnVsbCAxODAgZGVncmVlcwogICAgICAgIHZhciBuZXh0UHJldmlvdXNPY3RhbnQgPSAoZGlyIC0gMiArIDgpICUgODsgLy9OZWVkIHRvIHJldHJpZXZlIHRoZSBwcmV2aW91cyB0d28gb2N0YW50cyB0byByZW5kZXIgYSBmdWxsIDE4MCBkZWdyZWVzCiAgICAgICAgdmFyIG5leHRPY3RhbnQgPSAoZGlyICsgMSArIDgpICUgODsgLy9OZWVkIHRvIGdyYWIgdG8gbmV4dCBvY3RhbnQgdG8gcmVuZGVyIGEgZnVsbCAxODAgZGVncmVlcwogICAgICAgIHRoaXMuX3JlbmRlck9jdGFudCh4LCB5LCBST1QuRk9WLlJlY3Vyc2l2ZVNoYWRvd2Nhc3RpbmcuT0NUQU5UU1tuZXh0UHJldmlvdXNPY3RhbnRdLCBSLCBjYWxsYmFjayk7CiAgICAgICAgdGhpcy5fcmVuZGVyT2N0YW50KHgsIHksIFJPVC5GT1YuUmVjdXJzaXZlU2hhZG93Y2FzdGluZy5PQ1RBTlRTW3ByZXZpb3VzT2N0YW50XSwgUiwgY2FsbGJhY2spOwogICAgICAgIHRoaXMuX3JlbmRlck9jdGFudCh4LCB5LCBST1QuRk9WLlJlY3Vyc2l2ZVNoYWRvd2Nhc3RpbmcuT0NUQU5UU1tkaXJdLCBSLCBjYWxsYmFjayk7CiAgICAgICAgdGhpcy5fcmVuZGVyT2N0YW50KHgsIHksIFJPVC5GT1YuUmVjdXJzaXZlU2hhZG93Y2FzdGluZy5PQ1RBTlRTW25leHRPY3RhbnRdLCBSLCBjYWxsYmFjayk7CiAgICB9OwoKICAgIC8qKgogICAgICogQ29tcHV0ZSB2aXNpYmlsaXR5IGZvciBhIDkwLWRlZ3JlZSBhcmMKICAgICAqIEBwYXJhbSB7aW50fSB4CiAgICAgKiBAcGFyYW0ge2ludH0geQogICAgICogQHBhcmFtIHtpbnR9IFIgTWF4aW11bSB2aXNpYmlsaXR5IHJhZGl1cwogICAgICogQHBhcmFtIHtpbnR9IGRpciBEaXJlY3Rpb24gdG8gbG9vayBpbiAoZXhwcmVzc2VkIGluIGEgUk9ULkRJUlMgdmFsdWUpOwogICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sKICAgICAqLwogICAgUk9ULkZPVi5SZWN1cnNpdmVTaGFkb3djYXN0aW5nLnByb3RvdHlwZS5jb21wdXRlOTAgPSBmdW5jdGlvbih4LCB5LCBSLCBkaXIsIGNhbGxiYWNrKQogICAgewogICAgICAgIC8vWW91IGNhbiBhbHdheXMgc2VlIHlvdXIgb3duIHRpbGUKICAgICAgICBjYWxsYmFjayh4LCB5LCAwLCAxKTsKICAgICAgICB2YXIgcHJldmlvdXNPY3RhbnQgPSAoZGlyIC0gMSArIDgpICUgODsgLy9OZWVkIHRvIHJldHJpZXZlIHRoZSBwcmV2aW91cyBvY3RhbnQgdG8gcmVuZGVyIGEgZnVsbCA5MCBkZWdyZWVzCiAgICAgICAgdGhpcy5fcmVuZGVyT2N0YW50KHgsIHksIFJPVC5GT1YuUmVjdXJzaXZlU2hhZG93Y2FzdGluZy5PQ1RBTlRTW2Rpcl0sIFIsIGNhbGxiYWNrKTsKICAgICAgICB0aGlzLl9yZW5kZXJPY3RhbnQoeCwgeSwgUk9ULkZPVi5SZWN1cnNpdmVTaGFkb3djYXN0aW5nLk9DVEFOVFNbcHJldmlvdXNPY3RhbnRdLCBSLCBjYWxsYmFjayk7CiAgICB9OwoKICAgIC8qKgogICAgICogUmVuZGVyIG9uZSBvY3RhbnQgKDQ1LWRlZ3JlZSBhcmMpIG9mIHRoZSB2aWV3c2hlZAogICAgICogQHBhcmFtIHtpbnR9IHgKICAgICAqIEBwYXJhbSB7aW50fSB5CiAgICAgKiBAcGFyYW0ge2ludH0gb2N0YW50IE9jdGFudCB0byBiZSByZW5kZXJlZAogICAgICogQHBhcmFtIHtpbnR9IFIgTWF4aW11bSB2aXNpYmlsaXR5IHJhZGl1cwogICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sKICAgICAqLwogICAgUk9ULkZPVi5SZWN1cnNpdmVTaGFkb3djYXN0aW5nLnByb3RvdHlwZS5fcmVuZGVyT2N0YW50ID0gZnVuY3Rpb24oeCwgeSwgb2N0YW50LCBSLCBjYWxsYmFjaykKICAgIHsKICAgICAgICAvL1JhZGl1cyBpbmNyZW1lbnRlZCBieSAxIHRvIHByb3ZpZGUgc2FtZSBjb3ZlcmFnZSBhcmVhIGFzIG90aGVyIHNoYWRvd2Nhc3RpbmcgcmFkaXVzZXMKICAgICAgICB0aGlzLl9jYXN0VmlzaWJpbGl0eSh4LCB5LCAxLCAxLjAsIDAuMCwgUiArIDEsIG9jdGFudFswXSwgb2N0YW50WzFdLCBvY3RhbnRbMl0sIG9jdGFudFszXSwgY2FsbGJhY2spOwogICAgfTsKCiAgICAvKioKICAgICAqIEFjdHVhbGx5IGNhbGN1bGF0ZXMgdGhlIHZpc2liaWxpdHkKICAgICAqIEBwYXJhbSB7aW50fSBzdGFydFggVGhlIHN0YXJ0aW5nIFggY29vcmRpbmF0ZQogICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0WSBUaGUgc3RhcnRpbmcgWSBjb29yZGluYXRlCiAgICAgKiBAcGFyYW0ge2ludH0gcm93IFRoZSByb3cgdG8gcmVuZGVyCiAgICAgKiBAcGFyYW0ge2Zsb2F0fSB2aXNTbG9wZVN0YXJ0IFRoZSBzbG9wZSB0byBzdGFydCBhdAogICAgICogQHBhcmFtIHtmbG9hdH0gdmlzU2xvcGVFbmQgVGhlIHNsb3BlIHRvIGVuZCBhdAogICAgICogQHBhcmFtIHtpbnR9IHJhZGl1cyBUaGUgcmFkaXVzIHRvIHJlYWNoIG91dCB0bwogICAgICogQHBhcmFtIHtpbnR9IHh4CiAgICAgKiBAcGFyYW0ge2ludH0geHkKICAgICAqIEBwYXJhbSB7aW50fSB5eAogICAgICogQHBhcmFtIHtpbnR9IHl5CiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gdXNlIHdoZW4gd2UgaGl0IGEgYmxvY2sgdGhhdCBpcyB2aXNpYmxlCiAgICAgKi8KICAgIFJPVC5GT1YuUmVjdXJzaXZlU2hhZG93Y2FzdGluZy5wcm90b3R5cGUuX2Nhc3RWaXNpYmlsaXR5ID0gZnVuY3Rpb24oc3RhcnRYLCBzdGFydFksIHJvdywgdmlzU2xvcGVTdGFydCwgdmlzU2xvcGVFbmQsIHJhZGl1cywgeHgsIHh5LCB5eCwgeXksIGNhbGxiYWNrKQogICAgewogICAgICAgIGlmICh2aXNTbG9wZVN0YXJ0IDwgdmlzU2xvcGVFbmQpCiAgICAgICAgewogICAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZvciAodmFyIGkgPSByb3c7IGkgPD0gcmFkaXVzOyBpKyspCiAgICAgICAgewogICAgICAgICAgICB2YXIgZHggPSAtaSAtIDE7CiAgICAgICAgICAgIHZhciBkeSA9IC1pOwogICAgICAgICAgICB2YXIgYmxvY2tlZCA9IGZhbHNlOwogICAgICAgICAgICB2YXIgbmV3U3RhcnQgPSAwOwoKICAgICAgICAgICAgLy8nUm93JyBjb3VsZCBiZSBjb2x1bW4sIG5hbWVzIGhlcmUgYXNzdW1lIG9jdGFudCAwIGFuZCB3b3VsZCBiZSBmbGlwcGVkIGZvciBoYWxmIHRoZSBvY3RhbnRzCiAgICAgICAgICAgIHdoaWxlIChkeCA8PSAwKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBkeCArPSAxOwoKICAgICAgICAgICAgICAgIC8vVHJhbnNsYXRlIGZyb20gcmVsYXRpdmUgY29vcmRpbmF0ZXMgdG8gbWFwIGNvb3JkaW5hdGVzCiAgICAgICAgICAgICAgICB2YXIgbWFwWCA9IHN0YXJ0WCArIGR4ICogeHggKyBkeSAqIHh5OwogICAgICAgICAgICAgICAgdmFyIG1hcFkgPSBzdGFydFkgKyBkeCAqIHl4ICsgZHkgKiB5eTsKCiAgICAgICAgICAgICAgICAvL1JhbmdlIG9mIHRoZSByb3cKICAgICAgICAgICAgICAgIHZhciBzbG9wZVN0YXJ0ID0gKGR4IC0gMC41KSAvIChkeSArIDAuNSk7CiAgICAgICAgICAgICAgICB2YXIgc2xvcGVFbmQgPSAoZHggKyAwLjUpIC8gKGR5IC0gMC41KTsKCiAgICAgICAgICAgICAgICAvL0lnbm9yZSBpZiBub3QgeWV0IGF0IGxlZnQgZWRnZSBvZiBPY3RhbnQKICAgICAgICAgICAgICAgIGlmIChzbG9wZUVuZCA+IHZpc1Nsb3BlU3RhcnQpCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgLy9Eb25lIGlmIHBhc3QgcmlnaHQgZWRnZQogICAgICAgICAgICAgICAgaWYgKHNsb3BlU3RhcnQgPCB2aXNTbG9wZUVuZCkKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAvL0lmIGl0J3MgaW4gcmFuZ2UsIGl0J3MgdmlzaWJsZQogICAgICAgICAgICAgICAgaWYgKChkeCAqIGR4ICsgZHkgKiBkeSkgPCAocmFkaXVzICogcmFkaXVzKSkKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhtYXBYLCBtYXBZLCBpLCAxKTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBpZiAoIWJsb2NrZWQpCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgLy9JZiB0aWxlIGlzIGEgYmxvY2tpbmcgdGlsZSwgY2FzdCBhcm91bmQgaXQKICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2xpZ2h0UGFzc2VzKG1hcFgsIG1hcFkpICYmIGkgPCByYWRpdXMpCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICBibG9ja2VkID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdFZpc2liaWxpdHkoc3RhcnRYLCBzdGFydFksIGkgKyAxLCB2aXNTbG9wZVN0YXJ0LCBzbG9wZVN0YXJ0LCByYWRpdXMsIHh4LCB4eSwgeXgsIHl5LCBjYWxsYmFjayk7CiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXJ0ID0gc2xvcGVFbmQ7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIC8vS2VlcCBuYXJyb3dpbmcgaWYgc2Nhbm5pbmcgYWNyb3NzIGEgYmxvY2sKICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2xpZ2h0UGFzc2VzKG1hcFgsIG1hcFkpKQogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhcnQgPSBzbG9wZUVuZDsKICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAvL0Jsb2NrIGhhcyBlbmRlZAogICAgICAgICAgICAgICAgICAgIGJsb2NrZWQgPSBmYWxzZTsKICAgICAgICAgICAgICAgICAgICB2aXNTbG9wZVN0YXJ0ID0gbmV3U3RhcnQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGJsb2NrZWQpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfTsKICAgIC8qKgogICAgICogQG5hbWVzcGFjZSBDb2xvciBvcGVyYXRpb25zCiAgICAgKi8KICAgIFJPVC5Db2xvciA9IHsKICAgICAgICBmcm9tU3RyaW5nOiBmdW5jdGlvbihzdHIpCiAgICAgICAgewogICAgICAgICAgICB2YXIgY2FjaGVkLCByOwogICAgICAgICAgICBpZiAoc3RyIGluIHRoaXMuX2NhY2hlKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBjYWNoZWQgPSB0aGlzLl9jYWNoZVtzdHJdOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgaWYgKHN0ci5jaGFyQXQoMCkgPT0gIiMiKQogICAgICAgICAgICAgICAgeyAvKiBoZXggcmdiICovCgogICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBzdHIubWF0Y2goL1swLTlhLWZdL2dpKS5tYXAoZnVuY3Rpb24oeCkKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh4LCAxNik7CiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT0gMykKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IHZhbHVlcy5tYXAoZnVuY3Rpb24oeCkKICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggKiAxNzsKICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKQogICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaSArIDFdICs9IDE2ICogdmFsdWVzW2ldOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnNwbGljZShpLCAxKTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWQgPSB2YWx1ZXM7CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGVsc2UgaWYgKChyID0gc3RyLm1hdGNoKC9yZ2JcKChbMC05LCBdKylcKS9pKSkpCiAgICAgICAgICAgICAgICB7IC8qIGRlY2ltYWwgcmdiICovCiAgICAgICAgICAgICAgICAgICAgY2FjaGVkID0gclsxXS5zcGxpdCgvXHMqLFxzKi8pLm1hcChmdW5jdGlvbih4KQogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHgpOwogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgeyAvKiBodG1sIG5hbWUgKi8KICAgICAgICAgICAgICAgICAgICBjYWNoZWQgPSBbMCwgMCwgMF07CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVbc3RyXSA9IGNhY2hlZDsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgcmV0dXJuIGNhY2hlZC5zbGljZSgpOwogICAgICAgIH0sCgogICAgICAgIC8qKgogICAgICAgICAqIEFkZCB0d28gb3IgbW9yZSBjb2xvcnMKICAgICAgICAgKiBAcGFyYW0ge251bWJlcltdfSBjb2xvcjEKICAgICAgICAgKiBAcGFyYW0ge251bWJlcltdfSBjb2xvcjIKICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119CiAgICAgICAgICovCiAgICAgICAgYWRkOiBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMikKICAgICAgICB7CiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjb2xvcjEuc2xpY2UoKTsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJndW1lbnRzLmxlbmd0aDsgaisrKQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSArPSBhcmd1bWVudHNbal1baV07CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9LAoKICAgICAgICAvKioKICAgICAgICAgKiBBZGQgdHdvIG9yIG1vcmUgY29sb3JzLCBNT0RJRklFUyBGSVJTVCBBUkdVTUVOVAogICAgICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGNvbG9yMQogICAgICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGNvbG9yMgogICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0KICAgICAgICAgKi8KICAgICAgICBhZGRfOiBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMikKICAgICAgICB7CiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGFyZ3VtZW50cy5sZW5ndGg7IGorKykKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBjb2xvcjFbaV0gKz0gYXJndW1lbnRzW2pdW2ldOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBjb2xvcjE7CiAgICAgICAgfSwKCiAgICAgICAgLyoqCiAgICAgICAgICogTXVsdGlwbHkgKG1peCkgdHdvIG9yIG1vcmUgY29sb3JzCiAgICAgICAgICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3IxCiAgICAgICAgICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3IyCiAgICAgICAgICogQHJldHVybnMge251bWJlcltdfQogICAgICAgICAqLwogICAgICAgIG11bHRpcGx5OiBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMikKICAgICAgICB7CiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjb2xvcjEuc2xpY2UoKTsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJndW1lbnRzLmxlbmd0aDsgaisrKQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSAqPSBhcmd1bWVudHNbal1baV0gLyAyNTU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBNYXRoLnJvdW5kKHJlc3VsdFtpXSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9LAoKICAgICAgICAvKioKICAgICAgICAgKiBNdWx0aXBseSAobWl4KSB0d28gb3IgbW9yZSBjb2xvcnMsIE1PRElGSUVTIEZJUlNUIEFSR1VNRU5UCiAgICAgICAgICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3IxCiAgICAgICAgICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3IyCiAgICAgICAgICogQHJldHVybnMge251bWJlcltdfQogICAgICAgICAqLwogICAgICAgIG11bHRpcGx5XzogZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIpCiAgICAgICAgewogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBhcmd1bWVudHMubGVuZ3RoOyBqKyspCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgY29sb3IxW2ldICo9IGFyZ3VtZW50c1tqXVtpXSAvIDI1NTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGNvbG9yMVtpXSA9IE1hdGgucm91bmQoY29sb3IxW2ldKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gY29sb3IxOwogICAgICAgIH0sCgogICAgICAgIC8qKgogICAgICAgICAqIEludGVycG9sYXRlIChibGVuZCkgdHdvIGNvbG9ycyB3aXRoIGEgZ2l2ZW4gZmFjdG9yCiAgICAgICAgICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3IxCiAgICAgICAgICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3IyCiAgICAgICAgICogQHBhcmFtIHtmbG9hdH0gW2ZhY3Rvcj0wLjVdIDAuLjEKICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119CiAgICAgICAgICovCiAgICAgICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uKGNvbG9yMSwgY29sb3IyLCBmYWN0b3IpCiAgICAgICAgewogICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGZhY3RvciA9IDAuNTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29sb3IxLnNsaWNlKCk7CiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBNYXRoLnJvdW5kKHJlc3VsdFtpXSArIGZhY3RvciAqIChjb2xvcjJbaV0gLSBjb2xvcjFbaV0pKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0sCgogICAgICAgIC8qKgogICAgICAgICAqIEludGVycG9sYXRlIChibGVuZCkgdHdvIGNvbG9ycyB3aXRoIGEgZ2l2ZW4gZmFjdG9yIGluIEhTTCBtb2RlCiAgICAgICAgICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3IxCiAgICAgICAgICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3IyCiAgICAgICAgICogQHBhcmFtIHtmbG9hdH0gW2ZhY3Rvcj0wLjVdIDAuLjEKICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119CiAgICAgICAgICovCiAgICAgICAgaW50ZXJwb2xhdGVIU0w6IGZ1bmN0aW9uKGNvbG9yMSwgY29sb3IyLCBmYWN0b3IpCiAgICAgICAgewogICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGZhY3RvciA9IDAuNTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgaHNsMSA9IHRoaXMucmdiMmhzbChjb2xvcjEpOwogICAgICAgICAgICB2YXIgaHNsMiA9IHRoaXMucmdiMmhzbChjb2xvcjIpOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgaHNsMVtpXSArPSBmYWN0b3IgKiAoaHNsMltpXSAtIGhzbDFbaV0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0aGlzLmhzbDJyZ2IoaHNsMSk7CiAgICAgICAgfSwKCiAgICAgICAgLyoqCiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHJhbmRvbSBjb2xvciBiYXNlZCBvbiB0aGlzIG9uZQogICAgICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGNvbG9yCiAgICAgICAgICogQHBhcmFtIHtudW1iZXJbXX0gZGlmZiBTZXQgb2Ygc3RhbmRhcmQgZGV2aWF0aW9ucwogICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0KICAgICAgICAgKi8KICAgICAgICByYW5kb21pemU6IGZ1bmN0aW9uKGNvbG9yLCBkaWZmKQogICAgICAgIHsKICAgICAgICAgICAgaWYgKCEoZGlmZiBpbnN0YW5jZW9mIEFycmF5KSkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgZGlmZiA9IE1hdGgucm91bmQoUk9ULlJORy5nZXROb3JtYWwoMCwgZGlmZikpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjb2xvci5zbGljZSgpOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgcmVzdWx0W2ldICs9IChkaWZmIGluc3RhbmNlb2YgQXJyYXkgPyBNYXRoLnJvdW5kKFJPVC5STkcuZ2V0Tm9ybWFsKDAsIGRpZmZbaV0pKSA6IGRpZmYpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgfSwKCiAgICAgICAgLyoqCiAgICAgICAgICogQ29udmVydHMgYW4gUkdCIGNvbG9yIHZhbHVlIHRvIEhTTC4gRXhwZWN0cyAwLi4yNTUgaW5wdXRzLCBwcm9kdWNlcyAwLi4xIG91dHB1dHMuCiAgICAgICAgICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3IKICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119CiAgICAgICAgICovCiAgICAgICAgcmdiMmhzbDogZnVuY3Rpb24oY29sb3IpCiAgICAgICAgewogICAgICAgICAgICB2YXIgciA9IGNvbG9yWzBdIC8gMjU1OwogICAgICAgICAgICB2YXIgZyA9IGNvbG9yWzFdIC8gMjU1OwogICAgICAgICAgICB2YXIgYiA9IGNvbG9yWzJdIC8gMjU1OwoKICAgICAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLAogICAgICAgICAgICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYik7CiAgICAgICAgICAgIHZhciBoLCBzLCBsID0gKG1heCArIG1pbikgLyAyOwoKICAgICAgICAgICAgaWYgKG1heCA9PSBtaW4pCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGggPSBzID0gMDsgLy8gYWNocm9tYXRpYwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47CiAgICAgICAgICAgICAgICBzID0gKGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pKTsKICAgICAgICAgICAgICAgIHN3aXRjaCAobWF4KQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIGNhc2UgcjoKICAgICAgICAgICAgICAgICAgICAgICAgaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICBjYXNlIGc6CiAgICAgICAgICAgICAgICAgICAgICAgIGggPSAoYiAtIHIpIC8gZCArIDI7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIGNhc2UgYjoKICAgICAgICAgICAgICAgICAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBoIC89IDY7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHJldHVybiBbaCwgcywgbF07CiAgICAgICAgfSwKCiAgICAgICAgLyoqCiAgICAgICAgICogQ29udmVydHMgYW4gSFNMIGNvbG9yIHZhbHVlIHRvIFJHQi4gRXhwZWN0cyAwLi4xIGlucHV0cywgcHJvZHVjZXMgMC4uMjU1IG91dHB1dHMuCiAgICAgICAgICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3IKICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119CiAgICAgICAgICovCiAgICAgICAgaHNsMnJnYjogZnVuY3Rpb24oY29sb3IpCiAgICAgICAgewogICAgICAgICAgICB2YXIgbCA9IGNvbG9yWzJdOwoKICAgICAgICAgICAgaWYgKGNvbG9yWzFdID09IDApCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGwgPSBNYXRoLnJvdW5kKGwgKiAyNTUpOwogICAgICAgICAgICAgICAgcmV0dXJuIFtsLCBsLCBsXTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHZhciBodWUycmdiID0gZnVuY3Rpb24ocCwgcSwgdCkKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBpZiAodCA8IDApIHQgKz0gMTsKICAgICAgICAgICAgICAgICAgICBpZiAodCA+IDEpIHQgLT0gMTsKICAgICAgICAgICAgICAgICAgICBpZiAodCA8IDEgLyA2KSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDsKICAgICAgICAgICAgICAgICAgICBpZiAodCA8IDEgLyAyKSByZXR1cm4gcTsKICAgICAgICAgICAgICAgICAgICBpZiAodCA8IDIgLyAzKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgdmFyIHMgPSBjb2xvclsxXTsKICAgICAgICAgICAgICAgIHZhciBxID0gKGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHMpOwogICAgICAgICAgICAgICAgdmFyIHAgPSAyICogbCAtIHE7CiAgICAgICAgICAgICAgICB2YXIgciA9IGh1ZTJyZ2IocCwgcSwgY29sb3JbMF0gKyAxIC8gMyk7CiAgICAgICAgICAgICAgICB2YXIgZyA9IGh1ZTJyZ2IocCwgcSwgY29sb3JbMF0pOwogICAgICAgICAgICAgICAgdmFyIGIgPSBodWUycmdiKHAsIHEsIGNvbG9yWzBdIC0gMSAvIDMpOwogICAgICAgICAgICAgICAgcmV0dXJuIFtNYXRoLnJvdW5kKHIgKiAyNTUpLCBNYXRoLnJvdW5kKGcgKiAyNTUpLCBNYXRoLnJvdW5kKGIgKiAyNTUpXTsKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIHRvUkdCOiBmdW5jdGlvbihjb2xvcikKICAgICAgICB7CiAgICAgICAgICAgIHJldHVybiAicmdiKCIgKyB0aGlzLl9jbGFtcChjb2xvclswXSkgKyAiLCIgKyB0aGlzLl9jbGFtcChjb2xvclsxXSkgKyAiLCIgKyB0aGlzLl9jbGFtcChjb2xvclsyXSkgKyAiKSI7CiAgICAgICAgfSwKCiAgICAgICAgdG9IZXg6IGZ1bmN0aW9uKGNvbG9yKQogICAgICAgIHsKICAgICAgICAgICAgdmFyIHBhcnRzID0gW107CiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX2NsYW1wKGNvbG9yW2ldKS50b1N0cmluZygxNikubHBhZCgiMCIsIDIpKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gIiMiICsgcGFydHMuam9pbigiIik7CiAgICAgICAgfSwKCiAgICAgICAgX2NsYW1wOiBmdW5jdGlvbihudW0pCiAgICAgICAgewogICAgICAgICAgICBpZiAobnVtIDwgMCkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSBpZiAobnVtID4gMjU1KQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICByZXR1cm4gMjU1OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgcmV0dXJuIG51bTsKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIF9jYWNoZTogewogICAgICAgICAgICAiYmxhY2siOiBbMCwgMCwgMF0sCiAgICAgICAgICAgICJuYXZ5IjogWzAsIDAsIDEyOF0sCiAgICAgICAgICAgICJkYXJrYmx1ZSI6IFswLCAwLCAxMzldLAogICAgICAgICAgICAibWVkaXVtYmx1ZSI6IFswLCAwLCAyMDVdLAogICAgICAgICAgICAiYmx1ZSI6IFswLCAwLCAyNTVdLAogICAgICAgICAgICAiZGFya2dyZWVuIjogWzAsIDEwMCwgMF0sCiAgICAgICAgICAgICJncmVlbiI6IFswLCAxMjgsIDBdLAogICAgICAgICAgICAidGVhbCI6IFswLCAxMjgsIDEyOF0sCiAgICAgICAgICAgICJkYXJrY3lhbiI6IFswLCAxMzksIDEzOV0sCiAgICAgICAgICAgICJkZWVwc2t5Ymx1ZSI6IFswLCAxOTEsIDI1NV0sCiAgICAgICAgICAgICJkYXJrdHVycXVvaXNlIjogWzAsIDIwNiwgMjA5XSwKICAgICAgICAgICAgIm1lZGl1bXNwcmluZ2dyZWVuIjogWzAsIDI1MCwgMTU0XSwKICAgICAgICAgICAgImxpbWUiOiBbMCwgMjU1LCAwXSwKICAgICAgICAgICAgInNwcmluZ2dyZWVuIjogWzAsIDI1NSwgMTI3XSwKICAgICAgICAgICAgImFxdWEiOiBbMCwgMjU1LCAyNTVdLAogICAgICAgICAgICAiY3lhbiI6IFswLCAyNTUsIDI1NV0sCiAgICAgICAgICAgICJtaWRuaWdodGJsdWUiOiBbMjUsIDI1LCAxMTJdLAogICAgICAgICAgICAiZG9kZ2VyYmx1ZSI6IFszMCwgMTQ0LCAyNTVdLAogICAgICAgICAgICAiZm9yZXN0Z3JlZW4iOiBbMzQsIDEzOSwgMzRdLAogICAgICAgICAgICAic2VhZ3JlZW4iOiBbNDYsIDEzOSwgODddLAogICAgICAgICAgICAiZGFya3NsYXRlZ3JheSI6IFs0NywgNzksIDc5XSwKICAgICAgICAgICAgImRhcmtzbGF0ZWdyZXkiOiBbNDcsIDc5LCA3OV0sCiAgICAgICAgICAgICJsaW1lZ3JlZW4iOiBbNTAsIDIwNSwgNTBdLAogICAgICAgICAgICAibWVkaXVtc2VhZ3JlZW4iOiBbNjAsIDE3OSwgMTEzXSwKICAgICAgICAgICAgInR1cnF1b2lzZSI6IFs2NCwgMjI0LCAyMDhdLAogICAgICAgICAgICAicm95YWxibHVlIjogWzY1LCAxMDUsIDIyNV0sCiAgICAgICAgICAgICJzdGVlbGJsdWUiOiBbNzAsIDEzMCwgMTgwXSwKICAgICAgICAgICAgImRhcmtzbGF0ZWJsdWUiOiBbNzIsIDYxLCAxMzldLAogICAgICAgICAgICAibWVkaXVtdHVycXVvaXNlIjogWzcyLCAyMDksIDIwNF0sCiAgICAgICAgICAgICJpbmRpZ28iOiBbNzUsIDAsIDEzMF0sCiAgICAgICAgICAgICJkYXJrb2xpdmVncmVlbiI6IFs4NSwgMTA3LCA0N10sCiAgICAgICAgICAgICJjYWRldGJsdWUiOiBbOTUsIDE1OCwgMTYwXSwKICAgICAgICAgICAgImNvcm5mbG93ZXJibHVlIjogWzEwMCwgMTQ5LCAyMzddLAogICAgICAgICAgICAibWVkaXVtYXF1YW1hcmluZSI6IFsxMDIsIDIwNSwgMTcwXSwKICAgICAgICAgICAgImRpbWdyYXkiOiBbMTA1LCAxMDUsIDEwNV0sCiAgICAgICAgICAgICJkaW1ncmV5IjogWzEwNSwgMTA1LCAxMDVdLAogICAgICAgICAgICAic2xhdGVibHVlIjogWzEwNiwgOTAsIDIwNV0sCiAgICAgICAgICAgICJvbGl2ZWRyYWIiOiBbMTA3LCAxNDIsIDM1XSwKICAgICAgICAgICAgInNsYXRlZ3JheSI6IFsxMTIsIDEyOCwgMTQ0XSwKICAgICAgICAgICAgInNsYXRlZ3JleSI6IFsxMTIsIDEyOCwgMTQ0XSwKICAgICAgICAgICAgImxpZ2h0c2xhdGVncmF5IjogWzExOSwgMTM2LCAxNTNdLAogICAgICAgICAgICAibGlnaHRzbGF0ZWdyZXkiOiBbMTE5LCAxMzYsIDE1M10sCiAgICAgICAgICAgICJtZWRpdW1zbGF0ZWJsdWUiOiBbMTIzLCAxMDQsIDIzOF0sCiAgICAgICAgICAgICJsYXduZ3JlZW4iOiBbMTI0LCAyNTIsIDBdLAogICAgICAgICAgICAiY2hhcnRyZXVzZSI6IFsxMjcsIDI1NSwgMF0sCiAgICAgICAgICAgICJhcXVhbWFyaW5lIjogWzEyNywgMjU1LCAyMTJdLAogICAgICAgICAgICAibWFyb29uIjogWzEyOCwgMCwgMF0sCiAgICAgICAgICAgICJwdXJwbGUiOiBbMTI4LCAwLCAxMjhdLAogICAgICAgICAgICAib2xpdmUiOiBbMTI4LCAxMjgsIDBdLAogICAgICAgICAgICAiZ3JheSI6IFsxMjgsIDEyOCwgMTI4XSwKICAgICAgICAgICAgImdyZXkiOiBbMTI4LCAxMjgsIDEyOF0sCiAgICAgICAgICAgICJza3libHVlIjogWzEzNSwgMjA2LCAyMzVdLAogICAgICAgICAgICAibGlnaHRza3libHVlIjogWzEzNSwgMjA2LCAyNTBdLAogICAgICAgICAgICAiYmx1ZXZpb2xldCI6IFsxMzgsIDQzLCAyMjZdLAogICAgICAgICAgICAiZGFya3JlZCI6IFsxMzksIDAsIDBdLAogICAgICAgICAgICAiZGFya21hZ2VudGEiOiBbMTM5LCAwLCAxMzldLAogICAgICAgICAgICAic2FkZGxlYnJvd24iOiBbMTM5LCA2OSwgMTldLAogICAgICAgICAgICAiZGFya3NlYWdyZWVuIjogWzE0MywgMTg4LCAxNDNdLAogICAgICAgICAgICAibGlnaHRncmVlbiI6IFsxNDQsIDIzOCwgMTQ0XSwKICAgICAgICAgICAgIm1lZGl1bXB1cnBsZSI6IFsxNDcsIDExMiwgMjE2XSwKICAgICAgICAgICAgImRhcmt2aW9sZXQiOiBbMTQ4LCAwLCAyMTFdLAogICAgICAgICAgICAicGFsZWdyZWVuIjogWzE1MiwgMjUxLCAxNTJdLAogICAgICAgICAgICAiZGFya29yY2hpZCI6IFsxNTMsIDUwLCAyMDRdLAogICAgICAgICAgICAieWVsbG93Z3JlZW4iOiBbMTU0LCAyMDUsIDUwXSwKICAgICAgICAgICAgInNpZW5uYSI6IFsxNjAsIDgyLCA0NV0sCiAgICAgICAgICAgICJicm93biI6IFsxNjUsIDQyLCA0Ml0sCiAgICAgICAgICAgICJkYXJrZ3JheSI6IFsxNjksIDE2OSwgMTY5XSwKICAgICAgICAgICAgImRhcmtncmV5IjogWzE2OSwgMTY5LCAxNjldLAogICAgICAgICAgICAibGlnaHRibHVlIjogWzE3MywgMjE2LCAyMzBdLAogICAgICAgICAgICAiZ3JlZW55ZWxsb3ciOiBbMTczLCAyNTUsIDQ3XSwKICAgICAgICAgICAgInBhbGV0dXJxdW9pc2UiOiBbMTc1LCAyMzgsIDIzOF0sCiAgICAgICAgICAgICJsaWdodHN0ZWVsYmx1ZSI6IFsxNzYsIDE5NiwgMjIyXSwKICAgICAgICAgICAgInBvd2RlcmJsdWUiOiBbMTc2LCAyMjQsIDIzMF0sCiAgICAgICAgICAgICJmaXJlYnJpY2siOiBbMTc4LCAzNCwgMzRdLAogICAgICAgICAgICAiZGFya2dvbGRlbnJvZCI6IFsxODQsIDEzNCwgMTFdLAogICAgICAgICAgICAibWVkaXVtb3JjaGlkIjogWzE4NiwgODUsIDIxMV0sCiAgICAgICAgICAgICJyb3N5YnJvd24iOiBbMTg4LCAxNDMsIDE0M10sCiAgICAgICAgICAgICJkYXJra2hha2kiOiBbMTg5LCAxODMsIDEwN10sCiAgICAgICAgICAgICJzaWx2ZXIiOiBbMTkyLCAxOTIsIDE5Ml0sCiAgICAgICAgICAgICJtZWRpdW12aW9sZXRyZWQiOiBbMTk5LCAyMSwgMTMzXSwKICAgICAgICAgICAgImluZGlhbnJlZCI6IFsyMDUsIDkyLCA5Ml0sCiAgICAgICAgICAgICJwZXJ1IjogWzIwNSwgMTMzLCA2M10sCiAgICAgICAgICAgICJjaG9jb2xhdGUiOiBbMjEwLCAxMDUsIDMwXSwKICAgICAgICAgICAgInRhbiI6IFsyMTAsIDE4MCwgMTQwXSwKICAgICAgICAgICAgImxpZ2h0Z3JheSI6IFsyMTEsIDIxMSwgMjExXSwKICAgICAgICAgICAgImxpZ2h0Z3JleSI6IFsyMTEsIDIxMSwgMjExXSwKICAgICAgICAgICAgInBhbGV2aW9sZXRyZWQiOiBbMjE2LCAxMTIsIDE0N10sCiAgICAgICAgICAgICJ0aGlzdGxlIjogWzIxNiwgMTkxLCAyMTZdLAogICAgICAgICAgICAib3JjaGlkIjogWzIxOCwgMTEyLCAyMTRdLAogICAgICAgICAgICAiZ29sZGVucm9kIjogWzIxOCwgMTY1LCAzMl0sCiAgICAgICAgICAgICJjcmltc29uIjogWzIyMCwgMjAsIDYwXSwKICAgICAgICAgICAgImdhaW5zYm9ybyI6IFsyMjAsIDIyMCwgMjIwXSwKICAgICAgICAgICAgInBsdW0iOiBbMjIxLCAxNjAsIDIyMV0sCiAgICAgICAgICAgICJidXJseXdvb2QiOiBbMjIyLCAxODQsIDEzNV0sCiAgICAgICAgICAgICJsaWdodGN5YW4iOiBbMjI0LCAyNTUsIDI1NV0sCiAgICAgICAgICAgICJsYXZlbmRlciI6IFsyMzAsIDIzMCwgMjUwXSwKICAgICAgICAgICAgImRhcmtzYWxtb24iOiBbMjMzLCAxNTAsIDEyMl0sCiAgICAgICAgICAgICJ2aW9sZXQiOiBbMjM4LCAxMzAsIDIzOF0sCiAgICAgICAgICAgICJwYWxlZ29sZGVucm9kIjogWzIzOCwgMjMyLCAxNzBdLAogICAgICAgICAgICAibGlnaHRjb3JhbCI6IFsyNDAsIDEyOCwgMTI4XSwKICAgICAgICAgICAgImtoYWtpIjogWzI0MCwgMjMwLCAxNDBdLAogICAgICAgICAgICAiYWxpY2VibHVlIjogWzI0MCwgMjQ4LCAyNTVdLAogICAgICAgICAgICAiaG9uZXlkZXciOiBbMjQwLCAyNTUsIDI0MF0sCiAgICAgICAgICAgICJhenVyZSI6IFsyNDAsIDI1NSwgMjU1XSwKICAgICAgICAgICAgInNhbmR5YnJvd24iOiBbMjQ0LCAxNjQsIDk2XSwKICAgICAgICAgICAgIndoZWF0IjogWzI0NSwgMjIyLCAxNzldLAogICAgICAgICAgICAiYmVpZ2UiOiBbMjQ1LCAyNDUsIDIyMF0sCiAgICAgICAgICAgICJ3aGl0ZXNtb2tlIjogWzI0NSwgMjQ1LCAyNDVdLAogICAgICAgICAgICAibWludGNyZWFtIjogWzI0NSwgMjU1LCAyNTBdLAogICAgICAgICAgICAiZ2hvc3R3aGl0ZSI6IFsyNDgsIDI0OCwgMjU1XSwKICAgICAgICAgICAgInNhbG1vbiI6IFsyNTAsIDEyOCwgMTE0XSwKICAgICAgICAgICAgImFudGlxdWV3aGl0ZSI6IFsyNTAsIDIzNSwgMjE1XSwKICAgICAgICAgICAgImxpbmVuIjogWzI1MCwgMjQwLCAyMzBdLAogICAgICAgICAgICAibGlnaHRnb2xkZW5yb2R5ZWxsb3ciOiBbMjUwLCAyNTAsIDIxMF0sCiAgICAgICAgICAgICJvbGRsYWNlIjogWzI1MywgMjQ1LCAyMzBdLAogICAgICAgICAgICAicmVkIjogWzI1NSwgMCwgMF0sCiAgICAgICAgICAgICJmdWNoc2lhIjogWzI1NSwgMCwgMjU1XSwKICAgICAgICAgICAgIm1hZ2VudGEiOiBbMjU1LCAwLCAyNTVdLAogICAgICAgICAgICAiZGVlcHBpbmsiOiBbMjU1LCAyMCwgMTQ3XSwKICAgICAgICAgICAgIm9yYW5nZXJlZCI6IFsyNTUsIDY5LCAwXSwKICAgICAgICAgICAgInRvbWF0byI6IFsyNTUsIDk5LCA3MV0sCiAgICAgICAgICAgICJob3RwaW5rIjogWzI1NSwgMTA1LCAxODBdLAogICAgICAgICAgICAiY29yYWwiOiBbMjU1LCAxMjcsIDgwXSwKICAgICAgICAgICAgImRhcmtvcmFuZ2UiOiBbMjU1LCAxNDAsIDBdLAogICAgICAgICAgICAibGlnaHRzYWxtb24iOiBbMjU1LCAxNjAsIDEyMl0sCiAgICAgICAgICAgICJvcmFuZ2UiOiBbMjU1LCAxNjUsIDBdLAogICAgICAgICAgICAibGlnaHRwaW5rIjogWzI1NSwgMTgyLCAxOTNdLAogICAgICAgICAgICAicGluayI6IFsyNTUsIDE5MiwgMjAzXSwKICAgICAgICAgICAgImdvbGQiOiBbMjU1LCAyMTUsIDBdLAogICAgICAgICAgICAicGVhY2hwdWZmIjogWzI1NSwgMjE4LCAxODVdLAogICAgICAgICAgICAibmF2YWpvd2hpdGUiOiBbMjU1LCAyMjIsIDE3M10sCiAgICAgICAgICAgICJtb2NjYXNpbiI6IFsyNTUsIDIyOCwgMTgxXSwKICAgICAgICAgICAgImJpc3F1ZSI6IFsyNTUsIDIyOCwgMTk2XSwKICAgICAgICAgICAgIm1pc3R5cm9zZSI6IFsyNTUsIDIyOCwgMjI1XSwKICAgICAgICAgICAgImJsYW5jaGVkYWxtb25kIjogWzI1NSwgMjM1LCAyMDVdLAogICAgICAgICAgICAicGFwYXlhd2hpcCI6IFsyNTUsIDIzOSwgMjEzXSwKICAgICAgICAgICAgImxhdmVuZGVyYmx1c2giOiBbMjU1LCAyNDAsIDI0NV0sCiAgICAgICAgICAgICJzZWFzaGVsbCI6IFsyNTUsIDI0NSwgMjM4XSwKICAgICAgICAgICAgImNvcm5zaWxrIjogWzI1NSwgMjQ4LCAyMjBdLAogICAgICAgICAgICAibGVtb25jaGlmZm9uIjogWzI1NSwgMjUwLCAyMDVdLAogICAgICAgICAgICAiZmxvcmFsd2hpdGUiOiBbMjU1LCAyNTAsIDI0MF0sCiAgICAgICAgICAgICJzbm93IjogWzI1NSwgMjUwLCAyNTBdLAogICAgICAgICAgICAieWVsbG93IjogWzI1NSwgMjU1LCAwXSwKICAgICAgICAgICAgImxpZ2h0eWVsbG93IjogWzI1NSwgMjU1LCAyMjRdLAogICAgICAgICAgICAiaXZvcnkiOiBbMjU1LCAyNTUsIDI0MF0sCiAgICAgICAgICAgICJ3aGl0ZSI6IFsyNTUsIDI1NSwgMjU1XQogICAgICAgIH0KICAgIH07CiAgICAvKioKICAgICAqIEBjbGFzcyBMaWdodGluZyBjb21wdXRhdGlvbiwgYmFzZWQgb24gYSB0cmFkaXRpb25hbCBGT1YgZm9yIG11bHRpcGxlIGxpZ2h0IHNvdXJjZXMgYW5kIG11bHRpcGxlIHBhc3Nlcy4KICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlZmxlY3Rpdml0eUNhbGxiYWNrIENhbGxiYWNrIHRvIHJldHJpZXZlIGNlbGwgcmVmbGVjdGl2aXR5ICgwLi4xKQogICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXQogICAgICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLnBhc3Nlcz0xXSBOdW1iZXIgb2YgcGFzc2VzLiAxIGVxdWFscyB0byBzaW1wbGUgRk9WIG9mIGFsbCBsaWdodCBzb3VyY2VzLCA+MSBtZWFucyBhICpoaWdobHkgc2ltcGxpZmllZCogcmFkaW9zaXR5LWxpa2UgYWxnb3JpdGhtLgogICAgICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLmVtaXNzaW9uVGhyZXNob2xkPTEwMF0gQ2VsbHMgd2l0aCBlbWlzc2l2aXR5ID4gdGhyZXNob2xkIHdpbGwgYmUgdHJlYXRlZCBhcyBsaWdodCBzb3VyY2UgaW4gdGhlIG5leHQgcGFzcy4KICAgICAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5yYW5nZT0xMF0gTWF4IGxpZ2h0IHJhbmdlCiAgICAgKi8KICAgIFJPVC5MaWdodGluZyA9IGZ1bmN0aW9uKHJlZmxlY3Rpdml0eUNhbGxiYWNrLCBvcHRpb25zKQogICAgewogICAgICAgIHRoaXMuX3JlZmxlY3Rpdml0eUNhbGxiYWNrID0gcmVmbGVjdGl2aXR5Q2FsbGJhY2s7CiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHsKICAgICAgICAgICAgcGFzc2VzOiAxLAogICAgICAgICAgICBlbWlzc2lvblRocmVzaG9sZDogMTAwLAogICAgICAgICAgICByYW5nZTogMTAKICAgICAgICB9OwogICAgICAgIHRoaXMuX2ZvdiA9IG51bGw7CgogICAgICAgIHRoaXMuX2xpZ2h0cyA9IHt9OwogICAgICAgIHRoaXMuX3JlZmxlY3Rpdml0eUNhY2hlID0ge307CiAgICAgICAgdGhpcy5fZm92Q2FjaGUgPSB7fTsKCiAgICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpOwogICAgfTsKCiAgICAvKioKICAgICAqIEFkanVzdCBvcHRpb25zIGF0IHJ1bnRpbWUKICAgICAqIEBzZWUgUk9ULkxpZ2h0aW5nCiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdCiAgICAgKi8KICAgIFJPVC5MaWdodGluZy5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpCiAgICB7CiAgICAgICAgZm9yICh2YXIgcCBpbiBvcHRpb25zKQogICAgICAgIHsKICAgICAgICAgICAgdGhpcy5fb3B0aW9uc1twXSA9IG9wdGlvbnNbcF07CiAgICAgICAgfQogICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmFuZ2UpCiAgICAgICAgewogICAgICAgICAgICB0aGlzLnJlc2V0KCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0aGlzOwogICAgfTsKCiAgICAvKioKICAgICAqIFNldCB0aGUgdXNlZCBGaWVsZC1PZi1WaWV3IGFsZ28KICAgICAqIEBwYXJhbSB7Uk9ULkZPVn0gZm92CiAgICAgKi8KICAgIFJPVC5MaWdodGluZy5wcm90b3R5cGUuc2V0Rk9WID0gZnVuY3Rpb24oZm92KQogICAgewogICAgICAgIHRoaXMuX2ZvdiA9IGZvdjsKICAgICAgICB0aGlzLl9mb3ZDYWNoZSA9IHt9OwogICAgICAgIHJldHVybiB0aGlzOwogICAgfTsKCiAgICAvKioKICAgICAqIFNldCAob3IgcmVtb3ZlKSBhIGxpZ2h0IHNvdXJjZQogICAgICogQHBhcmFtIHtpbnR9IHgKICAgICAqIEBwYXJhbSB7aW50fSB5CiAgICAgKiBAcGFyYW0ge251bGwgfHwgc3RyaW5nIHx8IG51bWJlclszXX0gY29sb3IKICAgICAqLwogICAgUk9ULkxpZ2h0aW5nLnByb3RvdHlwZS5zZXRMaWdodCA9IGZ1bmN0aW9uKHgsIHksIGNvbG9yKQogICAgewogICAgICAgIHZhciBrZXkgPSB4ICsgIiwiICsgeTsKCiAgICAgICAgaWYgKGNvbG9yKQogICAgICAgIHsKICAgICAgICAgICAgdGhpcy5fbGlnaHRzW2tleV0gPSAodHlwZW9mKGNvbG9yKSA9PSAic3RyaW5nIiA/IFJPVC5Db2xvci5mcm9tU3RyaW5nKGNvbG9yKSA6IGNvbG9yKTsKICAgICAgICB9CiAgICAgICAgZWxzZQogICAgICAgIHsKICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xpZ2h0c1trZXldOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgIH07CgogICAgLyoqCiAgICAgKiBSZW1vdmUgYWxsIGxpZ2h0IHNvdXJjZXMKICAgICAqLwogICAgUk9ULkxpZ2h0aW5nLnByb3RvdHlwZS5jbGVhckxpZ2h0cyA9IGZ1bmN0aW9uKCkKICAgIHsKICAgICAgICB0aGlzLl9saWdodHMgPSB7fTsKICAgIH07CgogICAgLyoqCiAgICAgKiBSZXNldCB0aGUgcHJlLWNvbXB1dGVkIHRvcG9sb2d5IHZhbHVlcy4gQ2FsbCB3aGVuZXZlciB0aGUgdW5kZXJseWluZyBtYXAgY2hhbmdlcyBpdHMgbGlnaHQtcGFzc2FiaWxpdHkuCiAgICAgKi8KICAgIFJPVC5MaWdodGluZy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpCiAgICB7CiAgICAgICAgdGhpcy5fcmVmbGVjdGl2aXR5Q2FjaGUgPSB7fTsKICAgICAgICB0aGlzLl9mb3ZDYWNoZSA9IHt9OwoKICAgICAgICByZXR1cm4gdGhpczsKICAgIH07CgogICAgLyoqCiAgICAgKiBDb21wdXRlIHRoZSBsaWdodGluZwogICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlnaHRpbmdDYWxsYmFjayBXaWxsIGJlIGNhbGxlZCB3aXRoICh4LCB5LCBjb2xvcikgZm9yIGV2ZXJ5IGxpdCBjZWxsCiAgICAgKi8KICAgIFJPVC5MaWdodGluZy5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uKGxpZ2h0aW5nQ2FsbGJhY2spCiAgICB7CiAgICAgICAgdmFyIGRvbmVDZWxscyA9IHt9OwogICAgICAgIHZhciBlbWl0dGluZ0NlbGxzID0ge307CiAgICAgICAgdmFyIGxpdENlbGxzID0ge307CgogICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9saWdodHMpCiAgICAgICAgeyAvKiBwcmVwYXJlIGVtaXR0ZXJzIGZvciBmaXJzdCBwYXNzICovCiAgICAgICAgICAgIHZhciBsaWdodCA9IHRoaXMuX2xpZ2h0c1trZXldOwogICAgICAgICAgICBlbWl0dGluZ0NlbGxzW2tleV0gPSBbMCwgMCwgMF07CiAgICAgICAgICAgIFJPVC5Db2xvci5hZGRfKGVtaXR0aW5nQ2VsbHNba2V5XSwgbGlnaHQpOwogICAgICAgIH0KCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9vcHRpb25zLnBhc3NlczsgaSsrKQogICAgICAgIHsgLyogbWFpbiBsb29wICovCiAgICAgICAgICAgIHRoaXMuX2VtaXRMaWdodChlbWl0dGluZ0NlbGxzLCBsaXRDZWxscywgZG9uZUNlbGxzKTsKICAgICAgICAgICAgaWYgKGkgKyAxID09IHRoaXMuX29wdGlvbnMucGFzc2VzKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfSAvKiBub3QgZm9yIHRoZSBsYXN0IHBhc3MgKi8KICAgICAgICAgICAgZW1pdHRpbmdDZWxscyA9IHRoaXMuX2NvbXB1dGVFbWl0dGVycyhsaXRDZWxscywgZG9uZUNlbGxzKTsKICAgICAgICB9CgogICAgICAgIGZvciAodmFyIGxpdEtleSBpbiBsaXRDZWxscykKICAgICAgICB7IC8qIGxldCB0aGUgdXNlciBrbm93IHdoYXQgYW5kIGhvdyBpcyBsaXQgKi8KICAgICAgICAgICAgdmFyIHBhcnRzID0gbGl0S2V5LnNwbGl0KCIsIik7CiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQocGFydHNbMF0pOwogICAgICAgICAgICB2YXIgeSA9IHBhcnNlSW50KHBhcnRzWzFdKTsKICAgICAgICAgICAgbGlnaHRpbmdDYWxsYmFjayh4LCB5LCBsaXRDZWxsc1tsaXRLZXldKTsKICAgICAgICB9CgogICAgICAgIHJldHVybiB0aGlzOwogICAgfTsKCiAgICAvKioKICAgICAqIENvbXB1dGUgb25lIGl0ZXJhdGlvbiBmcm9tIGFsbCBlbWl0dGluZyBjZWxscwogICAgICogQHBhcmFtIHtvYmplY3R9IGVtaXR0aW5nQ2VsbHMgVGhlc2UgZW1pdCBsaWdodAogICAgICogQHBhcmFtIHtvYmplY3R9IGxpdENlbGxzIEFkZCBwcm9qZWN0ZWQgbGlnaHQgdG8gdGhlc2UKICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkb25lQ2VsbHMgVGhlc2UgYWxyZWFkeSBlbWl0dGVkLCBmb3JiaWQgdGhlbSBmcm9tIGZ1cnRoZXIgY2FsY3VsYXRpb25zCiAgICAgKi8KICAgIFJPVC5MaWdodGluZy5wcm90b3R5cGUuX2VtaXRMaWdodCA9IGZ1bmN0aW9uKGVtaXR0aW5nQ2VsbHMsIGxpdENlbGxzLCBkb25lQ2VsbHMpCiAgICB7CiAgICAgICAgZm9yICh2YXIga2V5IGluIGVtaXR0aW5nQ2VsbHMpCiAgICAgICAgewogICAgICAgICAgICB2YXIgcGFydHMgPSBrZXkuc3BsaXQoIiwiKTsKICAgICAgICAgICAgdmFyIHggPSBwYXJzZUludChwYXJ0c1swXSk7CiAgICAgICAgICAgIHZhciB5ID0gcGFyc2VJbnQocGFydHNbMV0pOwogICAgICAgICAgICB0aGlzLl9lbWl0TGlnaHRGcm9tQ2VsbCh4LCB5LCBlbWl0dGluZ0NlbGxzW2tleV0sIGxpdENlbGxzKTsKICAgICAgICAgICAgZG9uZUNlbGxzW2tleV0gPSAxOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgIH07CgogICAgLyoqCiAgICAgKiBQcmVwYXJlIGEgbGlzdCBvZiBlbWl0dGVycyBmb3IgbmV4dCBwYXNzCiAgICAgKiBAcGFyYW0ge29iamVjdH0gbGl0Q2VsbHMKICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkb25lQ2VsbHMKICAgICAqIEByZXR1cm5zIHtvYmplY3R9CiAgICAgKi8KICAgIFJPVC5MaWdodGluZy5wcm90b3R5cGUuX2NvbXB1dGVFbWl0dGVycyA9IGZ1bmN0aW9uKGxpdENlbGxzLCBkb25lQ2VsbHMpCiAgICB7CiAgICAgICAgdmFyIHJlc3VsdCA9IHt9OwoKICAgICAgICBmb3IgKHZhciBrZXkgaW4gbGl0Q2VsbHMpCiAgICAgICAgewogICAgICAgICAgICBpZiAoa2V5IGluIGRvbmVDZWxscykKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0gLyogYWxyZWFkeSBlbWl0dGVkICovCgogICAgICAgICAgICB2YXIgY29sb3IgPSBsaXRDZWxsc1trZXldOwoKICAgICAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9yZWZsZWN0aXZpdHlDYWNoZSkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdmFyIHJlZmxlY3Rpdml0eSA9IHRoaXMuX3JlZmxlY3Rpdml0eUNhY2hlW2tleV07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBrZXkuc3BsaXQoIiwiKTsKICAgICAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQocGFydHNbMF0pOwogICAgICAgICAgICAgICAgdmFyIHkgPSBwYXJzZUludChwYXJ0c1sxXSk7CiAgICAgICAgICAgICAgICB2YXIgcmVmbGVjdGl2aXR5ID0gdGhpcy5fcmVmbGVjdGl2aXR5Q2FsbGJhY2soeCwgeSk7CiAgICAgICAgICAgICAgICB0aGlzLl9yZWZsZWN0aXZpdHlDYWNoZVtrZXldID0gcmVmbGVjdGl2aXR5OwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAocmVmbGVjdGl2aXR5ID09IDApCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9IC8qIHdpbGwgbm90IHJlZmxlY3QgYXQgYWxsICovCgogICAgICAgICAgICAvKiBjb21wdXRlIGVtaXNzaW9uIGNvbG9yICovCiAgICAgICAgICAgIHZhciBlbWlzc2lvbiA9IFtdOwogICAgICAgICAgICB2YXIgaW50ZW5zaXR5ID0gMDsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gTWF0aC5yb3VuZChjb2xvcltpXSAqIHJlZmxlY3Rpdml0eSk7CiAgICAgICAgICAgICAgICBlbWlzc2lvbltpXSA9IHBhcnQ7CiAgICAgICAgICAgICAgICBpbnRlbnNpdHkgKz0gcGFydDsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoaW50ZW5zaXR5ID4gdGhpcy5fb3B0aW9ucy5lbWlzc2lvblRocmVzaG9sZCkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBlbWlzc2lvbjsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH07CgogICAgLyoqCiAgICAgKiBDb21wdXRlIG9uZSBpdGVyYXRpb24gZnJvbSBvbmUgY2VsbAogICAgICogQHBhcmFtIHtpbnR9IHgKICAgICAqIEBwYXJhbSB7aW50fSB5CiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBjb2xvcgogICAgICogQHBhcmFtIHtvYmplY3R9IGxpdENlbGxzIENlbGwgZGF0YSB0byBieSB1cGRhdGVkCiAgICAgKi8KICAgIFJPVC5MaWdodGluZy5wcm90b3R5cGUuX2VtaXRMaWdodEZyb21DZWxsID0gZnVuY3Rpb24oeCwgeSwgY29sb3IsIGxpdENlbGxzKQogICAgewogICAgICAgIHZhciBrZXkgPSB4ICsgIiwiICsgeTsKICAgICAgICBpZiAoa2V5IGluIHRoaXMuX2ZvdkNhY2hlKQogICAgICAgIHsKICAgICAgICAgICAgdmFyIGZvdiA9IHRoaXMuX2ZvdkNhY2hlW2tleV07CiAgICAgICAgfQogICAgICAgIGVsc2UKICAgICAgICB7CiAgICAgICAgICAgIHZhciBmb3YgPSB0aGlzLl91cGRhdGVGT1YoeCwgeSk7CiAgICAgICAgfQoKICAgICAgICBmb3IgKHZhciBmb3ZLZXkgaW4gZm92KQogICAgICAgIHsKICAgICAgICAgICAgdmFyIGZvcm1GYWN0b3IgPSBmb3ZbZm92S2V5XTsKCiAgICAgICAgICAgIGlmIChmb3ZLZXkgaW4gbGl0Q2VsbHMpCiAgICAgICAgICAgIHsgLyogYWxyZWFkeSBsaXQgKi8KICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBsaXRDZWxsc1tmb3ZLZXldOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgeyAvKiBuZXdseSBsaXQgKi8KICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbMCwgMCwgMF07CiAgICAgICAgICAgICAgICBsaXRDZWxsc1tmb3ZLZXldID0gcmVzdWx0OwogICAgICAgICAgICB9CgogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgcmVzdWx0W2ldICs9IE1hdGgucm91bmQoY29sb3JbaV0gKiBmb3JtRmFjdG9yKTsKICAgICAgICAgICAgfSAvKiBhZGQgbGlnaHQgY29sb3IgKi8KICAgICAgICB9CgogICAgICAgIHJldHVybiB0aGlzOwogICAgfTsKCiAgICAvKioKICAgICAqIENvbXB1dGUgRk9WICgiZm9ybSBmYWN0b3IiKSBmb3IgYSBwb3RlbnRpYWwgbGlnaHQgc291cmNlIGF0IFt4LHldCiAgICAgKiBAcGFyYW0ge2ludH0geAogICAgICogQHBhcmFtIHtpbnR9IHkKICAgICAqIEByZXR1cm5zIHtvYmplY3R9CiAgICAgKi8KICAgIFJPVC5MaWdodGluZy5wcm90b3R5cGUuX3VwZGF0ZUZPViA9IGZ1bmN0aW9uKHgsIHkpCiAgICB7CiAgICAgICAgdmFyIGtleTEgPSB4ICsgIiwiICsgeTsKICAgICAgICB2YXIgY2FjaGUgPSB7fTsKICAgICAgICB0aGlzLl9mb3ZDYWNoZVtrZXkxXSA9IGNhY2hlOwogICAgICAgIHZhciByYW5nZSA9IHRoaXMuX29wdGlvbnMucmFuZ2U7CiAgICAgICAgdmFyIGNiID0gZnVuY3Rpb24oeCwgeSwgciwgdmlzKQogICAgICAgIHsKICAgICAgICAgICAgdmFyIGtleTIgPSB4ICsgIiwiICsgeTsKICAgICAgICAgICAgdmFyIGZvcm1GYWN0b3IgPSB2aXMgKiAoMSAtIHIgLyByYW5nZSk7CiAgICAgICAgICAgIGlmIChmb3JtRmFjdG9yID09IDApCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICBjYWNoZVtrZXkyXSA9IGZvcm1GYWN0b3I7CiAgICAgICAgfTsKICAgICAgICB0aGlzLl9mb3YuY29tcHV0ZSh4LCB5LCByYW5nZSwgY2IuYmluZCh0aGlzKSk7CgogICAgICAgIHJldHVybiBjYWNoZTsKICAgIH07CiAgICAvKioKICAgICAqIEBjbGFzcyBBYnN0cmFjdCBwYXRoZmluZGVyCiAgICAgKiBAcGFyYW0ge2ludH0gdG9YIFRhcmdldCBYIGNvb3JkCiAgICAgKiBAcGFyYW0ge2ludH0gdG9ZIFRhcmdldCBZIGNvb3JkCiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwYXNzYWJsZUNhbGxiYWNrIENhbGxiYWNrIHRvIGRldGVybWluZSBtYXAgcGFzc2FiaWxpdHkKICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10KICAgICAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy50b3BvbG9neT04XQogICAgICovCiAgICBST1QuUGF0aCA9IGZ1bmN0aW9uKHRvWCwgdG9ZLCBwYXNzYWJsZUNhbGxiYWNrLCBvcHRpb25zKQogICAgewogICAgICAgIHRoaXMuX3RvWCA9IHRvWDsKICAgICAgICB0aGlzLl90b1kgPSB0b1k7CiAgICAgICAgdGhpcy5fZnJvbVggPSBudWxsOwogICAgICAgIHRoaXMuX2Zyb21ZID0gbnVsbDsKICAgICAgICB0aGlzLl9wYXNzYWJsZUNhbGxiYWNrID0gcGFzc2FibGVDYWxsYmFjazsKICAgICAgICB0aGlzLl9vcHRpb25zID0gewogICAgICAgICAgICB0b3BvbG9neTogOAogICAgICAgIH07CiAgICAgICAgZm9yICh2YXIgcCBpbiBvcHRpb25zKQogICAgICAgIHsKICAgICAgICAgICAgdGhpcy5fb3B0aW9uc1twXSA9IG9wdGlvbnNbcF07CiAgICAgICAgfQoKICAgICAgICB0aGlzLl9kaXJzID0gUk9ULkRJUlNbdGhpcy5fb3B0aW9ucy50b3BvbG9neV07CiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMudG9wb2xvZ3kgPT0gOCkKICAgICAgICB7IC8qIHJlb3JkZXIgZGlycyBmb3IgbW9yZSBhZXN0aGV0aWMgcmVzdWx0ICh2ZXJ0aWNhbC9ob3Jpem9udGFsIGZpcnN0KSAqLwogICAgICAgICAgICB0aGlzLl9kaXJzID0gWwogICAgICAgICAgICB0aGlzLl9kaXJzWzBdLAogICAgICAgICAgICB0aGlzLl9kaXJzWzJdLAogICAgICAgICAgICB0aGlzLl9kaXJzWzRdLAogICAgICAgICAgICB0aGlzLl9kaXJzWzZdLAogICAgICAgICAgICB0aGlzLl9kaXJzWzFdLAogICAgICAgICAgICB0aGlzLl9kaXJzWzNdLAogICAgICAgICAgICB0aGlzLl9kaXJzWzVdLAogICAgICAgICAgICB0aGlzLl9kaXJzWzddCiAgICAgICAgXQogICAgICAgIH0KICAgIH07CgogICAgLyoqCiAgICAgKiBDb21wdXRlIGEgcGF0aCBmcm9tIGEgZ2l2ZW4gcG9pbnQKICAgICAqIEBwYXJhbSB7aW50fSBmcm9tWAogICAgICogQHBhcmFtIHtpbnR9IGZyb21ZCiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBXaWxsIGJlIGNhbGxlZCBmb3IgZXZlcnkgcGF0aCBpdGVtIHdpdGggYXJndW1lbnRzICJ4IiBhbmQgInkiCiAgICAgKi8KICAgIFJPVC5QYXRoLnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24oZnJvbVgsIGZyb21ZLCBjYWxsYmFjaykKICAgIHt9OwoKICAgIFJPVC5QYXRoLnByb3RvdHlwZS5fZ2V0TmVpZ2hib3JzID0gZnVuY3Rpb24oY3gsIGN5KQogICAgewogICAgICAgIHZhciByZXN1bHQgPSBbXTsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2RpcnMubGVuZ3RoOyBpKyspCiAgICAgICAgewogICAgICAgICAgICB2YXIgZGlyID0gdGhpcy5fZGlyc1tpXTsKICAgICAgICAgICAgdmFyIHggPSBjeCArIGRpclswXTsKICAgICAgICAgICAgdmFyIHkgPSBjeSArIGRpclsxXTsKCiAgICAgICAgICAgIGlmICghdGhpcy5fcGFzc2FibGVDYWxsYmFjayh4LCB5KSkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmVzdWx0LnB1c2goW3gsIHldKTsKICAgICAgICB9CgogICAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9OwogICAgLyoqCiAgICAgKiBAY2xhc3MgU2ltcGxpZmllZCBEaWprc3RyYSdzIGFsZ29yaXRobTogYWxsIGVkZ2VzIGhhdmUgYSB2YWx1ZSBvZiAxCiAgICAgKiBAYXVnbWVudHMgUk9ULlBhdGgKICAgICAqIEBzZWUgUk9ULlBhdGgKICAgICAqLwogICAgUk9ULlBhdGguRGlqa3N0cmEgPSBmdW5jdGlvbih0b1gsIHRvWSwgcGFzc2FibGVDYWxsYmFjaywgb3B0aW9ucykKICAgIHsKICAgICAgICBST1QuUGF0aC5jYWxsKHRoaXMsIHRvWCwgdG9ZLCBwYXNzYWJsZUNhbGxiYWNrLCBvcHRpb25zKTsKCiAgICAgICAgdGhpcy5fY29tcHV0ZWQgPSB7fTsKICAgICAgICB0aGlzLl90b2RvID0gW107CiAgICAgICAgdGhpcy5fYWRkKHRvWCwgdG9ZLCBudWxsKTsKICAgIH07CiAgICBST1QuUGF0aC5EaWprc3RyYS5leHRlbmQoUk9ULlBhdGgpOwoKICAgIC8qKgogICAgICogQ29tcHV0ZSBhIHBhdGggZnJvbSBhIGdpdmVuIHBvaW50CiAgICAgKiBAc2VlIFJPVC5QYXRoI2NvbXB1dGUKICAgICAqLwogICAgUk9ULlBhdGguRGlqa3N0cmEucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbihmcm9tWCwgZnJvbVksIGNhbGxiYWNrKQogICAgewogICAgICAgIHZhciBrZXkgPSBmcm9tWCArICIsIiArIGZyb21ZOwogICAgICAgIGlmICghKGtleSBpbiB0aGlzLl9jb21wdXRlZCkpCiAgICAgICAgewogICAgICAgICAgICB0aGlzLl9jb21wdXRlKGZyb21YLCBmcm9tWSk7CiAgICAgICAgfQogICAgICAgIGlmICghKGtleSBpbiB0aGlzLl9jb21wdXRlZCkpCiAgICAgICAgewogICAgICAgICAgICByZXR1cm47CiAgICAgICAgfQoKICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2NvbXB1dGVkW2tleV07CiAgICAgICAgd2hpbGUgKGl0ZW0pCiAgICAgICAgewogICAgICAgICAgICBjYWxsYmFjayhpdGVtLngsIGl0ZW0ueSk7CiAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnByZXY7CiAgICAgICAgfQogICAgfTsKCiAgICAvKioKICAgICAqIENvbXB1dGUgYSBub24tY2FjaGVkIHZhbHVlCiAgICAgKi8KICAgIFJPVC5QYXRoLkRpamtzdHJhLnByb3RvdHlwZS5fY29tcHV0ZSA9IGZ1bmN0aW9uKGZyb21YLCBmcm9tWSkKICAgIHsKICAgICAgICB3aGlsZSAodGhpcy5fdG9kby5sZW5ndGgpCiAgICAgICAgewogICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX3RvZG8uc2hpZnQoKTsKICAgICAgICAgICAgaWYgKGl0ZW0ueCA9PSBmcm9tWCAmJiBpdGVtLnkgPT0gZnJvbVkpCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgdmFyIG5laWdoYm9ycyA9IHRoaXMuX2dldE5laWdoYm9ycyhpdGVtLngsIGl0ZW0ueSk7CgogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKykKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdmFyIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldOwogICAgICAgICAgICAgICAgdmFyIHggPSBuZWlnaGJvclswXTsKICAgICAgICAgICAgICAgIHZhciB5ID0gbmVpZ2hib3JbMV07CiAgICAgICAgICAgICAgICB2YXIgaWQgPSB4ICsgIiwiICsgeTsKICAgICAgICAgICAgICAgIGlmIChpZCBpbiB0aGlzLl9jb21wdXRlZCkKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgIH0gLyogYWxyZWFkeSBkb25lICovCiAgICAgICAgICAgICAgICB0aGlzLl9hZGQoeCwgeSwgaXRlbSk7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9OwoKICAgIFJPVC5QYXRoLkRpamtzdHJhLnByb3RvdHlwZS5fYWRkID0gZnVuY3Rpb24oeCwgeSwgcHJldikKICAgIHsKICAgICAgICB2YXIgb2JqID0gewogICAgICAgICAgICB4OiB4LAogICAgICAgICAgICB5OiB5LAogICAgICAgICAgICBwcmV2OiBwcmV2CiAgICAgICAgfTsKICAgICAgICB0aGlzLl9jb21wdXRlZFt4ICsgIiwiICsgeV0gPSBvYmo7CiAgICAgICAgdGhpcy5fdG9kby5wdXNoKG9iaik7CiAgICB9OwogICAgLyoqCiAgICAgKiBAY2xhc3MgU2ltcGxpZmllZCBBKiBhbGdvcml0aG06IGFsbCBlZGdlcyBoYXZlIGEgdmFsdWUgb2YgMQogICAgICogQGF1Z21lbnRzIFJPVC5QYXRoCiAgICAgKiBAc2VlIFJPVC5QYXRoCiAgICAgKi8KICAgIFJPVC5QYXRoLkFTdGFyID0gZnVuY3Rpb24odG9YLCB0b1ksIHBhc3NhYmxlQ2FsbGJhY2ssIG9wdGlvbnMpCiAgICB7CiAgICAgICAgUk9ULlBhdGguY2FsbCh0aGlzLCB0b1gsIHRvWSwgcGFzc2FibGVDYWxsYmFjaywgb3B0aW9ucyk7CgogICAgICAgIHRoaXMuX3RvZG8gPSBbXTsKICAgICAgICB0aGlzLl9kb25lID0ge307CiAgICAgICAgdGhpcy5fZnJvbVggPSBudWxsOwogICAgICAgIHRoaXMuX2Zyb21ZID0gbnVsbDsKICAgIH07CiAgICBST1QuUGF0aC5BU3Rhci5leHRlbmQoUk9ULlBhdGgpOwoKICAgIC8qKgogICAgICogQ29tcHV0ZSBhIHBhdGggZnJvbSBhIGdpdmVuIHBvaW50CiAgICAgKiBAc2VlIFJPVC5QYXRoI2NvbXB1dGUKICAgICAqLwogICAgUk9ULlBhdGguQVN0YXIucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbihmcm9tWCwgZnJvbVksIGNhbGxiYWNrKQogICAgewogICAgICAgIHRoaXMuX3RvZG8gPSBbXTsKICAgICAgICB0aGlzLl9kb25lID0ge307CiAgICAgICAgdGhpcy5fZnJvbVggPSBmcm9tWDsKICAgICAgICB0aGlzLl9mcm9tWSA9IGZyb21ZOwogICAgICAgIHRoaXMuX2FkZCh0aGlzLl90b1gsIHRoaXMuX3RvWSwgbnVsbCk7CgogICAgICAgIHdoaWxlICh0aGlzLl90b2RvLmxlbmd0aCkKICAgICAgICB7CiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5fdG9kby5zaGlmdCgpOwogICAgICAgICAgICB2YXIgaWQgPSBpdGVtLnggKyAiLCIgKyBpdGVtLnk7CiAgICAgICAgICAgIGlmIChpZCBpbiB0aGlzLl9kb25lKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLl9kb25lW2lkXSA9IGl0ZW07CiAgICAgICAgICAgIGlmIChpdGVtLnggPT0gZnJvbVggJiYgaXRlbS55ID09IGZyb21ZKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgdmFyIG5laWdoYm9ycyA9IHRoaXMuX2dldE5laWdoYm9ycyhpdGVtLngsIGl0ZW0ueSk7CgogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKykKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdmFyIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldOwogICAgICAgICAgICAgICAgdmFyIHggPSBuZWlnaGJvclswXTsKICAgICAgICAgICAgICAgIHZhciB5ID0gbmVpZ2hib3JbMV07CiAgICAgICAgICAgICAgICB2YXIgaWQgPSB4ICsgIiwiICsgeTsKICAgICAgICAgICAgICAgIGlmIChpZCBpbiB0aGlzLl9kb25lKQogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdGhpcy5fYWRkKHgsIHksIGl0ZW0pOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2RvbmVbZnJvbVggKyAiLCIgKyBmcm9tWV07CiAgICAgICAgaWYgKCFpdGVtKQogICAgICAgIHsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgd2hpbGUgKGl0ZW0pCiAgICAgICAgewogICAgICAgICAgICBjYWxsYmFjayhpdGVtLngsIGl0ZW0ueSk7CiAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnByZXY7CiAgICAgICAgfQogICAgfTsKCiAgICBST1QuUGF0aC5BU3Rhci5wcm90b3R5cGUuX2FkZCA9IGZ1bmN0aW9uKHgsIHksIHByZXYpCiAgICB7CiAgICAgICAgdmFyIGggPSB0aGlzLl9kaXN0YW5jZSh4LCB5KTsKICAgICAgICB2YXIgb2JqID0gewogICAgICAgICAgICB4OiB4LAogICAgICAgICAgICB5OiB5LAogICAgICAgICAgICBwcmV2OiBwcmV2LAogICAgICAgICAgICBnOiAocHJldiA/IHByZXYuZyArIDEgOiAwKSwKICAgICAgICAgICAgaDogaAogICAgICAgIH07CgogICAgICAgIC8qIGluc2VydCBpbnRvIHByaW9yaXR5IHF1ZXVlICovCgogICAgICAgIHZhciBmID0gb2JqLmcgKyBvYmouaDsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3RvZG8ubGVuZ3RoOyBpKyspCiAgICAgICAgewogICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX3RvZG9baV07CiAgICAgICAgICAgIHZhciBpdGVtRiA9IGl0ZW0uZyArIGl0ZW0uaDsKICAgICAgICAgICAgaWYgKGYgPCBpdGVtRiB8fCAoZiA9PSBpdGVtRiAmJiBoIDwgaXRlbS5oKSkKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdGhpcy5fdG9kby5zcGxpY2UoaSwgMCwgb2JqKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgdGhpcy5fdG9kby5wdXNoKG9iaik7CiAgICB9OwoKICAgIFJPVC5QYXRoLkFTdGFyLnByb3RvdHlwZS5fZGlzdGFuY2UgPSBmdW5jdGlvbih4LCB5KQogICAgewogICAgICAgIHN3aXRjaCAodGhpcy5fb3B0aW9ucy50b3BvbG9neSkKICAgICAgICB7CiAgICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgICAgIHJldHVybiAoTWF0aC5hYnMoeCAtIHRoaXMuX2Zyb21YKSArIE1hdGguYWJzKHkgLSB0aGlzLl9mcm9tWSkpOwogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDY6CiAgICAgICAgICAgICAgICB2YXIgZHggPSBNYXRoLmFicyh4IC0gdGhpcy5fZnJvbVgpOwogICAgICAgICAgICAgICAgdmFyIGR5ID0gTWF0aC5hYnMoeSAtIHRoaXMuX2Zyb21ZKTsKICAgICAgICAgICAgICAgIHJldHVybiBkeSArIE1hdGgubWF4KDAsIChkeCAtIGR5KSAvIDIpOwogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDg6CiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5hYnMoeCAtIHRoaXMuX2Zyb21YKSwgTWF0aC5hYnMoeSAtIHRoaXMuX2Zyb21ZKSk7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICB9CgogICAgICAgIHRocm93IG5ldyBFcnJvcigiSWxsZWdhbCB0b3BvbG9neSIpOwogICAgfTsKICAgIHJldHVybiBST1Q7Cn0pKTs=
@@END rot.js

